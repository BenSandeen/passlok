<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" manifest="passlok.appcache"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>PassLok privacy</title>
    <style type="text/css">
	    body {
		font-family: Sans-Serif;
		margin-left: 1%;
		margin-right: 1%;
		background-color: #FFFFFF;
		color: #000000;
		overflow: auto;
	    }
		.black_overlay{
			display: none;
			position: absolute;
			top: 0%;
			left: 0%;
			width: 100%;
			height: 100%;
			background-color: black;
			z-index:1001;
			-moz-opacity: 0.4;
			opacity:.40;
			filter: alpha(opacity=40);
		}
		.white_content {
			display: none;
			position: absolute;
			top: 15%;
			left: 15%;
			width: 70%;
			height: 70%;
			padding: 0px;
			border: 0px solid gray;
			background-color: white;
			z-index:1002;
			overflow: auto;       
		}
	</style>
      
    <meta name="Keywords" content="passlok, URSA, browser, encryption, decryption, symmetric, public key, signature, AES, ECDH, Diffie, Hellman, elliptic curve, advanced, javascript, PGP, PRISM">
    <meta name="Description" content="PassLok privacy">
    <meta name="author" content="F. Ruiz">
    <meta name="robots" content="index">
    <meta name="viewport" content="width=device-width, minimum-scale=1, maximum-scale=1, user-scalable=no">
	
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="default">
	<link rel="apple-touch-icon" href="passlok-touch-icon.png">
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico">

<script>
        /* 
		@source: https://www.autistici.org/passlok/index.html
		   
        @licstart  The following is the entire license notice for the 
        JavaScript code in this page.

        Copyright (C) 2013  Francisco Ruiz

        The JavaScript code in this page is free software: you can
        redistribute it and/or modify it under the terms of the GNU
        General Public License (GNU GPL) as published by the Free Software
        Foundation, either version 3 of the License, or (at your option)
        any later version.  The code is distributed WITHOUT ANY WARRANTY;
        without even the implied warranty of MERCHANTABILITY or FITNESS
        FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

        As additional permission under GNU GPL version 3 section 7, you
        may distribute non-source (e.g., minimized or compacted) forms of
        that code without the copy of the GNU GPL normally required by
        section 4, provided you include this license notice and a URL
        through which recipients can access the Corresponding Source.   


        @licend  The above is the entire license notice
        for the JavaScript code in this page.
        */
        </script>

<script type="text/javascript">
    if (window.location.protocol == "http:") {				//force SSL/TLS

        var restOfUrl = window.location.href.substr(5);
        window.location = "https:" + restOfUrl;
    }
</script>
		
<script>
// secrets.js - by Alexander Stetsyuk - released under MIT License
//substantial edits by F. Ruiz: since RNG used is from SJCL, RNG check is left to SJCL: RNG checking code removed from here.

(function(exports, global){
var defaults = {
	bits: 8, // default number of bits
	radix: 16, // work with HEX by default
	minBits: 3,
	maxBits: 20, // this permits 1,048,575 shares, though going this high is NOT recommended in JS!
	
	bytesPerChar: 2,
	maxBytesPerChar: 6, // Math.pow(256,7) > Math.pow(2,53)
		
	// Primitive polynomials (in decimal form) for Galois Fields GF(2^n), for 2 <= n <= 30
	// The index of each term in the array corresponds to the n for that polynomial
	// i.e. to get the polynomial for n=16, use primitivePolynomials[16]
	primitivePolynomials: [null,null,1,3,3,5,3,3,29,17,9,5,83,27,43,3,45,9,39,39,9,5,3,33,27,9,71,39,9,5,83],
	
	// warning for insecure PRNG
	warning: 'WARNING:\nA secure random number generator was not found.\nUsing Math.random(), which is NOT cryptographically strong!'
};

// Protected settings object
var config = {};

function init(bits){
	if(bits && (typeof bits !== 'number' || bits%1 !== 0 || bits<defaults.minBits || bits>defaults.maxBits)){
		throw new Error('Number of bits must be an integer between ' + defaults.minBits + ' and ' + defaults.maxBits + ', inclusive.')
	}	
	config.radix = defaults.radix;
	config.bits = bits || defaults.bits;
	config.size = Math.pow(2, config.bits);
	config.max = config.size - 1;
	
	// Construct the exp and log tables for multiplication.	
	var logs = [], exps = [], x = 1, primitive = defaults.primitivePolynomials[config.bits];
	for(var i=0; i<config.size; i++){
		exps[i] = x;
		logs[x] = i;
		x <<= 1;
		if(x >= config.size){
			x ^= primitive;
			x &= config.max;
		}
	}		
	config.logs = logs;
	config.exps = exps;
};

/** @expose **/
exports.init = init;

// Divides a `secret` number String str expressed in radix `inputRadix` (optional, default 16) 
// into `numShares` shares, each expressed in radix `outputRadix` (optional, default to `inputRadix`), 
// requiring `threshold` number of shares to reconstruct the secret. 
// Optionally, zero-pads the secret to a length that is a multiple of padLength before sharing.
/** @expose **/
exports.share = function(secret, numShares, threshold, padLength){
	padLength =  padLength || 0;
		
	if(typeof secret !== 'string'){
		throw new Error('Secret must be a string.');
	}
	if(typeof numShares !== 'number' || numShares%1 !== 0 || numShares < 2){
		throw new Error('Number of shares must be an integer between 2 and 2^bits-1 (' + config.max + '), inclusive.')
	}
	if(numShares > config.max){
		var neededBits = Math.ceil(Math.log(numShares +1)/Math.LN2);
		throw new Error('Number of shares must be an integer between 2 and 2^bits-1 (' + config.max + '), inclusive. To create ' + numShares + ' shares, use at least ' + neededBits + ' bits.')	
	}
	if(typeof threshold !== 'number' || threshold%1 !== 0 || threshold < 2){
		throw new Error('Threshold number of shares must be an integer between 2 and 2^bits-1 (' + config.max + '), inclusive.');
	}
	if(threshold > config.max){
		var neededBits = Math.ceil(Math.log(threshold +1)/Math.LN2);
		throw new Error('Threshold number of shares must be an integer between 2 and 2^bits-1 (' + config.max + '), inclusive.  To use a threshold of ' + threshold + ', use at least ' + neededBits + ' bits.');
	}
	if(typeof padLength !== 'number' || padLength%1 !== 0 ){
		throw new Error('Zero-pad length must be an integer greater than 1.');
	}	
	secret = '1' + hex2bin(secret); // append a 1 so that we can preserve the correct number of leading zeros in our secret
	secret = split(secret, padLength);	
	var x = new Array(numShares), y = new Array(numShares);
	for(var i=0, len = secret.length; i<len; i++){
		var subShares = this._getShares(secret[i], numShares, threshold);
		for(var j=0; j<numShares; j++){
			x[j] = x[j] || subShares[j].x.toString(config.radix);
			y[j] = padLeft(subShares[j].y.toString(2)) + (y[j] ? y[j] : '');
		}
	}
	var padding = config.max.toString(config.radix).length;
	for(var i=0; i<numShares; i++){
		x[i] = config.bits.toString(36) + padLeft(x[i],padding) + bin2hex(y[i]);
	}		
	return x;
};

// This is the basic polynomial generation and evaluation function 
// for a `config.bits`-length secret (NOT an arbitrary length)
// Note: no error-checking at this stage! If `secrets` is NOT 
// a NUMBER less than 2^bits-1, the output will be incorrect!
/** @expose **/
exports._getShares = function(secret, numShares, threshold){	
	var shares = [];
	var coeffs = [secret];
	var limit = Math.pow(2,config.bits); 		
	for(var i=1; i<threshold; i++){
//		coeffs[i] = parseInt(config.rng(config.bits),2);		//original random decimal number of maximum size 2^config.bits
		coeffs[i]=sjcl.bn.random(limit).limbs[0];				//using SJCL RNG
	}
	for(var i=1, len = numShares+1; i<len; i++){
		shares[i-1] = {
			x: i,
			y: horner(i, coeffs)
		}
	}
	return shares;
};
	
// Polynomial evaluation at `x` using Horner's Method
// TODO: this can possibly be sped up using other methods
// NOTE: fx=fx * x + coeff[i] ->  exp(log(fx) + log(x)) + coeff[i], 
//       so if fx===0, just set fx to coeff[i] because
//       using the exp/log form will result in incorrect value
function horner(x, coeffs){
	var logx = config.logs[x];
	var fx = 0;
	for(var i=coeffs.length-1; i>=0; i--){	
		if(fx === 0){
			fx = coeffs[i];
			continue;
		}
		fx = config.exps[ (logx + config.logs[fx]) % config.max ] ^ coeffs[i];
	}
	return fx;
};

function inArray(arr,val){
	for(var i = 0,len=arr.length; i < len; i++) {
		if(arr[i] === val){
   		 return true;
	 	}
 	}
	return false;
};

function processShare(share){
	
	var bits = parseInt(share[0], 36);
	if(bits && (typeof bits !== 'number' || bits%1 !== 0 || bits<defaults.minBits || bits>defaults.maxBits)){
		throw new Error('Number of bits must be an integer between ' + defaults.minBits + ' and ' + defaults.maxBits + ', inclusive.')
	}	
	var max = Math.pow(2, bits) - 1;
	var idLength = max.toString(config.radix).length;
	
	var id = parseInt(share.substr(1, idLength), config.radix);
	if(typeof id !== 'number' || id%1 !== 0 || id<1 || id>max){
		throw new Error('Share id must be an integer between 1 and ' + config.max + ', inclusive.');
	}
	share = share.substr(idLength + 1);
	if(!share.length){
		throw new Error('Invalid share: zero-length share.')
	}
	return {
		'bits': bits,
		'id': id,
		'value': share
	};
};

/** @expose **/
secrets._processShare = processShare;

// Protected method that evaluates the Lagrange interpolation
// polynomial at x=`at` for individual config.bits-length
// segments of each share in the `shares` Array.
// Each share is expressed in base `inputRadix`. The output 
// is expressed in base `outputRadix'
function combine(at, shares){
	var setBits, share, x = [], y = [], result = '', idx;	
	
	for(var i=0, len = shares.length; i<len; i++){
		share = processShare(shares[i]);
		if(typeof setBits === 'undefined'){
			setBits = share['bits'];
		}else if(share['bits'] !== setBits){
			throw new Error('Mismatched shares: Different bit settings.')
		}		
		if(config.bits !== setBits){
			init(setBits);
		}		
		if(inArray(x, share['id'])){ // repeated x value?
			continue;
		}	
		idx = x.push(share['id']) - 1;
		share = split(hex2bin(share['value']));
		for(var j=0, len2 = share.length; j<len2; j++){
			y[j] = y[j] || [];
			y[j][idx] = share[j];
		}
	}	
	for(var i=0, len=y.length; i<len; i++){
		result = padLeft(lagrange(at, x, y[i]).toString(2)) + result;
	}
	if(at===0){// reconstructing the secret
		var idx = result.indexOf('1'); //find the first 1
		return bin2hex(result.slice(idx+1));
	}else{// generating a new share
		return bin2hex(result);
	}
};

// Combine `shares` Array into the original secret
/** @expose **/
exports.combine = function(shares){
	return combine(0, shares);
};

// Generate a new share with id `id` (a number between 1 and 2^bits-1)
// `id` can be a Number or a String in the default radix (16)
/** @expose **/
exports.newShare = function(id, shares){
	if(typeof id === 'string'){
		id = parseInt(id, config.radix);	
	}
	
	var share = processShare(shares[0]);
	var max = Math.pow(2, share['bits']) - 1;
	
	if(typeof id !== 'number' || id%1 !== 0 || id<1 || id>max){
		throw new Error('Share id must be an integer between 1 and ' + config.max + ', inclusive.');
	}

	var padding = max.toString(config.radix).length;
	return config.bits.toString(36) + padLeft(id.toString(config.radix), padding) + combine(id, shares);
};

// Evaluate the Lagrange interpolation polynomial at x = `at`
// using x and y Arrays that are of the same length, with
// corresponding elements constituting points on the polynomial.
function lagrange(at, x, y){
	var sum = 0,
		product, 
		i, j;
		
	for(var i=0, len = x.length; i<len; i++){
		if(!y[i]){
			continue; 
		}			
		product = config.logs[y[i]];
		for(var j=0; j<len; j++){
			if(i === j){ continue; }
			if(at === x[j]){ // happens when computing a share that is in the list of shares used to compute it
				product = -1; // fix for a zero product term, after which the sum should be sum^0 = sum, not sum^1
				break; 
			}
			product = ( product + config.logs[at ^ x[j]] - config.logs[x[i] ^ x[j]] + config.max/* to make sure it's not negative */ ) % config.max;
		}			
		sum = product === -1 ? sum : sum ^ config.exps[product]; // though exps[-1]= undefined and undefined ^ anything = anything in chrome, this behavior may not hold everywhere, so do the check
	}
	return sum;
};

/** @expose **/
exports._lagrange = lagrange;

// Splits a number string `bits`-length segments, after first 
// optionally zero-padding it to a length that is a multiple of `padLength.
// Returns array of integers (each less than 2^bits-1), with each element
// representing a `bits`-length segment of the input string from right to left, 
// i.e. parts[0] represents the right-most `bits`-length segment of the input string.
function split(str, padLength){
	if(padLength){
		str = padLeft(str, padLength)
	}
	var parts = [];
	for(var i=str.length; i>config.bits; i-=config.bits){
		parts.push(parseInt(str.slice(i-config.bits, i), 2));
	}	
	parts.push(parseInt(str.slice(0, i), 2));	
	return parts;
};
	
// Pads a string `str` with zeros on the left so that its length is a multiple of `bits`
function padLeft(str, bits){
	bits = bits || config.bits
	var missing = str.length % bits;
	return (missing ? new Array(bits - missing + 1).join('0') : '') + str;
};

function hex2bin(str){
	var bin = '', num;
	for(var i=str.length - 1; i>=0; i--){
		num = parseInt(str[i], 16)
		if(isNaN(num)){
			throw new Error('Invalid hex character.')
		}
		bin = padLeft(num.toString(2), 4) + bin;
	}
	return bin;
}

function bin2hex(str){
	var hex = '', num;
	str = padLeft(str, 4);
	for(var i=str.length; i>=4; i-=4){
		num = parseInt(str.slice(i-4, i), 2);
		if(isNaN(num)){
			throw new Error('Invalid binary character.')
		}
		hex = num.toString(16) + hex;
	}
	return hex;
}
	
// by default, initialize without an RNG
exports.init();
})(typeof module !== 'undefined' && module['exports'] ? module['exports'] : (window['secrets'] = {}), typeof GLOBAL !== 'undefined' ? GLOBAL : window );
</script> 

<script>
//
//	ULZSS  -- A Data Compression Program for UTF8 string
//
var ULZSS = {};
ULZSS.Window = function(input){
    this.buffer = input;
    this.offset = - ULZSS.N;
    this.current = 0;
    this.size = this.buffer.length;
    this.hash = {};
};
ULZSS.MAX_LEN = 17;
ULZSS.MIN_LEN = 1;
ULZSS.MIN_BYTE = 2;
ULZSS.N = 4096;
ULZSS.NN = 4096 - 0x20;
ULZSS.M = 2 * ULZSS.N;

ULZSS.Window.prototype = {
    next: function(){
	if (this.current == this.size){
	    return false
	}
	if (this.search()){
	    for(var i = 0; i < this.match_len; i++){
		this.insert_hash();
		this.current ++;
	    }
	    this.flag = true
	} else {
	    this.flag = false;
	    this.insert_hash();
	    this.current ++;
	}
	if (this.current > this.offset + ULZSS.N){
	    this.update();
	}
	return true
    },
    search: function(){
	var key = this.buffer.charCodeAt(this.current);
	this.match_len = this.match_pos = 0
	var d;
	if (d = this.hash[key]){
	    for(var i = 0; i < d.length; i++){
		var pos = d[i];
		var real_pos = this.offset + pos;
		if (this.current - real_pos >= ULZSS.NN){
		    continue;
		}
		var j = 0;
		var b = 0;
		while (this.buffer.charCodeAt(real_pos + j) == this.buffer.charCodeAt(this.current + j) &&
		       j < ULZSS.MAX_LEN){
		    b += ULZSS.charSize(this.buffer.charCodeAt(real_pos + j));
		    j ++;
		}
		if( j > ULZSS.MIN_LEN && b > ULZSS.MIN_BYTE && j > this.match_len){
		    this.match_len = j;
		    this.match_pos = this.current - real_pos;
		}
	    }
	    if (this.match_len != 0){
		return true;
	    } else {
		return false;
	    }
	} else {
	    return false;
	}
    },
    insert_hash: function(){
	var code = this.buffer.charCodeAt(this.current);
	if (!this.hash[code]) {
	    this.hash[code] = [];
	}
	this.hash[code].push(this.current - this.offset);
    },
    update: function(){
	var new_hash = {};
	for (var key in this.hash){
	    var d = this.hash[key];
	    var c = false;
	    for(var i = 0; i < d.length; i++){
		if(d[i] > ULZSS.N){
		    if(!c){
			new_hash[key] = [];
			c = true;
		    }
		    new_hash[key].push(d[i] - ULZSS.N);
		}
	    }
	}
	this.offset += ULZSS.N;
	this.hash = new_hash;
    },
    previous_char: function(){
	return this.buffer.charAt(this.current - 1);
    }
}

ULZSS.encode = function(input){
    var window = new ULZSS.Window(input);
    var body = "";
    var buffer = "";
    var flag = 0;
    var mask = 1;
    while (window.next()){
	if (window.flag){
	    flag |= mask;
	    var code = window.match_pos + 
		(window.match_len - ULZSS.MIN_LEN - 1) * 4096;
	    buffer += String.fromCharCode(code + 0x20);
	} else {
	    buffer += window.previous_char();
	}
	mask <<= 1;
	if (mask == 0x40){
	    mask = 1;
	    s = flag + 0x20;
	    body += String.fromCharCode(s);
	    body += buffer;
	    buffer = "";
	    flag = 0;
	}
    }
    if (mask != 1){
	s = flag + 0x20
	body += String.fromCharCode(s);
	body += buffer
    }
    return body
}


ULZSS.decode = function(input){
    var size = input.length;
    var i = 1;
    var current = 0;
    var output = "";
    var mask = 0;
    var flag = input.charCodeAt(0) - 0x20;
    var count = 0;
    while (i < size) {
	if (flag & 1 == 1){
	    var code = input.charCodeAt(i) - 0x20;
	    var match_len = Math.floor(code / 4096) + ULZSS.MIN_LEN + 1;
	    var match_pos = code % 4096;
	    var j = 0, p = current;
	    var k = 0;
	    while(k < match_len){
		output += output.charAt(current - match_pos + k);
		k ++;
	    }
	    current += match_len;
	    i ++;
	} else {
	    output += input.charAt(i);
	    i ++;
	    current ++;
	}
	count ++;
	if(count == 6 && i < size){
	    flag = input.charCodeAt(i) - 0x20;
	    i ++;
	    count = 0;
	}else{
	    flag >>= 1
	}
    }
    return output;
}

ULZSS.charSize = function(d){
    if(d <= 0x7F){
	return 1;
    } else if(d > 0x7FF){
	return 3;
    } else {
	return 2;
    }
}
</script>
       
   <script>

/*SJCL.js begins
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 * @author Jeff Mott
 * @author Stefan Thomas
 */

"use strict";
var sjcl = {
    cipher: {},
    hash: {},
    keyexchange: {},
    mode: {},
    misc: {},
    codec: {},
    exception: {
	corrupt: function (a) {
	    this.toString = function () {
		return "CORRUPT: " + this.message
	    };
	    this.message = a
	},
	invalid: function (a) {
	    this.toString = function () {
		return "INVALID: " + this.message
	    };
	    this.message = a
	},
	bug: function (a) {
	    this.toString = function () {
		return "BUG: " + this.message
	    };
	    this.message = a
	},
	notReady: function (a) {
	    this.toString = function () {
		return "NOT READY: " + this.message
	    };
	    this.message = a
	}
    }
};
if (typeof module != "undefined" && module.exports) module.exports = sjcl;
sjcl.cipher.aes = function (a) {
    this.h[0][0][0] || this.z();
    var b, c, d, e, f = this.h[0][4],
	g = this.h[1];
    b = a.length;
    var h = 1;
    if (b !== 4 && b !== 6 && b !== 8) throw new sjcl.exception.invalid("invalid aes key size");
    this.a = [d = a.slice(0), e = []];
    for (a = b; a < 4 * b + 28; a++) {
	c = d[a - 1];
	if (a % b === 0 || b === 8 && a % b === 4) {
	    c = f[c >>> 24] << 24 ^ f[c >> 16 & 255] << 16 ^ f[c >> 8 & 255] << 8 ^ f[c & 255];
	    if (a % b === 0) {
		c = c << 8 ^ c >>> 24 ^ h << 24;
		h = h << 1 ^ (h >> 7) * 283
	    }
	}
	d[a] = d[a - b] ^ c
    }
    for (b = 0; a; b++, a--) {
	c = d[b & 3 ? a : a - 4];
	e[b] = a <= 4 || b < 4 ? c : g[0][f[c >>> 24]] ^ g[1][f[c >> 16 & 255]] ^ g[2][f[c >> 8 & 255]] ^ g[3][f[c & 255]]
    }
};
sjcl.cipher.aes.prototype = {
    encrypt: function (a) {
	return this.I(a, 0)
    },
    decrypt: function (a) {
	return this.I(a, 1)
    },
    h: [
	[
	    [],
	    [],
	    [],
	    [],
	    []
	],
	[
	    [],
	    [],
	    [],
	    [],
	    []
	]
    ],
    z: function () {
	var a = this.h[0],
	    b = this.h[1],
	    c = a[4],
	    d = b[4],
	    e, f, g, h = [],
	    i = [],
	    k, j, l, m;
	for (e = 0; e < 0x100; e++) i[(h[e] = e << 1 ^ (e >> 7) * 283) ^ e] = e;
	for (f = g = 0; !c[f]; f ^= k || 1, g = i[g] || 1) {
	    l = g ^ g << 1 ^ g << 2 ^ g << 3 ^ g << 4;
	    l = l >> 8 ^ l & 255 ^ 99;
	    c[f] = l;
	    d[l] = f;
	    j = h[e = h[k = h[f]]];
	    m = j * 0x1010101 ^ e * 0x10001 ^ k * 0x101 ^ f * 0x1010100;
	    j = h[l] * 0x101 ^ l * 0x1010100;
	    for (e = 0; e < 4; e++) {
		a[e][f] = j = j << 24 ^ j >>> 8;
		b[e][l] = m = m << 24 ^ m >>> 8
	    }
	}
	for (e = 0; e < 5; e++) {
	    a[e] = a[e].slice(0);
	    b[e] = b[e].slice(0)
	}
    },
    I: function (a, b) {
	if (a.length !== 4) throw new sjcl.exception.invalid("invalid aes block size");
	var c = this.a[b],
	    d = a[0] ^ c[0],
	    e = a[b ? 3 : 1] ^ c[1],
	    f = a[2] ^ c[2];
	a = a[b ? 1 : 3] ^ c[3];
	var g, h, i, k = c.length / 4 - 2,
	    j, l = 4,
	    m = [0, 0, 0, 0];
	g = this.h[b];
	var n = g[0],
	    o = g[1],
	    p = g[2],
	    q = g[3],
	    r = g[4];
	for (j = 0; j < k; j++) {
	    g = n[d >>> 24] ^ o[e >> 16 & 255] ^ p[f >> 8 & 255] ^ q[a & 255] ^ c[l];
	    h = n[e >>> 24] ^ o[f >> 16 & 255] ^ p[a >> 8 & 255] ^ q[d & 255] ^ c[l + 1];
	    i = n[f >>> 24] ^ o[a >> 16 & 255] ^ p[d >> 8 & 255] ^ q[e & 255] ^ c[l + 2];
	    a = n[a >>> 24] ^ o[d >> 16 & 255] ^ p[e >> 8 & 255] ^ q[f & 255] ^ c[l + 3];
	    l += 4;
	    d = g;
	    e = h;
	    f = i
	}
	for (j = 0; j < 4; j++) {
	    m[b ? 3 & -j : j] = r[d >>> 24] << 24 ^ r[e >> 16 & 255] << 16 ^ r[f >> 8 & 255] << 8 ^ r[a & 255] ^ c[l++];
	    g = d;
	    d = e;
	    e = f;
	    f = a;
	    a = g
	}
	return m
    }
};
sjcl.bitArray = {
    bitSlice: function (a, b, c) {
	a = sjcl.bitArray.P(a.slice(b / 32), 32 - (b & 31)).slice(1);
	return c === undefined ? a : sjcl.bitArray.clamp(a, c - b)
    },
    extract: function (a, b, c) {
	var d = Math.floor(-b - c & 31);
	return ((b + c - 1 ^ b) & -32 ? a[b / 32 | 0] << 32 - d ^ a[b / 32 + 1 | 0] >>> d : a[b / 32 | 0] >>> d) & (1 << c) - 1
    },
    concat: function (a, b) {
	if (a.length === 0 || b.length === 0) return a.concat(b);
	var c = a[a.length - 1],
	    d = sjcl.bitArray.getPartial(c);
	return d === 32 ? a.concat(b) : sjcl.bitArray.P(b, d, c | 0, a.slice(0, a.length - 1))
    },
    bitLength: function (a) {
	var b = a.length;
	if (b === 0) return 0;
	return (b - 1) * 32 + sjcl.bitArray.getPartial(a[b - 1])
    },
    clamp: function (a, b) {
	if (a.length * 32 < b) return a;
	a = a.slice(0, Math.ceil(b / 32));
	var c = a.length;
	b &= 31;
	if (c > 0 && b) a[c - 1] = sjcl.bitArray.partial(b, a[c - 1] & 2147483648 >> b - 1, 1);
	return a
    },
    partial: function (a, b, c) {
	if (a === 32) return b;
	return (c ? b | 0 : b << 32 - a) + a * 0x10000000000
    },
    getPartial: function (a) {
	return Math.round(a / 0x10000000000) || 32
    },
    equal: function (a, b) {
	if (sjcl.bitArray.bitLength(a) !== sjcl.bitArray.bitLength(b)) return false;
	var c = 0,
	    d;
	for (d = 0; d < a.length; d++) c |= a[d] ^ b[d];
	return c === 0
    },
    P: function (a, b, c, d) {
	var e;
	e = 0;
	if (d === undefined) d = [];
	for (; b >= 32; b -= 32) {
	    d.push(c);
	    c = 0
	}
	if (b === 0) return d.concat(a);
	for (e = 0; e < a.length; e++) {
	    d.push(c | a[e] >>> b);
	    c = a[e] << 32 - b
	}
	e = a.length ? a[a.length - 1] : 0;
	a = sjcl.bitArray.getPartial(e);
	d.push(sjcl.bitArray.partial(b + a & 31, b + a > 32 ? c : d.pop(), 1));
	return d
    },
    k: function (a, b) {
	return [a[0] ^ b[0], a[1] ^ b[1], a[2] ^ b[2], a[3] ^ b[3]]
    }
};
sjcl.codec.utf8String = {
    fromBits: function (a) {
	var b = "",
	    c = sjcl.bitArray.bitLength(a),
	    d, e;
	for (d = 0; d < c / 8; d++) {
	    if ((d & 3) === 0) e = a[d / 4];
	    b += String.fromCharCode(e >>> 24);
	    e <<= 8
	}
	return decodeURIComponent(escape(b))
    },
    toBits: function (a) {
	a = unescape(encodeURIComponent(a));
	var b = [],
	    c, d = 0;
	for (c = 0; c < a.length; c++) {
	    d = d << 8 | a.charCodeAt(c);
	    if ((c & 3) === 3) {
		b.push(d);
		d = 0
	    }
	}
	c & 3 && b.push(sjcl.bitArray.partial(8 * (c & 3), d));
	return b
    }
};
sjcl.codec.hex = {
    fromBits: function (a) {
	var b = "",
	    c;
	for (c = 0; c < a.length; c++) b += ((a[c] | 0) + 0xf00000000000).toString(16).substr(4);
	return b.substr(0, sjcl.bitArray.bitLength(a) / 4)
    },
    toBits: function (a) {
	var b, c = [],
	    d;
	a = a.replace(/\s|0x/g, "");
	d = a.length;
	a += "00000000";
	for (b = 0; b < a.length; b += 8) c.push(parseInt(a.substr(b, 8), 16) ^ 0);
	return sjcl.bitArray.clamp(c, d * 4)
    }
};
sjcl.codec.base64 = {
    F: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    fromBits: function (a, b, c) {
	var d = "",
	    e = 0,
	    f = sjcl.codec.base64.F,
	    g = 0,
	    h = sjcl.bitArray.bitLength(a);
	if (c) f = f.substr(0, 62) + "-_";
	for (c = 0; d.length * 6 < h;) {
	    d += f.charAt((g ^ a[c] >>> e) >>> 26);
	    if (e < 6) {
		g = a[c] << 6 - e;
		e += 26;
		c++
	    } else {
		g <<= 6;
		e -= 6
	    }
	}
	for (; d.length & 3 && !b;) d += "=";
	return d
    },
    toBits: function (a, b) {
	a = a.replace(/\s|=/g, "");
	var c = [],
	    d = 0,
	    e = sjcl.codec.base64.F,
	    f = 0,
	    g;
	if (b) e = e.substr(0, 62) + "-_";
	for (b = 0; b < a.length; b++) {
	    g = e.indexOf(a.charAt(b));
	    if (g < 0) throw new sjcl.exception.invalid("this isn't base64!");
	    if (d > 26) {
		d -= 26;
		c.push(f ^ g >>> d);
		f = g << 32 - d
	    } else {
		d += 6;
		f ^= g << 32 - d
	    }
	}
	d & 56 && c.push(sjcl.bitArray.partial(d & 56, f, 1));
	return c
    }
};
sjcl.codec.base64url = {
    fromBits: function (a) {
	return sjcl.codec.base64.fromBits(a, 1, 1)
    },
    toBits: function (a) {
	return sjcl.codec.base64.toBits(a, 1)
    }
};
sjcl.hash.sha256 = function (a) {
    this.a[0] || this.z();
    if (a) {
	this.n = a.n.slice(0);
	this.i = a.i.slice(0);
	this.e = a.e
    } else this.reset()
};
sjcl.hash.sha256.hash = function (a) {
    return (new sjcl.hash.sha256).update(a).finalize()
};
sjcl.hash.sha256.prototype = {
    blockSize: 512,
    reset: function () {
	this.n = this.N.slice(0);
	this.i = [];
	this.e = 0;
	return this
    },
    update: function (a) {
	if (typeof a === "string") a = sjcl.codec.utf8String.toBits(a);
	var b, c = this.i = sjcl.bitArray.concat(this.i, a);
	b = this.e;
	a = this.e = b + sjcl.bitArray.bitLength(a);
	for (b = 512 + b & -512; b <= a; b += 512) this.D(c.splice(0, 16));
	return this
    },
    finalize: function () {
	var a, b = this.i,
	    c = this.n;
	b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1, 1)]);
	for (a = b.length + 2; a & 15; a++) b.push(0);
	b.push(Math.floor(this.e / 4294967296));
	for (b.push(this.e | 0); b.length;) this.D(b.splice(0, 16));
	this.reset();
	return c
    },
    N: [],
    a: [],
    z: function () {
	function a(e) {
	    return (e - Math.floor(e)) * 0x100000000 | 0
	}
	var b = 0,
	    c = 2,
	    d;
	a: for (; b < 64; c++) {
	    for (d = 2; d * d <= c; d++) if (c % d === 0) continue a;
	    if (b < 8) this.N[b] = a(Math.pow(c, 0.5));
	    this.a[b] = a(Math.pow(c, 1 / 3));
	    b++
	}
    },
    D: function (a) {
	var b, c, d = a.slice(0),
	    e = this.n,
	    f = this.a,
	    g = e[0],
	    h = e[1],
	    i = e[2],
	    k = e[3],
	    j = e[4],
	    l = e[5],
	    m = e[6],
	    n = e[7];
	for (a = 0; a < 64; a++) {
	    if (a < 16) b = d[a];
	    else {
		b = d[a + 1 & 15];
		c = d[a + 14 & 15];
		b = d[a & 15] = (b >>> 7 ^ b >>> 18 ^ b >>> 3 ^ b << 25 ^ b << 14) + (c >>> 17 ^ c >>> 19 ^ c >>> 10 ^ c << 15 ^ c << 13) + d[a & 15] + d[a + 9 & 15] | 0
	    }
	    b = b + n + (j >>> 6 ^ j >>> 11 ^ j >>> 25 ^ j << 26 ^ j << 21 ^ j << 7) + (m ^ j & (l ^ m)) + f[a];
	    n = m;
	    m = l;
	    l = j;
	    j = k + b | 0;
	    k = i;
	    i = h;
	    h = g;
	    g = b + (h & i ^ k & (h ^ i)) + (h >>> 2 ^ h >>> 13 ^ h >>> 22 ^ h << 30 ^ h << 19 ^ h << 10) | 0
	}
	e[0] = e[0] + g | 0;
	e[1] = e[1] + h | 0;
	e[2] = e[2] + i | 0;
	e[3] = e[3] + k | 0;
	e[4] = e[4] + j | 0;
	e[5] = e[5] + l | 0;
	e[6] = e[6] + m | 0;
	e[7] = e[7] + n | 0
    }
};
sjcl.mode.ccm = {
    name: "ccm",
    encrypt: function (a, b, c, d, e) {
	var f, g = b.slice(0),
	    h = sjcl.bitArray,
	    i = h.bitLength(c) / 8,
	    k = h.bitLength(g) / 8;
	e = e || 64;
	d = d || [];
	if (i < 7) throw new sjcl.exception.invalid("ccm: iv must be at least 7 bytes");
	for (f = 2; f < 4 && k >>> 8 * f; f++);
	if (f < 15 - i) f = 15 - i;
	c = h.clamp(c, 8 * (15 - f));
	b = sjcl.mode.ccm.H(a, b, c, d, e, f);
	g = sjcl.mode.ccm.J(a, g, c, b, e, f);
	return h.concat(g.data, g.tag)
    },
    decrypt: function (a, b, c, d, e) {
	e = e || 64;
	d = d || [];
	var f = sjcl.bitArray,
	    g = f.bitLength(c) / 8,
	    h = f.bitLength(b),
	    i = f.clamp(b, h - e),
	    k = f.bitSlice(b,
	    h - e);
	h = (h - e) / 8;
	if (g < 7) throw new sjcl.exception.invalid("ccm: iv must be at least 7 bytes");
	for (b = 2; b < 4 && h >>> 8 * b; b++);
	if (b < 15 - g) b = 15 - g;
	c = f.clamp(c, 8 * (15 - b));
	i = sjcl.mode.ccm.J(a, i, c, k, e, b);
	a = sjcl.mode.ccm.H(a, i.data, c, d, e, b);
	if (!f.equal(i.tag, a)){															//modified to add alert in PassLok
	document.getElementById("mainmsg").innerHTML = '<span>Unlocking has Failed</span>';	//
	throw new sjcl.exception.corrupt("ccm: tag doesn't match")							//
	};																					//
	return i.data
    },
    H: function (a, b, c, d, e, f) {
	var g = [],
	    h = sjcl.bitArray,
	    i = h.k;
	e /= 8;
	if (e % 2 || e < 4 || e > 16) throw new sjcl.exception.invalid("ccm: invalid tag length");
	if (d.length > 0xffffffff || b.length > 0xffffffff) throw new sjcl.exception.bug("ccm: can't deal with 4GiB or more data");
	f = [h.partial(8, (d.length ? 64 : 0) | e - 2 << 2 | f - 1)];
	f = h.concat(f, c);
	f[3] |= h.bitLength(b) / 8;
	f = a.encrypt(f);
	if (d.length) {
	    c = h.bitLength(d) / 8;
	    if (c <= 65279) g = [h.partial(16, c)];
	    else if (c <= 0xffffffff) g = h.concat([h.partial(16, 65534)], [c]);
	    g = h.concat(g, d);
	    for (d = 0; d < g.length; d += 4) f = a.encrypt(i(f, g.slice(d, d + 4).concat([0, 0, 0])))
	}
	for (d = 0; d < b.length; d += 4) f = a.encrypt(i(f, b.slice(d, d + 4).concat([0, 0, 0])));
	return h.clamp(f, e * 8)
    },
    J: function (a, b, c, d, e, f) {
	var g, h = sjcl.bitArray;
	g = h.k;
	var i = b.length,
	    k = h.bitLength(b);
	c = h.concat([h.partial(8,
	f - 1)], c).concat([0, 0, 0]).slice(0, 4);
	d = h.bitSlice(g(d, a.encrypt(c)), 0, e);
	if (!i) return {
	    tag: d,
	    data: []
	};
	for (g = 0; g < i; g += 4) {
	    c[3]++;
	    e = a.encrypt(c);
	    b[g] ^= e[0];
	    b[g + 1] ^= e[1];
	    b[g + 2] ^= e[2];
	    b[g + 3] ^= e[3]
	}
	return {
	    tag: d,
	    data: h.clamp(b, k)
	}
    }
};
sjcl.mode.ocb2 = {
    name: "ocb2",
    encrypt: function (a, b, c, d, e, f) {
	if (sjcl.bitArray.bitLength(c) !== 128) throw new sjcl.exception.invalid("ocb iv must be 128 bits");
	var g, h = sjcl.mode.ocb2.B,
	    i = sjcl.bitArray,
	    k = i.k,
	    j = [0, 0, 0, 0];
	c = h(a.encrypt(c));
	var l, m = [];
	d = d || [];
	e = e || 64;
	for (g = 0; g + 4 < b.length; g += 4) {
	    l = b.slice(g, g + 4);
	    j = k(j, l);
	    m = m.concat(k(c, a.encrypt(k(c, l))));
	    c = h(c)
	}
	l = b.slice(g);
	b = i.bitLength(l);
	g = a.encrypt(k(c, [0, 0, 0, b]));
	l = i.clamp(k(l.concat([0, 0, 0]), g), b);
	j = k(j, k(l.concat([0, 0, 0]), g));
	j = a.encrypt(k(j, k(c, h(c))));
	if (d.length) j = k(j, f ? d : sjcl.mode.ocb2.pmac(a, d));
	return m.concat(i.concat(l, i.clamp(j, e)))
    },
    decrypt: function (a, b, c, d, e, f) {
	if (sjcl.bitArray.bitLength(c) !== 128) throw new sjcl.exception.invalid("ocb iv must be 128 bits");
	e = e || 64;
	var g = sjcl.mode.ocb2.B,
	    h = sjcl.bitArray,
	    i = h.k,
	    k = [0, 0, 0, 0],
	    j = g(a.encrypt(c)),
	    l, m, n = sjcl.bitArray.bitLength(b) - e,
	    o = [];
	d = d || [];
	for (c = 0; c + 4 < n / 32; c += 4) {
	    l = i(j, a.decrypt(i(j, b.slice(c, c + 4))));
	    k = i(k, l);
	    o = o.concat(l);
	    j = g(j)
	}
	m = n - c * 32;
	l = a.encrypt(i(j, [0, 0, 0, m]));
	l = i(l, h.clamp(b.slice(c),
	m).concat([0, 0, 0]));
	k = i(k, l);
	k = a.encrypt(i(k, i(j, g(j))));
	if (d.length) k = i(k, f ? d : sjcl.mode.ocb2.pmac(a, d));
	if (!h.equal(h.clamp(k, e), h.bitSlice(b, n))) throw new sjcl.exception.corrupt("ocb: tag doesn't match");
	return o.concat(h.clamp(l, m))
    },
    pmac: function (a, b) {
	var c, d = sjcl.mode.ocb2.B,
	    e = sjcl.bitArray,
	    f = e.k,
	    g = [0, 0, 0, 0],
	    h = a.encrypt([0, 0, 0, 0]);
	h = f(h, d(d(h)));
	for (c = 0; c + 4 < b.length; c += 4) {
	    h = d(h);
	    g = f(g, a.encrypt(f(h, b.slice(c, c + 4))))
	}
	b = b.slice(c);
	if (e.bitLength(b) < 128) {
	    h = f(h, d(h));
	    b = e.concat(b, [2147483648 | 0, 0,
	    0, 0])
	}
	g = f(g, b);
	return a.encrypt(f(d(f(h, d(h))), g))
    },
    B: function (a) {
	return [a[0] << 1 ^ a[1] >>> 31, a[1] << 1 ^ a[2] >>> 31, a[2] << 1 ^ a[3] >>> 31, a[3] << 1 ^ (a[0] >>> 31) * 135]
    }
};
sjcl.misc.hmac = function (a, b) {
    this.M = b = b || sjcl.hash.sha256;
    var c = [
	[],
	[]
    ],
	d = b.prototype.blockSize / 32;
    this.l = [new b, new b];
    if (a.length > d) a = b.hash(a);
    for (b = 0; b < d; b++) {
	c[0][b] = a[b] ^ 909522486;
	c[1][b] = a[b] ^ 1549556828
    }
    this.l[0].update(c[0]);
    this.l[1].update(c[1])
};
sjcl.misc.hmac.prototype.encrypt = sjcl.misc.hmac.prototype.mac = function (a, b) {
    a = (new this.M(this.l[0])).update(a, b).finalize();
    return (new this.M(this.l[1])).update(a).finalize()
};
sjcl.misc.pbkdf2 = function (a, b, c, d, e) {
    c = c || 1E3;
    if (d < 0 || c < 0) throw sjcl.exception.invalid("invalid params to pbkdf2");
    if (typeof a === "string") a = sjcl.codec.utf8String.toBits(a);
    e = e || sjcl.misc.hmac;
    a = new e(a);
    var f, g, h, i, k = [],
	j = sjcl.bitArray;
    for (i = 1; 32 * k.length < (d || 1); i++) {
	e = f = a.encrypt(j.concat(b, [i]));
	for (g = 1; g < c; g++) {
	    f = a.encrypt(f);
	    for (h = 0; h < f.length; h++) e[h] ^= f[h]
	}
	k = k.concat(e)
    }
    if (d) k = j.clamp(k, d);
    return k
};
sjcl.random = {
    randomWords: function (a, b) {
	var c = [];
	b = this.isReady(b);
	var d;
	if (b === 0) throw new sjcl.exception.notReady("generator isn't seeded");
	else b & 2 && this.U(!(b & 1));
	for (b = 0; b < a; b += 4) {
	    (b + 1) % 0x10000 === 0 && this.L();
	    d = this.w();
	    c.push(d[0], d[1], d[2], d[3])
	}
	this.L();
	return c.slice(0, a)
    },
    setDefaultParanoia: function (a) {
	this.t = a
    },
    addEntropy: function (a, b, c) {
	c = c || "user";
	var d, e, f = (new Date).valueOf(),
	    g = this.q[c],
	    h = this.isReady(),
	    i = 0;
	d = this.G[c];
	if (d === undefined) d = this.G[c] = this.R++;
	if (g === undefined) g = this.q[c] = 0;
	this.q[c] = (this.q[c] + 1) % this.b.length;
	switch (typeof a) {
	    case "number":
		if (b === undefined) b = 1;
		this.b[g].update([d, this.u++, 1, b, f, 1, a | 0]);
		break;
	    case "object":
		c = Object.prototype.toString.call(a);
		if (c === "[object Uint32Array]") {
		    e = [];
		    for (c = 0; c < a.length; c++) e.push(a[c]);
		    a = e
		} else {
		    if (c !== "[object Array]") i = 1;
		    for (c = 0; c < a.length && !i; c++) if (typeof a[c] != "number") i = 1
		}
		if (!i) {
		    if (b === undefined) for (c = b = 0; c < a.length; c++) for (e = a[c]; e > 0;) {
			b++;
			e >>>= 1
		    }
		    this.b[g].update([d, this.u++, 2, b, f, a.length].concat(a))
		}
		break;
	    case "string":
		if (b === undefined) b = a.length;
		this.b[g].update([d, this.u++, 3, b, f, a.length]);
		this.b[g].update(a);
		break;
	    default:
		i = 1
	}
	if (i) throw new sjcl.exception.bug("random: addEntropy only supports number, array of numbers or string");
	this.j[g] += b;
	this.f += b;
	if (h === 0) {
	    this.isReady() !== 0 && this.K("seeded", Math.max(this.g, this.f));
	    this.K("progress", this.getProgress())
	}
    },
    isReady: function (a) {
	a = this.C[a !== undefined ? a : this.t];
	return this.g && this.g >= a ? this.j[0] > 80 && (new Date).valueOf() > this.O ? 3 : 1 : this.f >= a ? 2 : 0
    },
    getProgress: function (a) {
	a = this.C[a ? a : this.t];
	return this.g >= a ? 1 : this.f > a ? 1 : this.f / a
    },
    startCollectors: function () {
	if (!this.m) {
	    if (window.addEventListener) {
		window.addEventListener("load", this.o, false);
		window.addEventListener("mousemove", this.p, false)
	    } else if (document.attachEvent) {
		document.attachEvent("onload", this.o);
		document.attachEvent("onmousemove", this.p)
	    } else throw new sjcl.exception.bug("can't attach event");
	    this.m = true
	}
    },
    stopCollectors: function () {
	if (this.m) {
	    if (window.removeEventListener) {
		window.removeEventListener("load",
		this.o, false);
		window.removeEventListener("mousemove", this.p, false)
	    } else if (window.detachEvent) {
		window.detachEvent("onload", this.o);
		window.detachEvent("onmousemove", this.p)
	    }
	    this.m = false
	}
    },
    addEventListener: function (a, b) {
	this.r[a][this.Q++] = b
    },
    removeEventListener: function (a, b) {
	var c;
	a = this.r[a];
	var d = [];
	for (c in a) a.hasOwnProperty(c) && a[c] === b && d.push(c);
	for (b = 0; b < d.length; b++) {
	    c = d[b];
	    delete a[c]
	}
    },
    b: [new sjcl.hash.sha256],
    j: [0],
    A: 0,
    q: {},
    u: 0,
    G: {},
    R: 0,
    g: 0,
    f: 0,
    O: 0,
    a: [0, 0, 0, 0, 0, 0, 0, 0],
    d: [0, 0, 0, 0],
    s: undefined,
    t: 6,
    m: false,
    r: {
	progress: {},
	seeded: {}
    },
    Q: 0,
    C: [0, 48, 64, 96, 128, 192, 0x100, 384, 512, 768, 1024],
    w: function () {
	for (var a = 0; a < 4; a++) {
	    this.d[a] = this.d[a] + 1 | 0;
	    if (this.d[a]) break
	}
	return this.s.encrypt(this.d)
    },
    L: function () {
	this.a = this.w().concat(this.w());
	this.s = new sjcl.cipher.aes(this.a)
    },
    T: function (a) {
	this.a = sjcl.hash.sha256.hash(this.a.concat(a));
	this.s = new sjcl.cipher.aes(this.a);
	for (a = 0; a < 4; a++) {
	    this.d[a] = this.d[a] + 1 | 0;
	    if (this.d[a]) break
	}
    },
    U: function (a) {
	var b = [],
	    c = 0,
	    d;
	this.O = b[0] = (new Date).valueOf() + 3E4;
	for (d = 0; d < 16; d++) b.push(Math.random() * 0x100000000 | 0);
	for (d = 0; d < this.b.length; d++) {
	    b = b.concat(this.b[d].finalize());
	    c += this.j[d];
	    this.j[d] = 0;
	    if (!a && this.A & 1 << d) break
	}
	if (this.A >= 1 << this.b.length) {
	    this.b.push(new sjcl.hash.sha256);
	    this.j.push(0)
	}
	this.f -= c;
	if (c > this.g) this.g = c;
	this.A++;
	this.T(b)
    },
    p: function (a) {
	sjcl.random.addEntropy([a.x || a.clientX || a.offsetX || 0, a.y || a.clientY || a.offsetY || 0], 2, "mouse")
    },
    o: function () {
	sjcl.random.addEntropy((new Date).valueOf(), 2, "loadtime")
    },
    K: function (a, b) {
	var c;
	a = sjcl.random.r[a];
	var d = [];
	for (c in a) a.hasOwnProperty(c) && d.push(a[c]);
	for (c = 0; c < d.length; c++) d[c](b)
    }
};
try {
    var s = new Uint32Array(32);
    crypto.getRandomValues(s);
    sjcl.random.addEntropy(s, 1024, "crypto['getRandomValues']")
} catch (t) {}
sjcl.json = {
    defaults: {
	v: 1,
	iter: 1E3,
	ks: 128,
	ts: 64,
	mode: "ccm",
	adata: "",
	cipher: "aes"
    },
    encrypt: function (a, b, c, d) {
	c = c || {};
	d = d || {};
	var e = sjcl.json,
	    f = e.c({
		iv: sjcl.random.randomWords(4, 0)
	    }, e.defaults),
	    g;
	e.c(f, c);
	c = f.adata;
	if (typeof f.salt === "string") f.salt = sjcl.codec.base64.toBits(f.salt);
	if (typeof f.iv === "string") f.iv = sjcl.codec.base64.toBits(f.iv);
	if (!sjcl.mode[f.mode] || !sjcl.cipher[f.cipher] || typeof a === "string" && f.iter <= 100 || f.ts !== 64 && f.ts !== 96 && f.ts !== 128 || f.ks !== 128 && f.ks !== 192 && f.ks !== 0x100 || f.iv.length < 2 || f.iv.length > 4) throw new sjcl.exception.invalid("json encrypt: invalid parameters");
	if (typeof a === "string") {
	    g = sjcl.misc.cachedPbkdf2(a, f);
	    a = g.key.slice(0, f.ks / 32);
	    f.salt = g.salt
	}
	if (typeof b === "string") b = sjcl.codec.utf8String.toBits(b);
	if (typeof c === "string") c = sjcl.codec.utf8String.toBits(c);
	g = new sjcl.cipher[f.cipher](a);
	e.c(d, f);
	d.key = a;
	f.ct = sjcl.mode[f.mode].encrypt(g, b, f.iv, c, f.ts);
	return e.encode(f)
    },
    decrypt: function (a, b, c, d) {
	c = c || {};
	d = d || {};
	var e = sjcl.json;
	b = e.c(e.c(e.c({}, e.defaults), e.decode(b)),
	c, true);
	var f;
	c = b.adata;
	if (typeof b.salt === "string") b.salt = sjcl.codec.base64.toBits(b.salt);
	if (typeof b.iv === "string") b.iv = sjcl.codec.base64.toBits(b.iv);
	if (!sjcl.mode[b.mode] || !sjcl.cipher[b.cipher] || typeof a === "string" && b.iter <= 100 || b.ts !== 64 && b.ts !== 96 && b.ts !== 128 || b.ks !== 128 && b.ks !== 192 && b.ks !== 0x100 || !b.iv || b.iv.length < 2 || b.iv.length > 4) throw new sjcl.exception.invalid("json decrypt: invalid parameters");
	if (typeof a === "string") {
	    f = sjcl.misc.cachedPbkdf2(a, b);
	    a = f.key.slice(0, b.ks / 32);
	    b.salt = f.salt
	}
	if (typeof c === "string") c = sjcl.codec.utf8String.toBits(c);
	f = new sjcl.cipher[b.cipher](a);
	c = sjcl.mode[b.mode].decrypt(f, b.ct, b.iv, c, b.ts);
	e.c(d, b);
	d.key = a;
	return sjcl.codec.utf8String.fromBits(c)
    },
    encode: function (a) {
	var b, c = "{",
	    d = "";
	for (b in a) if (a.hasOwnProperty(b)) {
	    if (!b.match(/^[a-z0-9]+$/i)) throw new sjcl.exception.invalid("json encode: invalid property name");
	    c += d + '"' + b + '":';
	    d = ",";
	    switch (typeof a[b]) {
		case "number":
		case "boolean":
		    c += a[b];
		    break;
		case "string":
		    c += '"' + escape(a[b]) + '"';
		    break;
		case "object":
		    c += '"' + sjcl.codec.base64.fromBits(a[b], 1) + '"';
		    break;
		default:
		    throw new sjcl.exception.bug("json encode: unsupported type");
	    }
	}
	return c + "}"
    },
    decode: function (a) {
	a = a.replace(/\s/g, "");
	if (!a.match(/^\{.*\}$/)) throw new sjcl.exception.invalid("json decode: this isn't json!");
	a = a.replace(/^\{|\}$/g, "").split(/,/);
	var b = {}, c, d;
	for (c = 0; c < a.length; c++) {
	    if (!(d = a[c].match(/^(?:(["']?)([a-z][a-z0-9]*)\1):(?:(\d+)|"([a-z0-9+\/%*_.@=\-]*)")$/i))) throw new sjcl.exception.invalid("json decode: this isn't json!");
	    b[d[2]] = d[3] ? parseInt(d[3], 10) : d[2].match(/^(ct|salt|iv)$/) ? sjcl.codec.base64.toBits(d[4]) : unescape(d[4])
	}
	return b
    },
    c: function (a, b, c) {
	if (a === undefined) a = {};
	if (b === undefined) return a;
	var d;
	for (d in b) if (b.hasOwnProperty(d)) {
	    if (c && a[d] !== undefined && a[d] !== b[d]) throw new sjcl.exception.invalid("required parameter overridden");
	    a[d] = b[d]
	}
	return a
    },
    W: function (a, b) {
	var c = {}, d;
	for (d in a) if (a.hasOwnProperty(d) && a[d] !== b[d]) c[d] = a[d];
	return c
    },
    V: function (a, b) {
	var c = {}, d;
	for (d = 0; d < b.length; d++) if (a[b[d]] !== undefined) c[b[d]] = a[b[d]];
	return c
    }
};
sjcl.encrypt = sjcl.json.encrypt;
sjcl.decrypt = sjcl.json.decrypt;
sjcl.misc.S = {};
sjcl.misc.cachedPbkdf2 = function (a, b) {
    var c = sjcl.misc.S,
	d;
    b = b || {};
    d = b.iter || 1E3;
    c = c[a] = c[a] || {};
    d = c[d] = c[d] || {
	firstSalt: b.salt && b.salt.length ? b.salt.slice(0) : sjcl.random.randomWords(2, 0)
    };
    c = b.salt === undefined ? d.firstSalt : b.salt;
    d[c] = d[c] || sjcl.misc.pbkdf2(a, c, b.iter);
    return {
	key: d[c].slice(0),
	salt: c.slice(0)
    }
};

//SHA512.js begins (also from SJCL)
/** @fileOverview Javascript SHA-512 implementation.
 *
 * This implementation was written for CryptoJS by Jeff Mott and adapted for
 * SJCL by Stefan Thomas.
 *
 * CryptoJS (c) 2009-2012 by Jeff Mott. All rights reserved.
 * Released with New BSD License
 */

/**
 * Context for a SHA-512 operation in progress.
 * @constructor
 * @class Secure Hash Algorithm, 512 bits.
 */
sjcl.hash.sha512 = function (hash) {
  if (!this._key[0]) { this._precompute(); }
  if (hash) {
    this._h = hash._h.slice(0);
    this._buffer = hash._buffer.slice(0);
    this._length = hash._length;
  } else {
    this.reset();
  }
};

/**
 * Hash a string or an array of words.
 * @static
 * @param {bitArray|String} data the data to hash.
 * @return {bitArray} The hash value, an array of 16 big-endian words.
 */
sjcl.hash.sha512.hash = function (data) {
  return (new sjcl.hash.sha512()).update(data).finalize();
};

sjcl.hash.sha512.prototype = {
  /**
   * The hash's block size, in bits.
   * @constant
   */
  blockSize: 1024,
   
  /**
   * Reset the hash state.
   * @return this
   */
  reset:function () {
    this._h = this._init.slice(0);
    this._buffer = [];
    this._length = 0;
    return this;
  },
  
  /**
   * Input several words to the hash.
   * @param {bitArray|String} data the data to hash.
   * @return this
   */
  update: function (data) {
    if (typeof data === "string") {
      data = sjcl.codec.utf8String.toBits(data);
    }
    var i, b = this._buffer = sjcl.bitArray.concat(this._buffer, data),
        ol = this._length,
        nl = this._length = ol + sjcl.bitArray.bitLength(data);
    for (i = 1024+ol & -1024; i <= nl; i+= 1024) {
      this._block(b.splice(0,32));
    }
    return this;
  },
  
  /**
   * Complete hashing and output the hash value.
   * @return {bitArray} The hash value, an array of 16 big-endian words.
   */
  finalize:function () {
    var i, b = this._buffer, h = this._h;

    // Round out and push the buffer
    b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1,1)]);

    // Round out the buffer to a multiple of 32 words, less the 4 length words.
    for (i = b.length + 4; i & 31; i++) {
      b.push(0);
    }

    // append the length
    b.push(0);
    b.push(0);
    b.push(Math.floor(this._length / 0x100000000));
    b.push(this._length | 0);

    while (b.length) {
      this._block(b.splice(0,32));
    }

    this.reset();
    return h;
  },

  /**
   * The SHA-512 initialization vector, to be precomputed.
   * @private
   */
  _init:[],

  /**
   * Least significant 24 bits of SHA512 initialization values.
   *
   * Javascript only has 53 bits of precision, so we compute the 40 most
   * significant bits and add the remaining 24 bits as constants.
   *
   * @private
   */
  _initr: [ 0xbcc908, 0xcaa73b, 0x94f82b, 0x1d36f1, 0xe682d1, 0x3e6c1f, 0x41bd6b, 0x7e2179 ],

   /**
   * The SHA-512 hash key, to be precomputed.
   * @private
   */
  _key:[],

  /**
   * Least significant 24 bits of SHA512 key values.
   * @private
   */
  _keyr:
  [0x28ae22, 0xef65cd, 0x4d3b2f, 0x89dbbc, 0x48b538, 0x05d019, 0x194f9b, 0x6d8118,
   0x030242, 0x706fbe, 0xe4b28c, 0xffb4e2, 0x7b896f, 0x1696b1, 0xc71235, 0x692694,
   0xf14ad2, 0x4f25e3, 0x8cd5b5, 0xac9c65, 0x2b0275, 0xa6e483, 0x41fbd4, 0x1153b5,
   0x66dfab, 0xb43210, 0xfb213f, 0xef0ee4, 0xa88fc2, 0x0aa725, 0x03826f, 0x0e6e70,
   0xd22ffc, 0x26c926, 0xc42aed, 0x95b3df, 0xaf63de, 0x77b2a8, 0xedaee6, 0x82353b,
   0xf10364, 0x423001, 0xf89791, 0x54be30, 0xef5218, 0x65a910, 0x71202a, 0xbbd1b8,
   0xd2d0c8, 0x41ab53, 0x8eeb99, 0x9b48a8, 0xc95a63, 0x418acb, 0x63e373, 0xb2b8a3,
   0xefb2fc, 0x172f60, 0xf0ab72, 0x6439ec, 0x631e28, 0x82bde9, 0xc67915, 0x72532b,
   0x26619c, 0xc0c207, 0xe0eb1e, 0x6ed178, 0x176fba, 0xc898a6, 0xf90dae, 0x1c471b,
   0x047d84, 0xc72493, 0xc9bebc, 0x100d4c, 0x3e42b6, 0x657e2a, 0xd6faec, 0x475817],

  /**
   * Function to precompute _init and _key.
   * @private
   */
  _precompute: function () {
    // XXX: This code is for precomputing the SHA256 constants, change for
    //      SHA512 and re-enable.
    var i = 0, prime = 2, factor;

    function frac(x)  { return (x-Math.floor(x)) * 0x100000000 | 0; }
    function frac2(x) { return (x-Math.floor(x)) * 0x10000000000 & 0xff; }

    outer: for (; i<80; prime++) {
      for (factor=2; factor*factor <= prime; factor++) {
        if (prime % factor === 0) {
          // not a prime
          continue outer;
        }
      }

      if (i<8) {
        this._init[i*2] = frac(Math.pow(prime, 1/2));
        this._init[i*2+1] = (frac2(Math.pow(prime, 1/2)) << 24) | this._initr[i];
      }
      this._key[i*2] = frac(Math.pow(prime, 1/3));
      this._key[i*2+1] = (frac2(Math.pow(prime, 1/3)) << 24) | this._keyr[i];
      i++;
    }
  },

  /**
   * Perform one cycle of SHA-512.
   * @param {bitArray} words one block of words.
   * @private
   */
  _block:function (words) {
    var i, wrh, wrl,
        w = words.slice(0),
        h = this._h,
        k = this._key,
        h0h = h[ 0], h0l = h[ 1], h1h = h[ 2], h1l = h[ 3],
        h2h = h[ 4], h2l = h[ 5], h3h = h[ 6], h3l = h[ 7],
        h4h = h[ 8], h4l = h[ 9], h5h = h[10], h5l = h[11],
        h6h = h[12], h6l = h[13], h7h = h[14], h7l = h[15];

    // Working variables
    var ah = h0h, al = h0l, bh = h1h, bl = h1l,
        ch = h2h, cl = h2l, dh = h3h, dl = h3l,
        eh = h4h, el = h4l, fh = h5h, fl = h5l,
        gh = h6h, gl = h6l, hh = h7h, hl = h7l;

    for (i=0; i<80; i++) {
      // load up the input word for this round
      if (i<16) {
        wrh = w[i * 2];
        wrl = w[i * 2 + 1];
      } else {
        // Gamma0
        var gamma0xh = w[(i-15) * 2];
        var gamma0xl = w[(i-15) * 2 + 1];
        var gamma0h =
          ((gamma0xl << 31) | (gamma0xh >>> 1)) ^
          ((gamma0xl << 24) | (gamma0xh >>> 8)) ^
           (gamma0xh >>> 7);
        var gamma0l =
          ((gamma0xh << 31) | (gamma0xl >>> 1)) ^
          ((gamma0xh << 24) | (gamma0xl >>> 8)) ^
          ((gamma0xh << 25) | (gamma0xl >>> 7));

        // Gamma1
        var gamma1xh = w[(i-2) * 2];
        var gamma1xl = w[(i-2) * 2 + 1];
        var gamma1h =
          ((gamma1xl << 13) | (gamma1xh >>> 19)) ^
          ((gamma1xh << 3)  | (gamma1xl >>> 29)) ^
           (gamma1xh >>> 6);
        var gamma1l =
          ((gamma1xh << 13) | (gamma1xl >>> 19)) ^
          ((gamma1xl << 3)  | (gamma1xh >>> 29)) ^
          ((gamma1xh << 26) | (gamma1xl >>> 6));

        // Shortcuts
        var wr7h = w[(i-7) * 2];
        var wr7l = w[(i-7) * 2 + 1];

        var wr16h = w[(i-16) * 2];
        var wr16l = w[(i-16) * 2 + 1];

        // W(round) = gamma0 + W(round - 7) + gamma1 + W(round - 16)
        wrl = gamma0l + wr7l;
        wrh = gamma0h + wr7h + ((wrl >>> 0) < (gamma0l >>> 0) ? 1 : 0);
        wrl += gamma1l;
        wrh += gamma1h + ((wrl >>> 0) < (gamma1l >>> 0) ? 1 : 0);
        wrl += wr16l;
        wrh += wr16h + ((wrl >>> 0) < (wr16l >>> 0) ? 1 : 0);
      }

      w[i*2]     = wrh |= 0;
      w[i*2 + 1] = wrl |= 0;

      // Ch
      var chh = (eh & fh) ^ (~eh & gh);
      var chl = (el & fl) ^ (~el & gl);

      // Maj
      var majh = (ah & bh) ^ (ah & ch) ^ (bh & ch);
      var majl = (al & bl) ^ (al & cl) ^ (bl & cl);

      // Sigma0
      var sigma0h = ((al << 4) | (ah >>> 28)) ^ ((ah << 30) | (al >>> 2)) ^ ((ah << 25) | (al >>> 7));
      var sigma0l = ((ah << 4) | (al >>> 28)) ^ ((al << 30) | (ah >>> 2)) ^ ((al << 25) | (ah >>> 7));

      // Sigma1
      var sigma1h = ((el << 18) | (eh >>> 14)) ^ ((el << 14) | (eh >>> 18)) ^ ((eh << 23) | (el >>> 9));
      var sigma1l = ((eh << 18) | (el >>> 14)) ^ ((eh << 14) | (el >>> 18)) ^ ((el << 23) | (eh >>> 9));

      // K(round)
      var krh = k[i*2];
      var krl = k[i*2+1];

      // t1 = h + sigma1 + ch + K(round) + W(round)
      var t1l = hl + sigma1l;
      var t1h = hh + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0);
      t1l += chl;
      t1h += chh + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0);
      t1l += krl;
      t1h += krh + ((t1l >>> 0) < (krl >>> 0) ? 1 : 0);
      t1l += wrl;
      t1h += wrh + ((t1l >>> 0) < (wrl >>> 0) ? 1 : 0);

      // t2 = sigma0 + maj
      var t2l = sigma0l + majl;
      var t2h = sigma0h + majh + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0);

      // Update working variables
      hh = gh;
      hl = gl;
      gh = fh;
      gl = fl;
      fh = eh;
      fl = el;
      el = (dl + t1l) | 0;
      eh = (dh + t1h + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;
      dh = ch;
      dl = cl;
      ch = bh;
      cl = bl;
      bh = ah;
      bl = al;
      al = (t1l + t2l) | 0;
      ah = (t1h + t2h + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0;
    }

    // Intermediate hash
    h0l = h[1] = (h0l + al) | 0;
    h[0] = (h0h + ah + ((h0l >>> 0) < (al >>> 0) ? 1 : 0)) | 0;
    h1l = h[3] = (h1l + bl) | 0;
    h[2] = (h1h + bh + ((h1l >>> 0) < (bl >>> 0) ? 1 : 0)) | 0;
    h2l = h[5] = (h2l + cl) | 0;
    h[4] = (h2h + ch + ((h2l >>> 0) < (cl >>> 0) ? 1 : 0)) | 0;
    h3l = h[7] = (h3l + dl) | 0;
    h[6] = (h3h + dh + ((h3l >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;
    h4l = h[9] = (h4l + el) | 0;
    h[8] = (h4h + eh + ((h4l >>> 0) < (el >>> 0) ? 1 : 0)) | 0;
    h5l = h[11] = (h5l + fl) | 0;
    h[10] = (h5h + fh + ((h5l >>> 0) < (fl >>> 0) ? 1 : 0)) | 0;
    h6l = h[13] = (h6l + gl) | 0;
    h[12] = (h6h + gh + ((h6l >>> 0) < (gl >>> 0) ? 1 : 0)) | 0;
    h7l = h[15] = (h7l + hl) | 0;
    h[14] = (h7h + hh + ((h7l >>> 0) < (hl >>> 0) ? 1 : 0)) | 0;
  }
};
//SHA512.js ends

//BN.js begins (also from SJCL)
/**
 * Constructs a new bignum from another bignum, a number or a hex string.
 */
sjcl.bn = function(it) {
  this.initWith(it);
};

sjcl.bn.prototype = {
  radix: 24,
  maxMul: 8,
  _class: sjcl.bn,
  
  copy: function() {
    return new this._class(this);
  },

  /**
   * Initializes this with it, either as a bn, a number, or a hex string.
   */
  initWith: function(it) {
    var i=0, k, n, l;
    switch(typeof it) {
    case "object":
      this.limbs = it.limbs.slice(0);
      break;
      
    case "number":
      this.limbs = [it];
      this.normalize();
      break;
      
    case "string":
      it = it.replace(/^0x/, '');
      this.limbs = [];
      // hack
      k = this.radix / 4;
      for (i=0; i < it.length; i+=k) {
	this.limbs.push(parseInt(it.substring(Math.max(it.length - i - k, 0), it.length - i),16));
      }
      break;

    default:
      this.limbs = [0];
    }
    return this;
  },

  /**
   * Returns true if "this" and "that" are equal.  Calls fullReduce().
   * Equality test is in constant time.
   */
  equals: function(that) {
    if (typeof that === "number") { that = new this._class(that); }
    var difference = 0, i;
    this.fullReduce();
    that.fullReduce();
    for (i = 0; i < this.limbs.length || i < that.limbs.length; i++) {
      difference |= this.getLimb(i) ^ that.getLimb(i);
    }
    return (difference === 0);
  },
  
  /**
   * Get the i'th limb of this, zero if i is too large.
   */
  getLimb: function(i) {
    return (i >= this.limbs.length) ? 0 : this.limbs[i];
  },
  
  /**
   * Constant time comparison function.
   * Returns 1 if this >= that, or zero otherwise.
   */
  greaterEquals: function(that) {
    if (typeof that === "number") { that = new this._class(that); }
    var less = 0, greater = 0, i, a, b;
    i = Math.max(this.limbs.length, that.limbs.length) - 1;
    for (; i>= 0; i--) {
      a = this.getLimb(i);
      b = that.getLimb(i);
      greater |= (b - a) & ~less;
      less |= (a - b) & ~greater;
    }
    return (greater | ~less) >>> 31;
  },
  
  /**
   * Convert to a hex string.
   */
  toString: function() {
    this.fullReduce();
    var out="", i, s, l = this.limbs;
    for (i=0; i < this.limbs.length; i++) {
      s = l[i].toString(16);
      while (i < this.limbs.length - 1 && s.length < 6) {
	s = "0" + s;
      }
      out = s + out;
    }
    return "0x"+out;
  },
  
  /** this += that.  Does not normalize. */
  addM: function(that) {
    if (typeof(that) !== "object") { that = new this._class(that); }
    var i, l=this.limbs, ll=that.limbs;
    for (i=l.length; i<ll.length; i++) {
      l[i] = 0;
    }
    for (i=0; i<ll.length; i++) {
      l[i] += ll[i];
    }
    return this;
  },
  
  /** this *= 2.  Requires normalized; ends up normalized. */
  doubleM: function() {
    var i, carry=0, tmp, r=this.radix, m=this.radixMask, l=this.limbs;
    for (i=0; i<l.length; i++) {
      tmp = l[i];
      tmp = tmp+tmp+carry;
      l[i] = tmp & m;
      carry = tmp >> r;
    }
    if (carry) {
      l.push(carry);
    }
    return this;
  },
  
  /** this /= 2, rounded down.	Requires normalized; ends up normalized. */
  halveM: function() {
    var i, carry=0, tmp, r=this.radix, l=this.limbs;
    for (i=l.length-1; i>=0; i--) {
      tmp = l[i];
      l[i] = (tmp+carry)>>1;
      carry = (tmp&1) << r;
    }
    if (!l[l.length-1]) {
      l.pop();
    }
    return this;
  },

  /** this -= that.  Does not normalize. */
  subM: function(that) {
    if (typeof(that) !== "object") { that = new this._class(that); }
    var i, l=this.limbs, ll=that.limbs;
    for (i=l.length; i<ll.length; i++) {
      l[i] = 0;
    }
    for (i=0; i<ll.length; i++) {
      l[i] -= ll[i];
    }
    return this;
  },
  
  mod: function(that) {
    that = new sjcl.bn(that).normalize(); // copy before we begin
    var out = new sjcl.bn(this).normalize(), ci=0;
    
    for (; out.greaterEquals(that); ci++) {

      that.doubleM();
    }
    for (; ci > 0; ci--) {
      that.halveM();
      if (out.greaterEquals(that)) {
	out.subM(that).normalize();
      }
    }
    return out.trim();
  },
  
  /** return inverse mod prime p.  p must be odd. Binary extended Euclidean algorithm mod p. */
  inverseMod: function(p) {
    var a = new sjcl.bn(1), b = new sjcl.bn(0), x = new sjcl.bn(this), y = new sjcl.bn(p), tmp, i, nz=1;
    
    if (!(p.limbs[0] & 1)) {
      throw (new sjcl.exception.invalid("inverseMod: p must be odd"));
    }
    
    // invariant: y is odd
    do {
      if (x.limbs[0] & 1) {
	if (!x.greaterEquals(y)) {
	  // x < y; swap everything
	  tmp = x; x = y; y = tmp;
	  tmp = a; a = b; b = tmp;
	}
	x.subM(y);
	x.normalize();
	
	if (!a.greaterEquals(b)) {
	  a.addM(p);
	}
	a.subM(b);
      }
      
      // cut everything in half
      x.halveM();
      if (a.limbs[0] & 1) {
	a.addM(p);
      }
      a.normalize();
      a.halveM();
      
      // check for termination: x ?= 0
      for (i=nz=0; i<x.limbs.length; i++) {
	nz |= x.limbs[i];
      }
    } while(nz);
    
    if (!y.equals(1)) {
      throw (new sjcl.exception.invalid("inverseMod: p and x must be relatively prime"));
    }
    
    return b;
  },
  
  /** this + that.  Does not normalize. */
  add: function(that) {
    return this.copy().addM(that);
  },

  /** this - that.  Does not normalize. */
  sub: function(that) {
    return this.copy().subM(that);
  },
  
  /** this * that.  Normalizes and reduces. */
  mul: function(that) {
    if (typeof(that) === "number") { that = new this._class(that); }
    var i, j, a = this.limbs, b = that.limbs, al = a.length, bl = b.length, out = new this._class(), c = out.limbs, ai, ii=this.maxMul;

    for (i=0; i < this.limbs.length + that.limbs.length + 1; i++) {
      c[i] = 0;
    }
    for (i=0; i<al; i++) {
      ai = a[i];
      for (j=0; j<bl; j++) {
	c[i+j] += ai * b[j];
      }
     
      if (!--ii) {
	ii = this.maxMul;
	out.cnormalize();
      }
    }
    return out.cnormalize().reduce();
  },

  /** this ^ 2.  Normalizes and reduces. */
  square: function() {
    return this.mul(this);
  },

  /** this ^ n.  Uses square-and-multiply.  Normalizes and reduces. */
  power: function(l) {
    if (typeof(l) === "number") {
      l = [l];
    } else if (l.limbs !== undefined) {
      l = l.normalize().limbs;
    }
    var i, j, out = new this._class(1), pow = this;

    for (i=0; i<l.length; i++) {
      for (j=0; j<this.radix; j++) {
	if (l[i] & (1<<j)) {
	  out = out.mul(pow);
	}
	pow = pow.square();
      }
    }
    
    return out;
  },

  /** this * that mod N */
  mulmod: function(that, N) {
    return this.mod(N).mul(that.mod(N)).mod(N);
  },

  /** this ^ x mod N */
  powermod: function(x, N) {
    var result = new sjcl.bn(1), a = new sjcl.bn(this), k = new sjcl.bn(x);
    while (true) {
      if (k.limbs[0] & 1) { result = result.mulmod(a, N); }
      k.halveM();
      if (k.equals(0)) { break; }
      a = a.mulmod(a, N);
    }
    return result.normalize().reduce();
  },

  trim: function() {
    var l = this.limbs, p;
    do {
      p = l.pop();
    } while (l.length && p === 0);
    l.push(p);
    return this;
  },
  
  /** Reduce mod a modulus.  Stubbed for subclassing. */
  reduce: function() {
    return this;
  },

  /** Reduce and normalize. */
  fullReduce: function() {
    return this.normalize();
  },
  
  /** Propagate carries. */
  normalize: function() {
    var carry=0, i, pv = this.placeVal, ipv = this.ipv, l, m, limbs = this.limbs, ll = limbs.length, mask = this.radixMask;
    for (i=0; i < ll || (carry !== 0 && carry !== -1); i++) {
      l = (limbs[i]||0) + carry;
      m = limbs[i] = l & mask;
      carry = (l-m)*ipv;
    }
    if (carry === -1) {
      limbs[i-1] -= this.placeVal;
    }
    return this;
  },

  /** Constant-time normalize. Does not allocate additional space. */
  cnormalize: function() {
    var carry=0, i, ipv = this.ipv, l, m, limbs = this.limbs, ll = limbs.length, mask = this.radixMask;
    for (i=0; i < ll-1; i++) {
      l = limbs[i] + carry;
      m = limbs[i] = l & mask;
      carry = (l-m)*ipv;
    }
    limbs[i] += carry;
    return this;
  },
  
  /** Serialize to a bit array */
  toBits: function(len) {
    this.fullReduce();
    len = len || this.exponent || this.limbs.length * this.radix;
    var i = Math.floor((len-1)/24), w=sjcl.bitArray, e = (len + 7 & -8) % this.radix || this.radix,
	out = [w.partial(e, this.getLimb(i))];
    for (i--; i >= 0; i--) {
      out = w.concat(out, [w.partial(this.radix, this.getLimb(i))]);
    }
    return out;
  },
  
  /** Return the length in bits, rounded up to the nearest byte. */
  bitLength: function() {
    this.fullReduce();
    var out = this.radix * (this.limbs.length - 1),
	b = this.limbs[this.limbs.length - 1];
    for (; b; b >>= 1) {
      out ++;
    }
    return out+7 & -8;
  }
};

sjcl.bn.fromBits = function(bits) {
  var Class = this, out = new Class(), words=[], w=sjcl.bitArray, t = this.prototype,
      l = Math.min(this.bitLength || 0x100000000, w.bitLength(bits)), e = l % t.radix || t.radix;
  
  words[0] = w.extract(bits, 0, e);
  for (; e < l; e += t.radix) {
    words.unshift(w.extract(bits, e, t.radix));
  }

  out.limbs = words;
  return out;
};

sjcl.bn.prototype.ipv = 1 / (sjcl.bn.prototype.placeVal = Math.pow(2,sjcl.bn.prototype.radix));
sjcl.bn.prototype.radixMask = (1 << sjcl.bn.prototype.radix) - 1;

/**
 * Creates a new subclass of bn, based on reduction modulo a pseudo-Mersenne prime,
 * i.e. a prime of the form 2^e + sum(a * 2^b),where the sum is negative and sparse.
 */
sjcl.bn.pseudoMersennePrime = function(exponent, coeff) {
  function p(it) {
    this.initWith(it);
    /*if (this.limbs[this.modOffset]) {
      this.reduce();
    }*/
  }

  var ppr = p.prototype = new sjcl.bn(), i, tmp, mo;
  mo = ppr.modOffset = Math.ceil(tmp = exponent / ppr.radix);
  ppr.exponent = exponent;
  ppr.offset = [];
  ppr.factor = [];
  ppr.minOffset = mo;
  ppr.fullMask = 0;
  ppr.fullOffset = [];
  ppr.fullFactor = [];
  ppr.modulus = p.modulus = new sjcl.bn(Math.pow(2,exponent));
  
  ppr.fullMask = 0|-Math.pow(2, exponent % ppr.radix);

  for (i=0; i<coeff.length; i++) {
    ppr.offset[i] = Math.floor(coeff[i][0] / ppr.radix - tmp);
    ppr.fullOffset[i] = Math.ceil(coeff[i][0] / ppr.radix - tmp);
    ppr.factor[i] = coeff[i][1] * Math.pow(1/2, exponent - coeff[i][0] + ppr.offset[i] * ppr.radix);
    ppr.fullFactor[i] = coeff[i][1] * Math.pow(1/2, exponent - coeff[i][0] + ppr.fullOffset[i] * ppr.radix);
    ppr.modulus.addM(new sjcl.bn(Math.pow(2,coeff[i][0])*coeff[i][1]));
    ppr.minOffset = Math.min(ppr.minOffset, -ppr.offset[i]); // conservative
  }
  ppr._class = p;
  ppr.modulus.cnormalize();

  /** Approximate reduction mod p.  May leave a number which is negative or slightly larger than p. */
  ppr.reduce = function() {
    var i, k, l, mo = this.modOffset, limbs = this.limbs, aff, off = this.offset, ol = this.offset.length, fac = this.factor, ll;

    i = this.minOffset;
    while (limbs.length > mo) {
      l = limbs.pop();
      ll = limbs.length;
      for (k=0; k<ol; k++) {
	limbs[ll+off[k]] -= fac[k] * l;
      }
      
      i--;
      if (!i) {
	limbs.push(0);
	this.cnormalize();
	i = this.minOffset;
      }
    }
    this.cnormalize();

    return this;
  };
  
  ppr._strongReduce = (ppr.fullMask === -1) ? ppr.reduce : function() {
    var limbs = this.limbs, i = limbs.length - 1, k, l;
    this.reduce();
    if (i === this.modOffset - 1) {
      l = limbs[i] & this.fullMask;
      limbs[i] -= l;
      for (k=0; k<this.fullOffset.length; k++) {
	limbs[i+this.fullOffset[k]] -= this.fullFactor[k] * l;
      }
      this.normalize();
    }
  };

  /** mostly constant-time, very expensive full reduction. */
  ppr.fullReduce = function() {
    var greater, i;
    // massively above the modulus, may be negative
    
    this._strongReduce();
    // less than twice the modulus, may be negative

    this.addM(this.modulus);
    this.addM(this.modulus);
    this.normalize();
    // probably 2-3x the modulus
    
    this._strongReduce();
    // less than the power of 2.  still may be more than
    // the modulus

    // HACK: pad out to this length
    for (i=this.limbs.length; i<this.modOffset; i++) {
      this.limbs[i] = 0;
    }
    
    // constant-time subtract modulus
    greater = this.greaterEquals(this.modulus);
    for (i=0; i<this.limbs.length; i++) {
      this.limbs[i] -= this.modulus.limbs[i] * greater;
    }
    this.cnormalize();

    return this;
  };

  ppr.inverse = function() {
    return (this.power(this.modulus.sub(2)));
  };

  p.fromBits = sjcl.bn.fromBits;

  return p;
};

// a small Mersenne prime
sjcl.bn.prime = {
  // NIST primes
  p192: sjcl.bn.pseudoMersennePrime(192, [[0,-1],[64,-1]]),
  p224: sjcl.bn.pseudoMersennePrime(224, [[0,1],[96,-1]]),
  p256: sjcl.bn.pseudoMersennePrime(256, [[0,-1],[96,1],[192,1],[224,-1]]),
  p384: sjcl.bn.pseudoMersennePrime(384, [[0,-1],[32,1],[96,-1],[128,-1]]),
  p521: sjcl.bn.pseudoMersennePrime(521, [[0,-1]])
};

sjcl.bn.random = function(modulus, paranoia) {
  if (typeof modulus !== "object") { modulus = new sjcl.bn(modulus); }
  var words, i, l = modulus.limbs.length, m = modulus.limbs[l-1]+1, out = new sjcl.bn();
  while (true) {
    // get a sequence whose first digits make sense
    do {
      words = sjcl.random.randomWords(l, paranoia);
      if (words[l-1] < 0) { words[l-1] += 0x100000000; }
    } while (Math.floor(words[l-1] / m) === Math.floor(0x100000000 / m));
    words[l-1] %= m;

    // mask off all the limbs
    for (i=0; i<l-1; i++) {
      words[i] &= modulus.radixMask;
    }

    // check the rest of the digitssj
    out.limbs = words;
    if (!out.greaterEquals(modulus)) {
      return out;
    }
  }
};

//ECC.js begins
//F. Ruiz: I added the 521-bit curve, took out elGamal etc. at the end, replaced by my own functions. Modifications are noted)

sjcl.ecc = {};

/**
 * Represents a point on a curve in affine coordinates.
 * @constructor
 * @param {sjcl.ecc.curve} curve The curve that this point lies on.
 * @param {bigInt} x The x coordinate.
 * @param {bigInt} y The y coordinate.
 */
sjcl.ecc.point = function(curve,x,y) {
  if (x === undefined) {
    this.isIdentity = true;
  } else {
    this.x = x;
    this.y = y;
    this.isIdentity = false;
  }
  this.curve = curve;
};

sjcl.ecc.point.prototype = {
  toJac: function() {
    return new sjcl.ecc.pointJac(this.curve, this.x, this.y, new this.curve.field(1));
  },

  mult: function(k) {
    return this.toJac().mult(k, this).toAffine();
  },
  
  /**
   * Multiply this point by k, added to affine2*k2, and return the answer in Jacobian coordinates.
   * @param {bigInt} k The coefficient to multiply this by.
   * @param {bigInt} k2 The coefficient to multiply affine2 this by.
   * @param {sjcl.ecc.point} affine The other point in affine coordinates.
   * @return {sjcl.ecc.pointJac} The result of the multiplication and addition, in Jacobian coordinates.
   */
  mult2: function(k, k2, affine2) {
    return this.toJac().mult2(k, this, k2, affine2).toAffine();
  },
  
  multiples: function() {
    var m, i, j;
    if (this._multiples === undefined) {
      j = this.toJac().doubl();
      m = this._multiples = [new sjcl.ecc.point(this.curve), this, j.toAffine()];
      for (i=3; i<16; i++) {
	j = j.add(this);
	m.push(j.toAffine());
      }
    }
    return this._multiples;
  },

  isValid: function() {
    return this.y.square().equals(this.curve.b.add(this.x.mul(this.curve.a.add(this.x.square()))));
  },

  toBits: function() {
    return sjcl.bitArray.concat(this.x.toBits(), this.y.toBits());
  }
};

/**
 * Represents a point on a curve in Jacobian coordinates. Coordinates can be specified as bigInts or strings (which
 * will be converted to bigInts).
 *
 * @constructor
 * @param {bigInt/string} x The x coordinate.
 * @param {bigInt/string} y The y coordinate.
 * @param {bigInt/string} z The z coordinate.
 * @param {sjcl.ecc.curve} curve The curve that this point lies on.
 */
sjcl.ecc.pointJac = function(curve, x, y, z) {
  if (x === undefined) {
    this.isIdentity = true;
  } else {
    this.x = x;
    this.y = y;
    this.z = z;
    this.isIdentity = false;
  }
  this.curve = curve;
};

sjcl.ecc.pointJac.prototype = {
  /**
   * Adds S and T and returns the result in Jacobian coordinates. Note that S must be in Jacobian coordinates and T must be in affine coordinates.
   * @param {sjcl.ecc.pointJac} S One of the points to add, in Jacobian coordinates.
   * @param {sjcl.ecc.point} T The other point to add, in affine coordinates.
   * @return {sjcl.ecc.pointJac} The sum of the two points, in Jacobian coordinates. 
   */
  add: function(T) {
    var S = this, sz2, c, d, c2, x1, x2, x, y1, y2, y, z;
    if (S.curve !== T.curve) {
      throw("sjcl.ecc.add(): Points must be on the same curve to add them!");
    }

    if (S.isIdentity) {
      return T.toJac();
    } else if (T.isIdentity) {
      return S;
    }

    sz2 = S.z.square();
    c = T.x.mul(sz2).subM(S.x);

    if (c.equals(0)) {
      if (S.y.equals(T.y.mul(sz2.mul(S.z)))) {
	// same point
	return S.doubl();
      } else {
	// inverses
	return new sjcl.ecc.pointJac(S.curve);
      }
    }
    
    d = T.y.mul(sz2.mul(S.z)).subM(S.y);
    c2 = c.square();

    x1 = d.square();
    x2 = c.square().mul(c).addM( S.x.add(S.x).mul(c2) );
    x  = x1.subM(x2);

    y1 = S.x.mul(c2).subM(x).mul(d);
    y2 = S.y.mul(c.square().mul(c));
    y  = y1.subM(y2);

    z  = S.z.mul(c);

    return new sjcl.ecc.pointJac(this.curve,x,y,z);
  },
  
  /**
   * doubles this point.
   * @return {sjcl.ecc.pointJac} The doubled point.
   */
  doubl: function() {
    if (this.isIdentity) { return this; }

    var
      y2 = this.y.square(),
      a  = y2.mul(this.x.mul(4)),
      b  = y2.square().mul(8),
      z2 = this.z.square(),
      c  = this.x.sub(z2).mul(3).mul(this.x.add(z2)),
      x  = c.square().subM(a).subM(a),
      y  = a.sub(x).mul(c).subM(b),
      z  = this.y.add(this.y).mul(this.z);
    return new sjcl.ecc.pointJac(this.curve, x, y, z);
  },

  /**
   * Returns a copy of this point converted to affine coordinates.
   * @return {sjcl.ecc.point} The converted point.
   */  
  toAffine: function() {
    if (this.isIdentity || this.z.equals(0)) {
      return new sjcl.ecc.point(this.curve);
    }
    var zi = this.z.inverse(), zi2 = zi.square();
    return new sjcl.ecc.point(this.curve, this.x.mul(zi2).fullReduce(), this.y.mul(zi2.mul(zi)).fullReduce());
  },
  
  /**
   * Multiply this point by k and return the answer in Jacobian coordinates.
   * @param {bigInt} k The coefficient to multiply by.
   * @param {sjcl.ecc.point} affine This point in affine coordinates.
   * @return {sjcl.ecc.pointJac} The result of the multiplication, in Jacobian coordinates.
   */
  mult: function(k, affine) {
    if (typeof(k) === "number") {
      k = [k];
    } else if (k.limbs !== undefined) {
      k = k.normalize().limbs;
    }
    
    var i, j, out = new sjcl.ecc.point(this.curve).toJac(), multiples = affine.multiples();

    for (i=k.length-1; i>=0; i--) {
      for (j=sjcl.bn.prototype.radix-4; j>=0; j-=4) {
	out = out.doubl().doubl().doubl().doubl().add(multiples[k[i]>>j & 0xF]);
      }
    }
    
    return out;
  },
  
/**
   * Multiply this point by k, added to affine2*k2, and return the answer in Jacobian coordinates.
   * @param {bigInt} k The coefficient to multiply this by.
   * @param {sjcl.ecc.point} affine This point in affine coordinates.
   * @param {bigInt} k2 The coefficient to multiply affine2 this by.
   * @param {sjcl.ecc.point} affine The other point in affine coordinates.
   * @return {sjcl.ecc.pointJac} The result of the multiplication and addition, in Jacobian coordinates.
   */
  mult2: function(k1, affine, k2, affine2) {
    if (typeof(k1) === "number") {
      k1 = [k1];
    } else if (k1.limbs !== undefined) {
      k1 = k1.normalize().limbs;
    }
    
    if (typeof(k2) === "number") {
      k2 = [k2];
    } else if (k2.limbs !== undefined) {
      k2 = k2.normalize().limbs;
    }
    
    var i, j, out = new sjcl.ecc.point(this.curve).toJac(), m1 = affine.multiples(),
        m2 = affine2.multiples(), l1, l2;

    for (i=Math.max(k1.length,k2.length)-1; i>=0; i--) {
      l1 = k1[i] | 0;
      l2 = k2[i] | 0;
      for (j=sjcl.bn.prototype.radix-4; j>=0; j-=4) {
        out = out.doubl().doubl().doubl().doubl().add(m1[l1>>j & 0xF]).add(m2[l2>>j & 0xF]);
      }
    }
    
    return out;
  },
  
  isValid: function() {
    var z2 = this.z.square(), z4 = z2.square(), z6 = z4.mul(z2);
    return this.y.square().equals(
	    this.curve.b.mul(z6).add(this.x.mul(
	      this.curve.a.mul(z4).add(this.x.square()))));
  }
};

/**
 * Construct an elliptic curve. Most users will not use this and instead start with one of the NIST curves defined below.
 *
 * @constructor
 * @param {bigInt} p The prime modulus.
 * @param {bigInt} r The prime order of the curve.
 * @param {bigInt} a The constant a in the equation of the curve y^2 = x^3 + ax + b (for NIST curves, a is always -3).
 * @param {bigInt} x The x coordinate of a base point of the curve.
 * @param {bigInt} y The y coordinate of a base point of the curve.
 */
sjcl.ecc.curve = function(Field, r, a, b, x, y) {
  this.field = Field;
  this.r = Field.prototype.modulus.sub(r);
  this.a = new Field(a);
  this.b = new Field(b);
  this.G = new sjcl.ecc.point(this, new Field(x), new Field(y));
};

sjcl.ecc.curve.prototype.fromBits = function (bits) {
  var w = sjcl.bitArray, l = this.field.prototype.exponent + 7 & -8,
      p = new sjcl.ecc.point(this, this.field.fromBits(w.bitSlice(bits, 0, l)),
			    this.field.fromBits(w.bitSlice(bits, l, 2*l)));
  if (!p.isValid()) {															//modified to add alert in PassLok								//
	document.getElementById("mainmsg").innerHTML = '<span>Invalid Lock</span>';	//
    throw new sjcl.exception.corrupt("not on the curve!");						//
  }																				//
  return p;
};

//F. Ruiz: Added the NIST 521-bit elliptic curve parameters, removed the other curves since they are not used in PassLok

sjcl.ecc.curves = {
	
  c521: new sjcl.ecc.curve(				//these parameters are my addition to ecc.js
	sjcl.bn.prime.p521,
	"0x5AE79787C40D069948033FEB708F65A2FC44A36477663B851449048E16EC79BF6",
	- 3,
"0x051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00",
"0xc6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66",
"0x11839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650")
};

//End of SJCL code, some of its elGamal, ECDSA code is used in the functions below 

//Now the ORIGINAL PASSLOK CODE BEGINS

//if Key box is empty, this displays a random Key in the top box and its Lock in the bottom box, otherwise display Lock or combine Lock and Key
function fillkeys(){
	var learnOn = document.getElementById("learnmode").checked;
	var keymsg = document.getElementById("keymsg"),			//for displaying messages above key box
		mainmsg = document.getElementById("mainmsg");
		keymsg.innerHTML = "";
		mainmsg.innerHTML = "";
	var plainstr = document.plain.text.value.split("=").sort(function (a, b) { return b.length - a.length; })[0];   //remove end tags in the main box
	plainstr = plainstr.replace(/\s/g,'');										//remove also spaces
	if((plainstr != "") && (plainstr.length != 87)){
		keymsg.innerHTML = '<span style="color:red">The main box is not empty. Clear it before you try again<span>';
		mainmsg.innerHTML = 'Clear this box before making a Lock';
		throw ("main box not empty")
	};
	var secstr = document.key.text.value.trim();			//cut trailing spaces
	if(secstr===""){										//the key box empty, make Random Key and Lock
		if (learnOn){
			var reply2 = confirm("A random Key will be placed in the key box and its Lock in the main box. Cancel if this is not what you want.");
			if(reply2===false) throw("random canceled");
		};
		document.key.text.value = sjcl.codec.base64.fromBits(sjcl.random.randomWords('17','0')).slice(0,85);   //make it 85 characters long so it can be distinguished from a shared Key, which is 86
		showpub();
		keymsg.innerHTML = 'Random Key and Lock made';
		mainmsg.innerHTML = 'This is the Lock';
		throw("new random Key");
	};	
	if (plainstr.length===87){								//if it's a Lock in the main box, merge it with the secret Key
		if (learnOn){
			var reply3 = confirm("The Lock in the main box will be combined with the Key in the key box, and the resulting Key will be placed in the key box. The main box will be erased. Cancel if this is not what you want.");
			if(reply3===false) throw("merge canceled");
		};
		showshared();
		keymsg.innerHTML = 'Key and Lock merged';
		mainmsg.innerHTML = 'Lock cleared';
		throw ("it was a lock, merged with key");
	} else {												//replace the main box with Lock made from the key box
		if (learnOn){
			var reply4 = confirm("The Lock matching the Key in the key box will be placed in the main box, replacing its contents. Cancel if this is not what you want.");
			if(reply4===false) throw("lock canceled");
		};
		showpub();
		keymsg.innerHTML = 'Lock in main box';
		mainmsg.innerHTML = 'This is the Lock';
	};	
};

//display the public part, in case it got deleted
function showpub(){
	var secstr = document.key.text.value.trim();
	var pubstr = makepub(secstr);
	if (document.getElementById("notags").checked === false){
		document.plain.text.value = "PL15lok=" + pubstr + "=PL15lok";
	}else{
		document.plain.text.value = pubstr;
	}
};

//makes the public string of a private string
function makepub(secstr){
	var curve = sjcl.ecc.curves["c521"],					//make curve object
		sec = toexponent(secstr),							//retrieve secret Key, correctly formatted as an EC exponent
	    pub = curve.G.mult(sec),							//make public key or Lock
		pubstr = sjcl.codec.base64.fromBits(pub.toBits());
	return pubstr.slice(1,88)								//strip initial "A", only x part
};

//key reformatting and stretching for secret key (shared key is formatted automatically by sjcl) for 521 bit keys
function toexponent(string){
	var iter = passwordChanged();			//get number of iterations from Key strength meter
	var w = sjcl.bitArray;
	return sjcl.bn.fromBits(w.bitSlice(sjcl.misc.pbkdf2(string,"",iter,528)));	//use no salt, iteration number variable according to Key strength, 528 bits
};

//display shared secret made from secret and public keys 
function showshared(){
	var secstr = document.key.text.value.trim(),
		pubstr = document.plain.text.value.replace(/\s/g,'');			//ignore spaces in public key
		pubstr = pubstr.split("=").sort(function (a, b) { return b.length - a.length; })[0];		//remove tags
		pubstr = pubstr.replace(/[^a-zA-Z0-9+/ ]+/g, ''); 					//takes out anything that is not base64
		pubstr = "A" + pubstr;										//add inital "A" before calculation
	document.key.text.value = makeshared(secstr,pubstr);
	document.plain.text.value = "";
};

//this one makes the shared secret
function makeshared(secstr,xstr){
	var curve = sjcl.ecc.curves["c521"],
		sec = toexponent(secstr),
		ystr = yfromx(curve,xstr),				      				//retrieve y coordinate from x coordinate
		pub = curve.fromBits(sjcl.codec.base64.toBits(xstr+ystr)),  //make public key object containing both x and y
		sharedsec = pub.mult(sec),
		sharedstr = sjcl.codec.base64.fromBits(sharedsec.toBits());
	return sharedstr.slice(2,88)  									//strip initial "A", only x part. Strip also 2nd char so it's not mistaken for a lock
};

function yfromx(curve,xstr){
	var x = sjcl.bn.fromBits(sjcl.codec.base64.toBits(xstr)),   //the following to retrieve y coordinate from x coordinate
		y = curve.b.add(x.mul(curve.a.add(x.square())));		//this is actually y^2, square root by special case of Tonelli-Shanks follows
	var i;
	for (i=0; i<519; i++) {
  		y = y.square();											//performs y^((p+1)/4), since p = 2^521 - 1, (p=1)/4=2^519, all is mod p
		};
	return sjcl.codec.base64.fromBits(y.toBits());
};

//display a hash of the textarea for authentication purposes
function makehash(){
	if (document.getElementById("learnmode").checked === true){
			var reply = confirm("The content of this box will be replaced with its ID. This is irreversible. Cancel if this is not what you want.");
			if(reply===false) throw("ID canceled");
		};
	var mine = document.extra.text.value.trim(),		//remove spaces at start and end
		extramsg = document.getElementById("extramsg");
	if(mine == "") {
		extramsg.innerHTML = '<span style="color:red">Nothing to make an ID of</span>';
		throw("textarea empty");
	};
	if(mine.split("-").length == 16){
		extramsg.innerHTML = "<span style='color:red'>Won't make an ID of an ID</span>";
		throw("ID in box");
	};	
	if (mine.length < 267){								//if it's the length of a signature or shorter: remove spaces, tags and anything that is not base64
		mine = mine.replace(/\s/g,'');
		mine = mine.split("=").sort(function (a, b) { return b.length - a.length; })[0];  
		mine = mine.replace(/[^a-zA-Z0-9+/ ]+/g, '');
	};
	mine = sjcl.codec.hex.fromBits(sjcl.hash.sha256.hash(mine)).match(/.{1,4}/g).join("-"); //take hash, make it hex, cut into 4-char pieces and join with dashes
	document.extra.text.value = mine;
	extramsg.innerHTML = 'Box contents replaced with ID'
};

var encrypting;		//global flag so decoy input doesn't get confused

//AES encryption process: determines which kind of encryption by looking at the length of what's in the Key box
function Encrypt_text(){
	var shortOn = document.getElementById("shortmode").checked,
		learnOn = document.getElementById("learnmode").checked,
		tagsOff = document.getElementById("notags").checked;
	var mainmsg = document.getElementById("mainmsg"),
		extramsg = document.getElementById("extramsg");
	var secstr = document.key.text.value.trim();
	var pubstr = secstr;
		pubstr = pubstr.replace(/\s/g,'');															//remove spaces
		pubstr = pubstr.split("=").sort(function (a, b) { return b.length - a.length; })[0];		//remove tags									
		pubstr = pubstr.replace(/[^a-zA-Z0-9+/ ]+/g, ''); 					//takes out anything that is not base64	
		
	if (pubstr.length === 87){										//if it's a public key in the key box = Lock mode
		if (learnOn){
			var reply = confirm("The contents of the main box will be locked with the Lock in the key box and the result will be placed in the main box. This is irreversible. Cancel if this is not what you want.");
			if(reply===false) throw("public encryption canceled");
		};
		var secstrdum = sjcl.codec.base64.fromBits(sjcl.random.randomWords('17','0')).slice(0,87),	//make dummy Key
			pubstrdum = makepub(secstrdum);							//makes 87 char dummy public key, initial A stripped	
			pubstr = "A" + pubstr;
		var keystr = makeshared(secstrdum,pubstr);					//make AES key from dummy secret and recipient's public key
		if(shortOn){
			var iv = sjcl.codec.base64.fromBits(sjcl.random.randomWords('2','0'))					//11 char serial in short mode, no salt
			var salt = "";
			var text = encodeURI(document.plain.text.value).replace(/%20/g, ' ');
				text = text + "                                                         ";   //clip or add spaces to make a 38 char message 
				text = text.slice(0,38);			
		} else{
			var iv = sjcl.codec.base64.fromBits(sjcl.random.randomWords('4','0')),					//22 char serial in regular mode, salt can hide a Lock
				salt = makesalt(iv,87),	
				text = ULZSS.encode(document.plain.text.value)					//compress longer strings; add a tag to recognize it		
		}
		var cipherj = JSON.parse(sjcl.encrypt(keystr,text,{"iv":iv,"salt":salt,"ks":256,"iter": 101}));   //use 256 bit keys, min stretching for random key
		if (learnOn){
			alert("The recipent will need to place his/her secret Key in the key box to unlock the message in the main box.");
		};
		if (shortOn){			//display adding dummy public key and anonymous tags, depending on mode
			document.plain.text.value = cipherj.iv + cipherj.salt + pubstrdum + cipherj.ct;
			if(typeof window.orientation !== 'undefined'){
				plain2extra();
				extramsg.innerHTML = 'Locking successful. Copy and click SMS';
				selectExtra()
			}
		} else if(tagsOff){
			document.plain.text.value = "!" + cipherj.iv + cipherj.salt + pubstrdum + cipherj.ct;
			mainmsg.innerHTML = "Locking successful. To be unlocked by recipient's Key"
		} else {
			document.plain.text.value = "PL15msl=!" + cipherj.iv + cipherj.salt + pubstrdum + cipherj.ct + "=PL15msl";
			mainmsg.innerHTML = "Locking successful. To be unlocked by recipient's Key"
		}
		
	} else {														//not a public key, symmetric encryption		
		if (learnOn){
			var reply3 = confirm("The contents of the main box will be locked with the secret Key in the key box, and the result will replace the main box. Cancel if this is not what you want.");
			if(reply3===false) throw("sym encryption canceled");
		};
		var iter = passwordChanged();						//get number of iterations from Key strength meter, minimum is 101
		if (iter<100) iter=iter+100;
		if (shortOn){						//salt can hide 37 chars in short mode, shorter iv
			var iv = sjcl.codec.base64.fromBits(sjcl.random.randomWords('2','0')),
				salt = makesalt(iv,37),
				text = encodeURI(document.plain.text.value).replace(/%20/g, ' ');
				text = text + "                                                         ";   //clip or add spaces to make a 58 char message 
				text = text.slice(0,58);	
		} else {
			var iv = sjcl.codec.base64.fromBits(sjcl.random.randomWords('4','0')),			//salt hides 152 chars in regular mode
				salt = makesalt(iv,152),
				text = ULZSS.encode(document.plain.text.value)		
		}
		var cipherj = JSON.parse(sjcl.encrypt(secstr,text,{"iv":iv,"salt":salt,"ks":256,"iter": iter}));
		if(secstr.length===86){													//if shared Key, use a different tag
			if (learnOn){
				alert("The recipent will need your Lock and his/her secret Key to unlock the message in the main box.");
			};
			if(shortOn){
				document.plain.text.value = "#" + cipherj.iv + cipherj.salt + cipherj.ct;
				if(typeof window.orientation !== 'undefined'){							//detect mobile
					plain2extra();
					extramsg.innerHTML = 'Locking successful. Copy and click SMS';
					selectExtra()
				}
			} else if (tagsOff){
				document.plain.text.value = "#" + cipherj.iv + cipherj.salt + cipherj.ct;
				mainmsg.innerHTML = "Locking successful. To be unlocked by combining first your Key and the recipient's Lock"
			}else{
				document.plain.text.value = "PL15mss=#" + cipherj.iv + cipherj.salt + cipherj.ct + "=PL15mss";
				mainmsg.innerHTML = "Locking successful. To be unlocked by combining first your Key and the recipient's Lock"
			}
		}else{																	//not shared Key
			if (learnOn){
				alert("The recipent will need to place the same Key in the key box to unlock the message in the main box.");
			};
			if(shortOn){
				document.plain.text.value = "@" + cipherj.iv + cipherj.salt + cipherj.ct;
				if(typeof window.orientation !== 'undefined'){							//detect mobile
					plain2extra();
					extramsg.innerHTML = 'Locking successful. Copy and click SMS';
					selectExtra()
				}
			} else if (tagsOff){
				document.plain.text.value = "@" + cipherj.iv + cipherj.salt + cipherj.ct;
				mainmsg.innerHTML = "Locking successful. To be unlocked by the same Key"
			}else{
				document.plain.text.value = "PL15msk=@" + cipherj.iv + cipherj.salt + cipherj.ct + "=PL15msk";
				mainmsg.innerHTML = "Locking successful. To be unlocked by the same Key"
			}
		}
	}
	document.decoyIn.text.value = "";
	document.decoyIn.key.value = "";
	document.decoyOut.key.value = "";
};

//closes input divs
function closebox() {
	document.getElementById("shadow").style.display = "none";
	document.getElementById("decoyIn").style.display = "none";
	document.getElementById("decoyOut").style.display = "none";
	document.getElementById("partsIn").style.display = "none"
}

//encrypts a hidden message into the salt value used by regular encryption, or makes a random salt also encoded by AES so it's indistinguishable
function makesalt(iv,leng){
	if (document.getElementById("decoymode").checked === true){
		if (document.getElementById("learnmode").checked === true){
			var reply = confirm("You are adding a hidden message in Decoy mode. Cancel if this is not what you want.Then uncheck Decoy mode below.");
			if(reply===false) throw("decoy encryption canceled");
		};
		if ((document.decoyIn.key.value.trim() == "")||(document.decoyIn.text.value.trim() == "")){ //stop to display the decoy entry form if there is no hidden message or key
			document.getElementById("decoyIn").style.display = "block";		//display decoy form, and back shadow
			document.getElementById("shadow").style.display = "block";			
			throw ("stopped for decoy input")				
		}
		var key = document.decoyIn.key.value,
			text = encodeURI(document.decoyIn.text.value.replace(/%20/g, ' ')),
			iter = 10000;															//key may be weak, so stretch it
	} else {												//no decoy mode, so salt comes from random text and key, no stretching
		var key = sjcl.codec.base64.fromBits(sjcl.random.randomWords('8','0')),
			text = sjcl.codec.base64.fromBits(sjcl.random.randomWords('57','0')).slice(0,214),
			iter = 101;														//minimum allowed
	};
	while (text.length < leng) {										//clip or add spaces to make the number of characters required
			text = text + "          ";
		};
		text = text.slice(0,leng);
		var cipherj = JSON.parse(sjcl.encrypt(key,text,{"iv":iv,"salt":"","ks":256,"iter":iter}));
		return cipherj.ct;
};

//AES decryption process: determines which kind of encryption by looking at first character after the initial tag. Calls Encrypt_text or showpub as appropriate
function Decrypt_text(){
	encrypting = true;
	var decoyon = document.getElementById("decoymode").checked,
		learnOn = document.getElementById("learnmode").checked;
	var keymsg = document.getElementById("keymsg"),
		mainmsg = document.getElementById("mainmsg");
		keymsg.innerHTML = "";
		mainmsg.innerHTML = "";
	var	cipherstr = document.plain.text.value.trim(),
		secstr = document.key.text.value.trim();
	if (cipherstr===""){								//if the main box or the text box are empty, display a warning
		mainmsg.innerHTML = '<span style="color:red">Nothing to lock or unlock</span>';
		throw("the main box empty");
	};
	if (secstr === ""){
		plain2key();
		keymsg.innerHTML = '<span style="color:red">Enter a Key or a Lock</span>';
		throw("key box empty");
	}else{
		var pubstr = secstr.split("=").sort(function (a, b) { return b.length - a.length; })[0];		//strip tags, if any, to check later if this is a Lock
			pubstr = pubstr.replace(/[^a-zA-Z0-9+/ ]+/g, '').replace(/\s/g,'');
	};
	cipherstr = cipherstr.split("=").sort(function (a, b) { return b.length - a.length; })[0];   //remove end tags
	var type = cipherstr.slice(0,1);									//get encryption type. !=public, @=symmetric, #=signed
	cipherstr = cipherstr.replace(/[^a-zA-Z0-9+/ ]+/g, '');				//remove anything that is not base64
	
	if (cipherstr.length===160){					//short asymmetric decryption
		if (learnOn){
			var reply = confirm("The short message in the main box was locked with your personal Lock, and will now be unlocked if your secret Key is in the key box, replacing the locked message. Cancel if this is not what you want.");
			if(reply===false) throw("public decryption canceled");
		};
			if (pubstr.length === 87){
				plain2key();
				message.innerHTML = '<span style="color:red">This is a Lock. Enter a Key</span>';	
				throw("lock in key box");
			};
		var	iv = cipherstr.slice(0,11),									//get iv, salt, and later ct data and public key
			salt = "";			
		var pubstrdum = cipherstr.slice(11,98);			
		pubstrdum = "A" + pubstrdum;
		var keystr = makeshared(secstr,pubstrdum);
		var	ct = cipherstr.slice(98,cipherstr.length);
		cipherstr = '{"iv":"' + iv + '","salt":"' + salt + '","ct":"' + ct + '","ks":256,"iter":101}';	//add labels and keylength to data, minimum keystretching
		document.plain.text.value = sjcl.decrypt(keystr,cipherstr).trim();
		if(!decoyon) mainmsg.innerHTML = 'Unlock successful'
	}
	
	else if (type === "!"){									//public decryption
		if (decoyon){
			var reply = confirm("The message in the main box was locked with your personal Lock, and will now be unlocked if your secret Key is in the key box, replacing the locked message. Cancel if this is not what you want.");
			if(reply===false) throw("public decryption canceled");
		};
			if (pubstr.length === 87){
				plain2key();
				keymsg.innerHTML = '<span style="color:red">This is a Lock. Enter a Key</span>';
				throw("lock in key box");
			};		
		var	iv = cipherstr.slice(0,22),									//get iv, salt, and later ct data and public key
			salt = cipherstr.slice(22,149);			
		if (decoyon) decoydecrypt(iv,salt); 	//do decoy decryption first, in case regular fails
		var pubstrdum = cipherstr.slice(149,236);			
		pubstrdum = "A" + pubstrdum;
		var keystr = makeshared(secstr,pubstrdum),
			ct = cipherstr.slice(236,cipherstr.length);
		cipherstr = '{"iv":"' + iv + '","salt":"' + salt + '","ct":"' + ct + '","ks":256,"iter":101}';	//add labels and keylength to data, minimum keystretching
		document.plain.text.value = ULZSS.decode(sjcl.decrypt(keystr,cipherstr));
		if (!decoyon) mainmsg.innerHTML = 'Unlock successful'
	}
	
	else if ((type === "@") || (type === "#")){			//symmetric decryption
		if (learnOn){
			var reply2 = confirm("The message in the main box was locked with a Key, and will now be unlocked if the same Key is in the key box, replacing the locked message. Cancel if this is not what you want.");
			if(reply2===false) throw("sym decryption canceled");
		};
		if (cipherstr.length == 159){					//short symmetric message
			var	iv = cipherstr.slice(0,11),
				salt = cipherstr.slice(11,71),
				ct = cipherstr.slice(71,cipherstr.length);
		} else {										//regular symmetric message
			var	iv = cipherstr.slice(0,22),
				salt = cipherstr.slice(22,236),
				ct = cipherstr.slice(236,cipherstr.length);
		}				
		var keystr = secstr;
		if (decoyon) decoydecrypt(iv,salt);
		if ((type === "#") && !(keystr.length === 86)){		//signed message, key should be 86-char shared key
			mainmsg.innerHTML = "<span style='color:red'>Signed message. First combine your Key and the sender's Lock</span>";
			throw("need a shared key");
		};
		var iter = passwordChanged();						//get number of iterations from Key strength meter
		if(iter<100) iter=iter+100;
		var cipherstr2 = '{"iv":"' + iv + '","salt":"' + salt + '","ct":"' + ct + '","ks":256,"iter":' + iter.toString() + '}';
		if (cipherstr.length == 159){
			document.plain.text.value = sjcl.decrypt(keystr,cipherstr2).trim()
			if (!decoyon) mainmsg.innerHTML = 'Unlock successful'
		}else{
			document.plain.text.value = ULZSS.decode(sjcl.decrypt(keystr,cipherstr2))
			if (!decoyon) mainmsg.innerHTML = 'Unlock successful'
		}	
	}else{
		Encrypt_text()									//none of the known encrypted types, therefore encrypt rather than decrypt
	};
};

//decrypt the message hidden in the salt, for decoy mode
function decoydecrypt(iv,ct){
	var mainmsg = document.getElementById("mainmsg");
		mainmsg.innerHTML = "";
		if (document.getElementById("learnmode").checked === true){
			var	key2 = prompt("Decoy mode is selected, so please write the Password used to lock the hidden message. If you don't expect a hidden message, uncheck Decoy mode below.");
		} else {
		if (document.decoyOut.key.value.trim() == ""){						//stop to display the decoy key entry form if there is no key entered
			document.getElementById("decoyOut").style.display = "block";
			document.getElementById("shadow").style.display = "block";			
			throw ("stopped for decoy input")				
		}	
		var key2 = document.decoyOut.key.value;			
			document.decoyOut.key.value = ""
		};
		var	cipherstr2 = '{"iv":"' + iv + '","salt":"' + "" + '","ct":"' + ct + '","ks":256,"iter":10000}';
		mainmsg.innerHTML = '<span style="color:blue">Hidden message: ' + decodeURI(sjcl.decrypt(key2,cipherstr2)) + '</span>'
};

//takes a hash of the plaintext and generates an ECDSA signature
function Signhash(){
	var keymsg = document.getElementById("keymsg"),
		mainmsg = document.getElementById("mainmsg");
		keymsg.innerHTML = "";
		mainmsg.innerHTML = "";
	var secstr = document.key.text.value.trim();
	if (document.getElementById("learnmode").checked === true){
		var reply = confirm("A signature matching the contents of the main box will be made using your secret Key in the key box, and the resulting signature will be added to the end of the main box. Cancel if this is not what you want.");
		if(reply===false) throw("signature canceled");
	};
	var pubstr = secstr.replace(/\s/g,'');
		pubstr = pubstr.split("=").sort(function (a, b) { return b.length - a.length; })[0];				
		pubstr = pubstr.replace(/[^a-zA-Z0-9+/ ]+/g, '');
	if (pubstr.length===87){											//this is a Lock, not a Key
		plain2key();
		keymsg.innerHTML = '<span style="color:red">This is a Lock. Enter your Key here</span>';	
		throw("lock instead of key")
	};
	var hash = sjcl.hash.sha512.hash(document.plain.text.value.trim()),						//take SHA512 hash of plaintext, trimming space at ends
		sec = toexponent(secstr),
		curve = sjcl.ecc.curves["c521"],
		R = curve.r,
		l = R.bitLength(),
    	k = sjcl.bn.random(R.sub(1), 0).add(1),
    	r = curve.G.mult(k).x.mod(R),
		s = sjcl.bn.fromBits(hash).add(r.mul(sec)).mul(k.inverseMod(R)).mod(R),
		sigstr = sjcl.codec.base64.fromBits(sjcl.bitArray.concat(r.toBits(l), s.toBits(l)));	//make it base64
	var iv = sjcl.codec.base64.fromBits(sjcl.random.randomWords('2','0')),						//for hidden message, if activated
		padding = makesalt(iv,40);
	if (document.getElementById("notags").checked === false){
		document.plain.text.value = document.plain.text.value + "\n\n" + "PL15sig=" + sigstr.slice(1,sigstr.length) + iv.slice(0,11) + padding + "=PL15sig";	//strip initial "A" and add decoy iv & padding and tags
	}else{
		document.plain.text.value = document.plain.text.value + "\n\n" + sigstr.slice(1,sigstr.length) + iv.slice(0,11) + padding
	}
};	

//verifies the ECDSA signature of a hash of the plaintext, calls Signhash as appropriate. Algorithm from SJCL ecc.js, but not the latest version
function Verifyhash(){
	encrypting = false;
	var keymsg = document.getElementById("keymsg"),
		mainmsg = document.getElementById("mainmsg");
		keymsg.innerHTML = "";
		mainmsg.innerHTML = "";
	var text = document.plain.text.value.trim();
	if (text==""){												//nothing in text box
		mainmsg.innerHTML = '<span style="color:red">Nothing to sign or verify</span>';
		throw("no text")
	};			
	var	pubstr = document.key.text.value.trim();
	if (pubstr==""){											//nothing in sec box
		plain2key();
		keymsg.innerHTML = '<span style="color:red">Enter a Key to sign, or a Lock to verify</span>';	
		throw("no key present")
	};
	var	sign = text.split(/\r?\n/);
		sign = sign[sign.length-1];							//this is a signature if added as last line of text
	var	sigstr = sign.replace(/\s/g,'');
	var sigstripped = sigstr.split("=").sort(function (a, b) { return b.length - a.length; })[0];
	if (!(sigstripped.length===250)){							//no signature tag, therefore making sign	
		Signhash();
		throw("no signature, creating one")
	};
	if (document.getElementById("learnmode").checked === true){
		var reply = confirm("The text in the main box has been signed with somebody's secret Key. I will now verify if the sign is correct for this text and the matching Lock, which should be present in the key box, and will display the result in a popup. Cancel if this is not what you want.");
		if(reply===false) throw("sign verification canceled");
	};
		sigstr = sigstr.split("=").sort(function (a, b) { return b.length - a.length; })[0];			
		sigstr = sigstr.replace(/[^a-zA-Z0-9+/ ]+/g, '');
	if (sigstr.length != 250){
		mainmsg.innerHTML = '<span style="color:red">Invalid signature</span>'
		throw("invalid signature")
	};		
		pubstr = pubstr.replace(/\s/g,'');
		pubstr = pubstr.split("=").sort(function (a, b) { return b.length - a.length; })[0];	//remove tags
		pubstr = pubstr.replace(/[^a-zA-Z0-9+/ ]+/g, ''); 
	if (pubstr == ""){
		plain2key();
		keymsg.innerHTML = "<span style='color:red'>Enter the signer's Lock in the key box</span>";
		throw("public key empty")
	};
	if (!(pubstr.length===87)){
		plain2key();
		keymsg.innerHTML = '<span style="color:red">Enter a valid Lock</span>';
		throw("invalid public key")
	};
		text = text.replace(/\r?\n?[^\r\n]*$/, "");						//remove last line
	var hash = sjcl.hash.sha512.hash(text.trim()),						//take SHA512 hash of plaintext, ignoring spaces			
		curve = sjcl.ecc.curves["c521"],
		xstr = "A" + pubstr.slice(0,pubstr.length),
		ystr = yfromx(curve,xstr),
	 	pub = curve.fromBits(sjcl.codec.base64.toBits(xstr+ystr)),
		rs = sjcl.codec.base64.toBits("A" + sigstr.slice(0,175)),		//recover signature part
		w = sjcl.bitArray,
        R = curve.r,
        l = R.bitLength(),
        r = sjcl.bn.fromBits(w.bitSlice(rs,0,l)),
        s = sjcl.bn.fromBits(w.bitSlice(rs,l,2*l)),
		u = s.inverseMod(R),	
        hG = sjcl.bn.fromBits(hash).mul(u).mod(R),	
        hA = r.mul(u).mod(R),
		check = true,	
		r2 = curve.G.mult2(hG, hA, pub).x.mod(R);
		if (!r2.equals(r)){													//hack from when y is the wrong root of y^2
			var y = sjcl.bn.fromBits(sjcl.codec.base64.toBits(ystr)),
				p = curve.field.modulus.copy(),
				y2 = p.sub(y),												//this should be the right y
				ystr2 = sjcl.codec.base64.fromBits(y2.toBits());		
			pub = curve.fromBits(sjcl.codec.base64.toBits(xstr+ystr2));
			r2 = curve.G.mult2(hG, hA, pub).x.mod(R);
		};																	//end of wrong root hack
    if (r.equals(0) || s.equals(0) || r.greaterEquals(R) || s.greaterEquals(R) || !r2.equals(r)) check = false;
	if (check) {
		mainmsg.innerHTML = '<span style="color:green">The signature is VERIFIED</span>'
		}
	else {
		mainmsg.innerHTML = '<span style="color:magenta">The signature has FAILED verification</span>'
		};
	if (document.getElementById("decoymode").checked === true){				//this part to extract the hidden message, if it exists
		var iv = sigstr.slice(175,186),
			padding = sigstr.slice(186,250);
		decoydecrypt(iv, padding);
	};
};

//add entropy as forms are manipulated
function ce() {
	sjcl.random.addEntropy(Math.floor((((new Date).getMilliseconds()) * 255) / 999), 2, "loadtime");
};

//this is for showing and hiding text in key box
function showsec(){
  var showPasswordCheckBox = document.getElementById("show");
  if(showPasswordCheckBox.checked){
        document.getElementById("pwd").type="TEXT";
  }else{
      document.getElementById("pwd").type="PASSWORD";
  }
};

//function to test password strength
function passwordChanged() {
var iter = 100000;
var keymsg = document.getElementById("keymsg");
	keymsg.innerHTML = '';
var strongRegex = new RegExp("^(?=.{9,})(?=.*[A-Z])(?=.*[a-z])(?=.*[0-9])(?=.*[^a-zA-Z0-9 ]).*$", "g");
var mediumRegex = new RegExp("^(?=.{8,})(((?=.*[A-Z])(?=.*[a-z]))|((?=.*[A-Z])(?=.*[0-9]))|((?=.*[a-z])(?=.*[0-9]))).*$", "g");
var enoughRegex = new RegExp("(?=.{7,}).*", "g");
var pwd = document.getElementById("pwd").value;
	pwd = pwd.replace(/^\d+/,'').replace(/\d+$/,'');		//no credit for initial and trailing numbers
	pwd = pwd.replace(/^[a-zA-Z]/,'');						//no credit for initial letter, small or capital
if (pwd.length==0) {
keymsg.innerHTML = "&nbsp";
} else if (false === enoughRegex.test(pwd)) {
keymsg.innerHTML = '<span style="color:magenta"> Terrible!</span>';		//less than 7 good characters
iter = 100000;
} else if (strongRegex.test(pwd)) {
keymsg.innerHTML = '<span style="color:green">  Good!</span>';	//lowercase, caps, numbers, and sp chars
iter = 1;
} else if (mediumRegex.test(pwd)) {
keymsg.innerHTML = '<span style="color:orange">  Medium</span>';	//either two of lowercase, caps, numbers, but no email
iter = 10000;
} else {
keymsg.innerHTML = '<span style="color:red">  Weak!</span>';		//just one kind of characters
iter = 50000;
};
return iter
};

//formats results depending on tags present and sends to default email
function sendMail() {
	var	extramsg = document.getElementById("extramsg");
		extramsg.innerHTML = "";
	if (document.getElementById("learnmode").checked === true){
		var reply = confirm("A new tab will open, including the contents of this box in your default email. You still need to supply the recipient's address and a title. Only Locks and locked or signed text are allowed. Cancel if this is not what you want.");
		if(reply===false) throw("email canceled");
	};
	var cipherstr = document.extra.text.value;
	cipherstr = cipherstr.split("=").sort(function (a, b) { return b.length - a.length; })[0];
	var type = cipherstr.slice(0,1);
if (document.getElementById("notags").checked === false){			//tags is checked, add explanatory text	
	if(type==="!"){
    	var link = "mailto:"+ "?subject=" + "&body=Message locked with PassLok v.1.5 %0D%0A%0D%0AUnlock with your secret Key. %0D%0A%0D%0A" + encodeURIComponent(document.extra.text.value) + "%0D%0A%0D%0AGet PassLok at http://passlok.com";
	} else if (type==="@"){
		var link = "mailto:"+ "?subject=" + "&body=Message locked with PassLok v.1.5 %0D%0A%0D%0AUnlock with shared Key. %0D%0A%0D%0A" + encodeURIComponent(document.extra.text.value) + "%0D%0A%0D%0AGet PassLok at http://passlok.com";
	} else if (type==="#"){
		var link = "mailto:"+ "?subject=" + "&body=Message locked with PassLok v.1.5 %0D%0A%0D%0AUnlock with your secret Key and the sender's Lock. %0D%0A%0D%0A" + encodeURIComponent(document.extra.text.value) + "%0D%0A%0D%0AGet PassLok at http://passlok.com";
	} else if (cipherstr.length===87){
		var link = "mailto:"+ "?subject=" + "&body=This is my PassLok v.1.5 Lock, use it to send me messages and verify my signature. %0D%0A%0D%0A" + encodeURIComponent(document.extra.text.value) +"%0D%0A%0D%0AGet PassLok at http://passlok.com";
	} else if (cipherstr.length===250){
		var link = "mailto:"+ "?subject=" + "&body=The following is a text signed with PassLok v.1.5. Verify using the signer's Lock.%0D%0A%0D%0AGet PassLok at http://passlok.com%0D%0A%0D%0AThe text, followed by the signature,  BEGINS BELOW THIS LINE:%0D%0A%0D%0A" + encodeURIComponent(document.extra.text.value);			
	} else if (cipherstr.length===160){
		var link = "mailto:"+ "?subject=" + "&body=Short message locked with PassLok v.1.5 %0D%0A%0D%0AStrip everything but the locked message and unlock with Short Message Key.%0D%0A%0D%0A" + encodeURIComponent(document.extra.text.value) + "%0D%0A%0D%0AGet PassLok at http://passlok.com";
	} else{
		extramsg.innerHTML = 'Only Locks, and locked or signed text are allowed for Email';
		throw("illegal text")
	}
}else{														//tags unchecked, no extra text
	if((type=="!")||(type=="@")||(type=="#")||(cipherstr.length==87)||(cipherstr.length==250)||(cipherstr.length==160)){
		var link = "mailto:"+ "?subject=" + "&body=" + encodeURIComponent(document.extra.text.value);
	}else{
		extramsg.innerHTML = '<span style="color:red">Only Locks, and locked or signed text are allowed for Email</span>';		
		throw("illegal text")
	}
}
	if(typeof window.orientation !== 'undefined'){ 	 		//new window for PC, same window for mobile
		window.open(link,"_parent")
	} else {
		window.open(link,"_blank")
	}
}

//calls SMS app (works on mobile only)
function sendSMS() {
	if (document.getElementById("learnmode").checked === true){
		var reply = confirm("The default SMS (texting) app will now open. You need to have copied your short locked message (no Key in the key box) to the clipboard before this, if you want to send one. This only works in smartphones. Cancel if this is not what you want.");
		if(reply===false) throw("SMS canceled");
	};
	if(typeof window.orientation !== 'undefined') window.open("SMS:","_parent");
};

function selectPlain(){
	document.plain.text.selectionStart=0;
	document.plain.text.selectionEnd=document.plain.text.value.length;
};

function selectExtra(){
	document.extra.text.selectionStart=0;
	document.extra.text.selectionEnd=document.extra.text.value.length;
};

//this function implements the Shamir Secret Sharing Scheme, taking the secret from the key box and putting the result in the main box, and vice-versa. To do: capture errors due to insufficient or malformed parts
function secretshare(){
	var learnOn = document.getElementById("learnmode").checked;
	var keymsg = document.getElementById("keymsg");						//for displaying messages above key box
	var plain = document.plain.text.value.trim(),
		sec = document.key.text.value.trim();
	if (!(plain==="")){													//main box not empty: join parts or make one more part
		var shares = plain.replace(/\n\s*\n/g, '\n').split("\n"),		//go from newline-containing string to array
			n = shares.length,
			quorumarr = plain.match(/p\d{3}/);															//quorum in tags is "p" plus 3 digits in a row, first instance
		if(quorumarr == null) {var quorum = n} else {var quorum = parseInt(quorumarr[0].slice(1,4))};	//if tags are missing, ignore quorum, otherwise read it form tags
		if(n < quorum){																					//not enough parts
			keymsg.innerHTML = '<span style="color:red">According to the tags, you need ' + (quorum - n) + ' more parts in the main box</span>'
		};	
		for (var i=0; i < shares.length; i++) {
			shares[i] = shares[i].split("=").sort(function (a, b) { return b.length - a.length; })[0];							//remove tags
			var isLock = shares[i].length;
			shares[i] = "8" + sjcl.codec.hex.fromBits(sjcl.codec.base64.toBits(shares[i].replace(/[^a-zA-Z0-9+/ ]+/g, '')));	//retrieve from base64 back to hex and add initial "8" to each item
		};
		if(sec===""){													//key box empty: join parts
			if (learnOn){
				var reply = confirm("The partial Keys in the main box will be joined to retrieve the original Key, which will be placed in the key box. Please make sure that there are enough partial Keys. Cancel if this is not what you want.");
				if(reply===false) throw("SSSS join canceled");
			};
			if(n === 1){
				keymsg.innerHTML = '<span style="color:red">Only one part in main box</span>';
				throw("insufficient parts")
			};
			var	sechex = secrets.combine(shares),
				secret = sjcl.codec.utf8String.fromBits(sjcl.codec.hex.toBits(sechex));
			document.key.text.value = secret;
			keymsg.innerHTML = 'Join successful';						
		} else {														//key box not empty: add a part instead
			if (learnOn){
				var reply = confirm("Provided there are sufficient parts in the main box, an additional part will be added to the main box.  Cancel if this is not what you want.");
				if(reply===false) throw("SSSS part addition canceled");
			};
			if(n > 254){
				keymsg.innerHTML = '<span style="color:red">Maximum number of parts is 255</span>';		
				throw("max part number reached")
			} else if(isLock === 87){
				keymsg.innerHTML = '<span style="color:red">The main box contains a Lock. Delete it and try again</span>';
				throw("Lock instead of parts")
			} else if(isLock === 250){
				keymsg.innerHTML = '<span style="color:red">The main box contains a signature. Delete it and try again</span>';		
				throw("signature instead of parts")
			} else if(n === 1){
				keymsg.innerHTML = '<span style="color:red">You need more than one part in main box</span>';				
				throw("insufficient parts")
			};
			var	sechex = secrets.combine(shares),						//first check that the key box has the right Key = parts in the main box are good
				secret = sjcl.codec.utf8String.fromBits(sjcl.codec.hex.toBits(sechex));
			if(sec===secret){											//if OK, add more parts. Get index by finding the highest of all the indices present
				var maxindex = 1,
					index = 1;
				for (var i=0; i < shares.length; i++) {					//get greatest index on the set
					index = parseInt(shares[i].slice(1,3),16);
					if (index > maxindex){maxindex = index};
				};
				var	newshare = secrets.newShare(maxindex+1,shares);
					shares = shares.concat(newshare);
				displayshare(shares,quorum);							//required parts was read from tag
				keymsg.innerHTML = 'Part added to main box';
			} else {
				keymsg.innerHTML = '<span style="color:red">Wrong Key in the key box. Please delete it and try again</span>';
				throw("bad Key in the key box");	
			};				
		};
	} else {															//main box empty: split secret in the key box
		if (sec==="") {
			keymsg.innerHTML = '<span style="color:red">There is no Key to split in the key box</span>';
			throw("No key in the key box")
		};
		if (learnOn){
			var reply = confirm("The Key in the key box will be split into several partial Keys, which will replace the contents of the main box. A popup will ask for number of parts needed to reconstruct the original Key. Extra parts can be made by clicking Split/Join again. Cancel if this is not what you want.");
			if(reply===false) throw("SSSS split canceled");
		};
		if (document.partsIn.text.value.trim() == ""){					//stop to display the entry form if it is empty
			document.getElementById("partsIn").style.display = "block";
			document.getElementById("shadow").style.display = "block";			
			throw ("stopped for # of parts input")				
		}	
		var quorum = document.partsIn.text.value;						//on re-execution, read the box and reset it
		document.partsIn.text.value = "";
		quorum = parseInt(quorum);
		if(quorum < 2){quorum = 2} else if(quorum > 255) {quorum = 255};
		var	sechex = sjcl.codec.hex.fromBits(sjcl.codec.utf8String.toBits(document.key.text.value)),
			shares = secrets.share(sechex,quorum,quorum);
		displayshare(shares,quorum);
		message.innerHTML = '<span style>' + quorum + ' Key parts in main box</span>';
	};
	document.getElementById("partsIn").style.display = "none";
	document.getElementById("shadow").style.display = "none"
};

function displayshare(shares,quorum){
	var length = shares[0].length,
		quorumst = "00" + quorum;
		quorumst = quorumst.substr(quorumst.length-3);
	if (document.getElementById("notags").checked === false){	
		var	output = "PL15p" + quorumst + "=" + sjcl.codec.base64.fromBits(sjcl.codec.hex.toBits(shares[0].slice(1,length))).replace(/=+/g, '') + "=PL15p" + quorumst;	//trim final "=" and display with tags
	}else{
		var	output = sjcl.codec.base64.fromBits(sjcl.codec.hex.toBits(shares[0].slice(1,length))).replace(/=+/g, '')
	}
	for (var i=1; i < shares.length; i++) {
		if (document.getElementById("notags").checked === false){
			output = output + "\n\n" + "PL15p" + quorumst + "=" + sjcl.codec.base64.fromBits(sjcl.codec.hex.toBits(shares[i].slice(1,length))).replace(/=+/g, '') + "=PL15p" + quorumst;	//strip initial "8" and display each share in a new line, base 64, with tags
		}else{
			output = output + "\n\n" + sjcl.codec.base64.fromBits(sjcl.codec.hex.toBits(shares[i].slice(1,length))).replace(/=+/g, '')
		}
	};	
	document.plain.text.value = output;
};

//The following code is to convert the contents of main box into fake text, and backward. This can be useful against email scanners.

if (typeof code == 'undefined'){			//default text for base64 to words conversion, global variable
	var covertext = "The licenses for most software and other practical works are designed to take away your freedom to share and change the works. By contrast, the GNU General Public License is intended to guarantee your freedom to share and change all versions of a program to make sure it remains free software for all its users. We, the Free Software Foundation, use the GNU General Public License for most of our software; it applies also to any other work released this way by its authors. You can apply it to your programs, too. When we speak of free software, we are referring to freedom, not price. Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for them if you wish), that you receive source code or can get it if you want it, that you can change the software or use pieces of it in new free programs, and that you know you can do these things. To protect your rights, we need to prevent others from denying you these rights or asking you to surrender the rights. Therefore, you have certain responsibilities if you distribute copies of the software, or if you modify it: responsibilities to respect the freedom of others. For example, if you distribute copies of such a program, whether gratis or for a fee, you must pass on to the recipients the same freedoms that you received. You must make sure that they, too, receive or can get the source code. And you must show them these terms so they know their rights. Developers that use the GNU GPL protect your rights with two steps: (1) assert copyright on the software, and (2) offer you this License giving you legal permission to copy, distribute and or modify it. For the developers' and authors' protection, the GPL clearly explains that there is no warranty for this free software. For both users' and authors' sake, the GPL requires that modified versions be marked as changed, so that their problems will not be attributed erroneously to authors of previous versions.";
		covertext = covertext.replace(/   +/g, "\t").replace(/  +/g, " ").replace(/\n /g,"\n\t");		//remove multiple spaces, space after linefeed
	var code = covertext.toLowerCase().replace(/[\.,-\/#!$%\^&\*;:{}=\-_`~()'"]|_/g, "").replace(/\s+/g, " ").split(" ");
		code = code.filter(function(n){return n});													//remove nulls
		code = code.filter(function(elem, pos, self) {return self.indexOf(elem) == pos;});			//global array containing the words, no duplicates
	var keystr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=!@#-" + "\n",	//base64 plus other characters used in PassLok strings
		remainder = code.length % keystr.length,
		noptions = Math.floor(code.length / keystr.length);
}

//This function checks for words or spaces encoding and calls the approrpiate decoders. If no encoding is detected, it calls the words encoder
function words(){
	var extramsg = document.getElementById("extramsg");
		extramsg.innerHTML = "";
	if(document.extra.text.value.match(/  +/g) != null) {								//detect double spaces and if there are any invoke spaces decoder
		fromSpaces()	
	}else{
		var text = document.extra.text.value;				//get rid of null characters, if any
		if(text.trim() == ""){
			extramsg.innerHTML = '<span style="color:red">No text in the box</span>';
			throw("no text")
		}
		var	textlow = text.toLowerCase().replace(/[,\.]+/g,'').replace(/\n+/g,' '),		//make lowercase and strip periods, commas and newlines
			textvector = textlow.split(" "),											//break up the main box into an array of words
			inwords = true,
			indices = new Array();
		for (var i = 0; i < textvector.length; i++){									//find the words in the covertext
			var index = searchStringInArray(textvector[i],code);
			indices[i] = index;															//put the indices into an array
			if(index == -1) inwords = false												//if any word is not in the covertext, this was not encoded with Words method
		}
		if (inwords) {																	//if encoded in words, call words decoder
			fromWords(indices);
			extramsg.innerHTML = 'Message extracted from Words encoding'
		} else {																		//otherwise call words encoder
			toWords(text);
			extramsg.innerHTML = 'Message encoded into words of this text. Decoding requires the same Cover text'
		}
	}
}

//this is almost the same as above, but if it doesn't detect encoding present, it calls the spaces encoder instead
function spaces(){
	var extramsg = document.getElementById("extramsg");
		extramsg.innerHTML = "";
	if(document.extra.text.value.match(/  +/g) != null) {								//detect double spaces and if there are any invoke spaces decoder
		fromSpaces()	
	}else{
		var text = document.extra.text.value;				//get rid of null characters, if any
		if(text.trim() == ""){
			extramsg.innerHTML = '<span style="color:red">No text in the box</span>';
			throw("no text");
		}
		var	textlow = text.toLowerCase().replace(/[,\.]+/g,'').replace(/\n+/g,' '),		//make lowercase and strip periods, commas and newlines
			textvector = textlow.split(" "),											//break up the main box into an array of words
			inwords = true,
			indices = new Array();
		for (var i = 0; i < textvector.length; i++){									//find the words in the covertext
			var index = searchStringInArray(textvector[i],code);
			indices[i] = index;															//put the indices into an array
			if(index == -1) inwords = false												//if any word is not in the covertext, this was not encoded with Words method
		}
		if (inwords) {																	//if encoded in words, call words decoder
			fromWords(indices);
			extramsg.innerHTML = 'Message extracted from Spaces encoding'
		} else {																		//otherwise call spaces encoder
			toSpaces();
			if(extramsg.innerHTML=="") extramsg.innerHTML = 'Message encoded into spaces of this text. Decoding does not require the same Cover text'
		}
	}
}

//the following two are to encode or decode each character of the main box into a word from the covertext
function toWords(text){
	var extramsg = document.getElementById("extramsg");
		extramsg.innerHTML = "";
	if (document.getElementById("learnmode").checked === true){
			var reply = confirm("The contents of the main box will be replaced with fake text representing it. Cancel if this is not what you want.");
			if(reply===false) throw("toWords canceled");
	}
		var output = code[randomindex(keystr.indexOf(text[0]))];
		for (var i = 1; i < text.length; i++){
			var index = keystr.indexOf(text[i]);
			if(index == -1){
				extramsg.innerHTML = '<span style="color:red">This text contains illegal characters for a PassLok string</span>'; 
				throw("illegal characters in the main box")
			}
			output = output + randompunct() + code[randomindex(index)]		//add some random commas and periods, and spaces between words
		}
		output = output.replace(/[.][\s\n][a-z]/g,function(a){return a.toUpperCase();}).replace(/[a-z]/,function(a){return a.toUpperCase();}) + "."; //capitalize initial and after period, add final period.
		document.extra.text.value = output
}

function fromWords(indices){
	if (document.getElementById("learnmode").checked === true){
		var reply = confirm("The fake text in the main box will be replaced with the original code from which it came. Cancel if this is not what you want.");
		if(reply===false) throw("fromWords canceled");
	}
		var output = "";
		for (var i = 0; i < indices.length; i++){
			output = output + keystr[indices[i] % keystr.length]
		}
		document.extra.text.value = output		
}

//Computes an index taking the full range of words in the covertext
function randomindex(index){
	if(index >= remainder){
		var choice = Math.floor(Math.random() * noptions)
	}else{
		var choice = Math.floor(Math.random() * (noptions + 1))
	}
	return index + choice*keystr.length
}

//To find words in the code. Returns the index if found, or -1 if not found
function searchStringInArray (str, strArray) {
    for (var j = 0; j < strArray.length; j++) {
        if (strArray[j] == str) return j;
    }
    return -1;
}

//This is to generate random periods, commans and newlines, per the percentage brackets below, plus spaces when appropriate
function randompunct(){
	var percent = Math.ceil(Math.random() * 100);
	if (percent < 7) {
		return ". "
	} else if(percent < 13) {
		return ", "
	} else if(percent < 15) {
		return ".\n"	
	} else {
		return " "
	}
}

//the following functions are to hide text into a text cover, as binary double spaces. It needs 7 cover words for each ASCII characters, 42 for non-ASCII
function encoder(bin){
	var textsplit = covertext.split(" ");
	var spaces = textsplit.length - 1;
	var missing = bin.length - spaces;
	var iter = 0;
	if (spaces < bin.length){
		while (spaces < bin.length){
			textsplit = textsplit.concat(covertext.split(" "));
			spaces = textsplit.length - 1;
			iter = iter + 1
		}
		extramsg.innerHTML = '<span style="color:red">The cover text was too short. It was repeated ' + iter + ' times. If this is not acceptable, repeat with a larger cover.</span>'; 
	}
		textsplit = textsplit.slice(0,bin.length+2);
	var newtext = textsplit[0];
	for(var i=0; i < textsplit.length-1; i++){
		newtext = newtext + stegospace(bin.slice(i,i+1)) + textsplit[i+1]
	}
	return newtext
}

function decoder(text){
	var bin = "";
	var textsplit = text.split(" ");
	for(var i=1; i < textsplit.length-1; i++){
		if (textsplit[i] == ""){
			bin = bin + "1";
			i = i + 1			//skip next word
		}else{
			bin = bin + "0"
		}
	}
	return bin
}

function stegospace(bin){
	if(bin == "1"){
		return "  "		//double space
	}else{
		return " "		//regular space
	}
}

function toSpaces() {
	var extramsg = document.getElementById("extramsg");
		extramsg.innerHTML = "";
	if (document.getElementById("learnmode").checked === true){
		var reply = confirm("The contents of the main box will be replaced with fake text representing it. Cancel if this is not what you want.");
		if(reply===false) throw("toSpaces canceled");
	}	
  var output=""; 
	var input = document.extra.text.value.trim();
    for (var i=0; i < input.length; i++) {
		if(keystr.indexOf(input[i]) == -1){
			extramsg.innerHTML = '<span style="color:red">This text contains illegal characters for a PassLok string</span>'; 			
			throw("illegal characters in the main box")
		}
		var bin = "000" + input[i].charCodeAt(0).toString(2);
        output = output + bin.slice(bin.length-7,bin.length);
    }
	document.extra.text.value = encoder(output)
}

function fromSpaces() {
	if (document.getElementById("learnmode").checked === true){
		var reply = confirm("The fake text in the main box will be replaced with the original code from which it came. Cancel if this is not what you want.");
		if(reply===false) throw("fromWords canceled");
	}	
	var output=""; 
	var input=decoder(document.extra.text.value);
    for (var i=0; i < input.length; i=i+7) {
		var bin = input.slice(i,i+7);
        output = output + String.fromCharCode(parseInt(bin,2));
    }
	document.extra.text.value = output.replace(/\x00/g,'')		//take out nulls, in case text was added to finish the last sentence.
}

//this one is to display the cover text or change it as requested
function newcover(){
	var extramsg = document.getElementById("extramsg");
		extramsg.innerHTML = "";
	if(document.extra.text.value.trim() == ""){										//if the box is empty display the cover text
		if (document.getElementById("learnmode").checked === true){
			var reply = confirm("The cover text will be displayed in the main box. Cancel if this is not what you want.");
			if(reply==false) throw("covertext display canceled");
		}	
		document.extra.text.value = covertext
	}else{																			//otherwise store new cover text
		if (document.getElementById("learnmode").checked === true){
			var reply = confirm("If you go ahead, the cover text will be replaced with the contents of this box, which will be deleted.");
			if(reply==false) throw("covertext change canceled");
		}	
		var newcovertext = document.extra.text.value.replace(/   +/g, "\t").replace(/  +/g, " ").replace(/\n /g,"\n\t");				//remove multiple spaces, spaces after linefeed
		if (newcovertext.match(/[\u3400-\u9FBF]/) != null) newcovertext = newcovertext.split('').join(' ').replace(/  +/g, ' ');		//add spaces if Chinese, Korean, or Japanese
		var	newcode = newcovertext.toLowerCase().replace(/[\.,-\/#!$%\^&\*;:{}=\-_`~()'"]|_/g, "").replace(/\s+/g, " ").split(" ");  	//removes punctuation, collapses spaces to single space
			newcode = newcode.filter(function(n){return n});																			//remove nulls
			newcode = newcode.filter(function(elem, pos, self) {return self.indexOf(elem) == pos;});									//remove repeats
		if (newcode.length >= keystr.length){										//enough length for words method
			code = newcode;															//store into global variables
			covertext = newcovertext;			
			remainder = code.length % keystr.length;
			noptions = Math.floor(code.length / keystr.length);
			document.extra.text.value = "";
			extramsg.innerHTML = 'Cover text changed'
		} else {
			extramsg.innerHTML = '<span style="color:red">This text is too short for a Cover</span>';
			throw("text sample too short");
		}	
	}
}      

//these are for switching between windows
function plain2extra(){
	openClose("main");
	openClose("extrascr");
	if(document.plain.text.value.trim() != "") document.extra.text.value = document.plain.text.value
}
function extra2plain(){
	openClose("main");
	openClose("extrascr");
	if((document.extra.text.value.trim() != "") && (document.extra.text.value.split("-").length != 16)) document.plain.text.value = document.extra.text.value
}
function plain2key(){
	openClose("keyscr");
	openClose("main")
}

//resizes text boxes so they fit within the window
function textrows(){
	if(isiPad){												//first for iPad. Don't know how to detect other tablets
		if((angle==90)||(angle==-90)){
			document.plain.text.rows=document.documentElement.clientHeight/rowheight-11					//landscape
		}else{document.plain.text.rows=document.documentElement.clientHeight/rowheight*1.2-11}			//portrait
	}else{
		if((angle==90)||(angle==-90)){
			document.plain.text.rows=document.documentElement.clientHeight/rowheight*0.9-11				//smartphone here and line below
		}else if(typeof window.orientation != 'undefined') {document.plain.text.rows=document.documentElement.clientHeight/rowheight*1.25-11
		}else{document.plain.text.rows=document.documentElement.clientHeight/rowheight*1.2-10}}			//non-mobile
	if(document.extra!=null) document.extra.text.rows = document.plain.text.rows	
}

<!-- Text hide trick, by Sandeep Gangadharan 2005-->
if (document.getElementById) {
 document.writeln('<style type="text/css"><!--')
 document.writeln('.texter {display:none} @media print {.texter {display:block;}}')
 document.writeln('//--></style>') }

function openClose(theID) {
 if (document.getElementById(theID).style.display === "block") { document.getElementById(theID).style.display = "none" }
 else { document.getElementById(theID).style.display = "block" } };
// end of hide trick

//The main script ends here.
</script>
		
</head>
  
<body link="#0000ff" vlink="#0000ff" alink="#0000ff" onload="ce();">
  
<div id="main" class="texter" style="display: block;">
  <div align="center" ontouchmove="event.preventDefault();">
  	<form name="warning" action="#" onsubmit="return false;">
		<input type="text" name="warning" style="background-color: #FFB0B0; color: #000000;width: 60%; font-size: large; text-align: center" value="Javascript NOT working!" class="ctr" readonly="readonly" />
	</form>
	<br />
<script type="text/javascript" language="JavaScript">
	sjcl.random.startCollectors();		//start SJCL's built-in entropy collectors
<!--
    //  Clear out "sorry, no JavaScript" message from text box.
    document.warning.warning.value = "PassLok Privacy";
    document.warning.warning.style.backgroundColor = "rgb(235, 255, 235)";
// -->
</script>
	<span id="mainmsg"></span><br />
	<input type="button" onclick = "openClose('mainhelp');openClose('main');" onBlur="ce();" onFocus="ce();" value="Help" style="font-size:medium"/>
    <input type="button" onclick = "openClose('keyscr');openClose('main');" onBlur="ce();" onFocus="ce();" value="Key" style="font-size:medium"/>
	<input type="button" onClick="selectPlain();" onBlur="ce();" onFocus="ce();" value="Select" style="font-size:medium">
	<input type="button" onClick="document.plain.text.value = '';" onBlur="ce();" onFocus="ce();" value="Clear" style="font-size:medium">
    </div>
    <div align="center">
    	<form onSubmit="return false;" id="plain" name="plain">      
    		<textarea onKeyDown="ce();" onKeyUp="document.getElementById('mainmsg').innerHTML=''" onBlur="ce();" onFocus="ce();" style="background-color: rgb(255, 255, 240); color: #000000; width: 98%; font-size: medium" name="text" rows="13" placeholder="The text to be locked, unlocked, or signed goes here.   Usually, the first thing would be to click the Key button above, and enter a Key or a Lock."></textarea>
<script>		
	var rowheight = document.warning.clientHeight*0.7,						//get title size in pixels, for number of rows calculation. global variables
		isiPad = (navigator.userAgent.match(/iPad/i) != null),
		angle = window.orientation;
	textrows();
	window.addEventListener("resize", function() { textrows() }, false)	    //resize if the window changes		
</script>
    	</form>
    </div>
	<div align="center" ontouchmove="event.preventDefault();">
    	<input type="button" onClick="Decrypt_text();" onBlur="ce();" onFocus="ce();" value="Lock/Unlock" name="decrypt" style="font-size:medium">
		<input type="button" onClick="Verifyhash();" onBlur="ce();" onFocus="ce();" value="Sign/Ver." style="font-size:medium">
    	<input type="button" onclick = "plain2extra();" onBlur="ce();" onFocus="ce();" value="More" style="font-size:medium"/><br /><br />
    	<input type="checkbox" id="shortmode" onBlur="ce();" onFocus="ce();"/> Short mode
    	<input type="checkbox" id="notags" onBlur="ce();" onFocus="ce();"/> No tags <input type="checkbox" id="decoymode" onBlur="ce();" onFocus="ce();"/> Decoy mode
	</div> 
</div> 

<div id="keyscr" class="texter" style="display: none;">
  	<div align="center" ontouchmove="event.preventDefault();">
    	<input type="button" onclick = "openClose('main');openClose('keyscr');" value="< Back" style="float:left;font-size:medium;"/>
        <input type="button" onclick = "openClose('keyhelp');openClose('keyscr');" onBlur="ce();" onFocus="ce();" value="Help" style="font-size:medium"/>
    	<input type="button" onClick="passwordChanged();document.key.text.value = ''" onBlur="ce();" onFocus="ce();" value="Clear" style="float: right;font-size:medium"/>
    </div><br />
    <div align="center" ontouchmove="event.preventDefault();">        
    	<form onsubmit="return false;" id="key" name="key">
      		<span id="keymsg"></span><br />
			<input type="password" autocomplete="off" id="pwd" onKeyDown="ce();" onKeyUp="return passwordChanged();" onBlur="ce();" onFocus="ce();" style="background-color: rgb(255, 255, 240); color: #000000; width: 98%; font-size: medium" name="text" placeholder="Secret Key or public Lock goes here." align="center"><br />
        </form>
    </div>
    <div align="center" ontouchmove="event.preventDefault();">
		<input type="checkbox" id="show" onClick="showsec();" onBlur="ce();" onFocus="ce();" style="font-size:medium"> Show 
        <input type="button" onclick="fillkeys();" onBlur="ce();" onFocus="ce();" value="Make Lock" style="font-size:medium"/>
        <input type="button" onclick="secretshare();" onBlur="ce();" onFocus="ce();" value="Splt/Join" style="font-size:medium"/>
	</div>
    <div align="left">        
      	<p>Write your personal or shared Key, or the recipient's or signer's Lock in this box. To display the characters, check Show. As you type your Key, a text above it will tell you the strength of the Key based on simple rules. Make sure to <strong>use $ymbol$, numb3rs, caPiTals, unusual words and mispelingss.</strong> Initial capitals and numbers at start and end are not helpful and will be ignored for the strength score.</p>
        <p>If your Key strength is worse than Medium, <strong>PassLok will be very slow.</strong></p>
    </div>
</div>  
        
<div id="extrascr" class="texter" style="display: none;" align="center">
	<div align="center" ontouchmove="event.preventDefault();">
       <input type="button" onclick = "extra2plain();" value="< Back" style="float: left;font-size:medium;"/>
       <input type="button" onclick = "openClose('extrahelp');openClose('extrascr');" onBlur="ce();" onFocus="ce();" value="Help" style="font-size:medium"/>
       <input type="button" onClick="document.extra.text.value = '';" onBlur="ce();" onFocus="ce();" value="Clear" style="float: right; font-size:medium;"/><br /><br />
    </div>   
    <div align="center" ontouchmove="event.preventDefault();">
		<span id="extramsg"></span><br />
		<input type="button" onClick="sendMail();" onBlur="ce();" onFocus="ce();" value="Email" style="font-size:medium"/>
        <input type="button" onClick="sendSMS();" onBlur="ce();" onFocus="ce();" value="SMS" style="font-size:medium"/>
		<input type="button" onClick="makehash();" onBlur="ce();" onFocus="ce();" value="ID" style="font-size:medium"/>
		<input type="button" onClick="selectExtra();" onBlur="ce();" onFocus="ce();" value="Select" style="font-size:medium">
	</div>
	<div align="center">
      	<form onSubmit="return false;" id="extra" name="extra">     
			<textarea onKeyDown="ce();" onKeyUp="document.getElementById('extramsg').innerHTML=''" onBlur="ce();" onFocus="ce();" style="background-color: rgb(255, 255, 240); color: #000000; width: 98%; font-size: medium" name="text" rows="13" placeholder="The text to be locked, unlocked, or signed goes here.   Usually, the first thing would be to click the Key button above, and enter a Key or a Lock."></textarea>
<script>
	textrows();
	window.addEventListener("resize", function() { textrows() }, false)	
</script>
    	</form>
    </div>
    <div align="center" ontouchmove="event.preventDefault();">
    	<input type="button" onClick="words();" onBlur="ce();" onFocus="ce();" value="Words" style="font-size:medium"/>
		<input type="button" onClick="spaces();" onBlur="ce();" onFocus="ce();" value="Spaces" style="font-size:medium"/>
    	<input type="button" onClick="newcover();" onBlur="ce();" onFocus="ce();" value="Cover" style="font-size:medium"/><br /><br /></div>
    </div>
</div>           
        
<div id="shadow" class="black_overlay"></div>
       
<div id="decoyIn" class="white_content" align="center" ontouchmove="event.preventDefault();">
	<form onSubmit="return false;" name="decoyIn">
		<p>Enter Decoy Password</p> 
    	<input type="password" onKeyDown="ce();" onBlur="ce();" onFocus="ce();" style="background-color: rgb(255, 255, 240); color: #000000; width: 98%; font-size: medium" name="key"/>
		<p>Enter Hidden Message</p>      
		<textarea onKeyDown="ce();" onBlur="ce();" onFocus="ce();" style="background-color: rgb(255, 255, 240); color: #000000; width: 98%; font-size: medium" name="text" rows="3"></textarea>
    	<input type="button" onClick="closebox();if(encrypting){Decrypt_text()}else{Verifyhash()};" onBlur="ce();" onFocus="ce();" value="OK" style="font-size:medium"/>
		<input type="button" onClick="closebox();" onBlur="ce();" onFocus="ce();" value="Cancel" style="font-size:medium"/>
	</form>   
</div>
       
<div id="decoyOut" class="white_content" align="center" ontouchmove="event.preventDefault();">
	<form onSubmit="return false;" name="decoyOut">
		<p>Enter Decoy Password</p> 
    	<input type="password" onKeyDown="ce();" onBlur="ce();" onFocus="ce();" style="background-color: rgb(255, 255, 240); color: #000000; width: 98%; font-size: medium" name="key"/>     
    	<input type="button" onClick="closebox();if(encrypting){Decrypt_text()}else{Verifyhash()};" onBlur="ce();" onFocus="ce();" value="OK" style="font-size:medium"/>
		<input type="button" onClick="closebox();" onBlur="ce();" onFocus="ce();" value="Cancel" style="font-size:medium"/>
    	<p>The Hidden message will appear in the main window</p>
    </form>   
</div>
    
<div id="partsIn" class="white_content" align="center" ontouchmove="event.preventDefault();">
	<form onSubmit="return false;" name="partsIn">
		<p>Enter the number of parts needed to retrieve the Key (between 2 and 255)</p> 
    	<input type="text" onKeyDown="ce();" onBlur="ce();" onFocus="ce();" style="background-color: rgb(255, 255, 240); color: #000000; width: 30%; font-size: medium" name="text" rows="1"/><br />    
    	<input type="button" onClick="closebox();secretshare();" onBlur="ce();" onFocus="ce();" value="OK" style="font-size:medium"/>
		<input type="button" onClick="closebox();" onBlur="ce();" onFocus="ce();" value="Cancel" style="font-size:medium"/>
	</form>
</div>

<div id="mainhelp" class="texter" style="display: none;">
 	<input type="button" onclick = "openClose('main');openClose('mainhelp');" value="< Back" style="font-size:medium"/>
    <p>To get information on every button as you press it, check this box: <strong> Learn Mode <input type="checkbox" id="learnmode" onBlur="ce();" onFocus="ce();" style="font-size:medium"/></strong></p>    
	<p>For instructions on how to do things, click on each title below. Click again to hide.</p>
    <hr style="background-color: rgb(192, 192, 192); color: #000000;">
    
    <div onClick="openClose('a1')" style="cursor:hand; cursor:pointer">
<h3>Lock a message with a shared Key, to be unlocked with the same Key</h3>  
</div>
      <div id="a1" class="texter" style="display: none;">
<p>1. Write or paste the shared Key in the key box, which is accessed with the Key button. It is masked by default, so
  if you want to display it, check the Show checkbox.</p>
<p>2. Write or paste the message in the main box. Click the Lock/Unlock button. The
  locked message will appear in the main box, replacing the original text. Copy it and paste it into your
  communications program or click Email to open your default email. 
  It is okay to strip the tags up to the "=" sign, but not recommended. 
  PassLok will do this automatically if the No tags checkbox is checked prior to locking. It is
  also okay to split the locked message with spaces, line returns, and
  punctuation other than = + or / This message can only be unlocked by
  someone having the shared Key.</p>
  <p>All of this is explained in this video tutorial:<a href="https://www.youtube.com/watch?v=y6sk7I7YR0I" target="_blank">https://www.youtube.com/watch?v=y6sk7I7YR0I</a></p></div>
  <hr style="background-color: rgb(192, 192, 192); color: #000000;">	
  
  <div onClick="openClose('a2')" style="cursor:hand; cursor:pointer">
 <h3>Unlock a message locked with a shared Key (tags are PL**msk)</h3>
</div>
      <div id="a2" class="texter" style="display: none;">
<p>1. Write or paste the shared Key in the key box, which is accessed with the Key button. It is masked by default, so
  if you want to display it, check the Show checkbox.</p>
<p>2. Paste the locked message in the main box. It is okay if it is broken up by
  spaces, carriage returns, and special characters other than = + or / or is
  missing its tags. Then click the Lock/Unlock button. The unlocked message
  will appear in the main box, replacing the locked message.</p>
  <p>All of this is explained in this video tutorial:<a href="https://www.youtube.com/watch?v=y6sk7I7YR0I" target="_blank">https://www.youtube.com/watch?v=y6sk7I7YR0I</a></p></div>
  <hr style="background-color: rgb(192, 192, 192); color: #000000;">	
  
  <div onClick="openClose('a3')" style="cursor:hand; cursor:pointer">
<h3>Lock a message with a Lock  (tags are PL**lok), to be unlocked with the matching
  personal Key</h3>
</div>
  <div id="a3" class="texter" style="display: none;">
 <p>1. Fetch the recipient's Lock. He/she would have sent it accompanying an email, or in
 and SMS text message, or posted it publicly. You can tell it is a Lock because it comprises 87 random-looking characters, likely 
 with PL**lok tags at either end (** is the version number). You need this Lock before you can do anything else.</p> 
<p>2. Paste the recipient's Lock in the key box, which is accessed with the Key button. It is masked by default, so if you want to display it, check the
  Show checkbox. It is okay if the tags up to the "=" signs
  are missing, or extra spaces, carriage returns, or special characters
  other than = + or / have been added.</p>
<p>3. Write or paste your message in the main box. Click the Lock/Unlock button. The
  locked message will appear in the main box, replacing the original message. Copy it and paste it into your
  communications program or click Email to open your default email. 
  It is okay to strip the tags up to the "=" sign, but not recommended. 
  PassLok will do this automatically if the No tags checkbox is checked prior to locking. It is
  also okay to split the locked message with spaces, line returns, and
  punctuation other than = + or / This message can only be unlocked by
  someone having the secret Key matching the Lock used to secure it.</p>
  <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=NqwnQY4O5MA" target="_blank">https://www.youtube.com/watch?v=NqwnQY4O5MA</a></p></div>
  <hr style="background-color: rgb(192, 192, 192); color: #000000;">	
  
  <div onClick="openClose('a4')" style="cursor:hand; cursor:pointer">
<h3>Unlock a locked message with the matching personal Key (tags
  are PL**msl)</h3>
  </div>
  <div id="a4" class="texter" style="display: none;">
<p>1. Write or paste into the key box, which is accessed with the Key button, the Key matching the Lock used to secure the
  message. It is masked by default, so if you want to display it, check the
  Show checkbox.</p>
<p>2. Paste the locked message in the main box. It is okay if it is broken up by
  spaces, carriage returns, and special characters other than = + or / or is
  missing its tags. Then click the Lock/Unlock button. The unlocked message
  will appear in the main box, replacing the locked message.</p>
  <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=NqwnQY4O5MA" target="_blank">https://www.youtube.com/watch?v=NqwnQY4O5MA</a></p></div>
  <hr style="background-color: rgb(192, 192, 192); color: #000000;">	
 
  <div onClick="openClose('a5')" style="cursor:hand; cursor:pointer">
<h3>Make a short locked message suitable for SMS</h3>
</div>
<div id="a5" class="texter" style="display: none;">
<p>1. Check the Short mode checkbox below the main box.</p>
<p>2. Write or paste your message in the main box. Message length is limited to 58
  ASCII characters when locking with a Key, 38 if locking with a Lock. Non-ASCII characters use 6 spaces each, so avoid them if
  you can. Any text beyond the limit will be lost. Click the Lock/Unlock button.</p>
<p>3. The locked message will appear in the main box, replacing the original message. Copy it and paste it into your communications program. The locked
  message, which has no tags, will fit within one SMS message (160
  characters). </p>
<p>4. On a mobile device, the locked message will be selected and ready to be copied into the clipboard. You need to copy it manually before clicking the SMS button, which will open your SMS app.</p>
  <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=7d2nhjCgo3E" target="_blank">https://www.youtube.com/watch?v=7d2nhjCgo3E</a></p></div>
  <hr style="background-color: rgb(192, 192, 192); color: #000000;">	
  
  <div onClick="openClose('a6')" style="cursor:hand; cursor:pointer">
<h3>Unlock a short locked message (no tags)</h3>
  </div>
  <div id="a6" class="texter" style="display: none;">
<p>1. Paste the locked message in the main box. It is okay if it is broken up by
  spaces, carriage returns, and special characters. As with regular-length messages, the appropriate Key must be entered in the key box prior to unlocking. 
  Then click the Lock/Unlock button. You don't need to check the Short mode checkbox.</p>
<p>2. The unlocked message will appear in the main box, replacing the locked message.</p>
  <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=7d2nhjCgo3E" target="_blank">https://www.youtube.com/watch?v=7d2nhjCgo3E</a></p></div>
  <hr style="background-color: rgb(192, 192, 192); color: #000000;">	 
  
  <div onClick="openClose('a7')" style="cursor:hand; cursor:pointer">
<h3>Sign a text with a secret Key</h3>
</div>
<div id="a7" class="texter" style="display: none;">
<p>1. Write or paste your secret Key in the key box, which is accessed with the Key button. It is masked by default, so
  if you want to display it, check the Show checkbox.</p>
<p>2. Write or paste the text to be signed in the main box. Click the signature/Verify
  button. A sign matching the text and the Key will be appended at the end of the text in the main box. Copy
  it and use it as appropriate. If you click Email the text with its signature
  will be placed into an email using the default program.
  It is okay to strip the tags up to the "="
  sign, but not recommended. PassLok will do this automatically if the No tags checkbox is checked prior to locking. 
  It is also okay to split the signature with spaces,
  and punctuation other than line returns or = + or /. </p>
  <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=7RP8Nc2jU8U" target="_blank">https://www.youtube.com/watch?v=7RP8Nc2jU8U</a></p></div>
  <hr style="background-color: rgb(192, 192, 192); color: #000000;">  
  
  <div onClick="openClose('a8')" style="cursor:hand; cursor:pointer">
<h3>Verify a signature attached to a text (signature tags are PL**sig) </h3>
</div>
<div id="a8" class="texter" style="display: none;">
<p>1. Paste the lock of the person who made the signature into the key box, which is accessed with the Key button. It is okay
  if the tags up to the "=" signs are missing, or extra spaces, carriage
  returns, or special characters other than = + or / have been added.</p>
<p>2. Write or paste the text with its signature appended at the end in the main box. It is okay if 
  the signature is broken up by spaces and special characters other than = + or / or is missing
  its tags up to the "=", but it should not be broken by carriage returns.
  Then click the signature/Verify button. A message above the main box will say whether
  or not the signature for that text has been verified.</p>
  <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=7RP8Nc2jU8U" target="_blank">https://www.youtube.com/watch?v=7RP8Nc2jU8U</a></p></div>
    <hr style="background-color: rgb(192, 192, 192); color: #000000;">
  
  <div onClick="openClose('a9')" style="cursor:hand; cursor:pointer">
<h3>Lock a second, undetectable message in addition to the main message
  (Decoy mode)</h3>
  </div>
  <div id="a9" class="texter" style="display: none;">
<p>1. Check the Decoy mode checkbox below the main box.</p>
<p>2. Follow the instructions for any kind of locking, using
  a shared Key or the recipient's Lock, short or regular length. This also works when making a signature. If Decoy mode is checked, a popup will ask for a Decoy Password to lock the hidden message, and the hidden message itself.</p>
<p>3. Write or paste into the the appropriate boxes the Password and the hidden message. The length of the hidden message is limited to
  152 ASCII characters in key-locked and signed modes, 87 characters in
  regular locked mode, 37 characters in short message mode (key-locked only), 40 characters in signatures. Non-ASCII characters
  use 6 spaces each, so avoid them if you can. Any text beyond the limit will be lost. Then click OK.</p>
<p>4. After clicking OK, the locked
  message containing both the main text and the hidden text will appear in
  the main box, replacing the original text. If it is a signature, it will be appended to the text. Copy it and paste it into your
  communications program. As with regular locked messages, it is okay to
  strip the tags up to the "=" sign, but not recommended. It is also okay to
  split the locked message with spaces, line returns, and punctuation other
  than = + or /</p>
  <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=XPwilrxhXG0" target="_blank">https://www.youtube.com/watch?v=XPwilrxhXG0</a></p></div>
  <hr style="background-color: rgb(192, 192, 192); color: #000000;">	
  
  <div onClick="openClose('a10')" style="cursor:hand; cursor:pointer">
<h3>Reveal the hidden text contained within a message locked in Decoy
  mode</h3>
  </div>
  <div id="a10" class="texter" style="display: none;">
<p>1. Check the Decoy mode checkbox below the main box.</p>
<p>2. Follow the instructions for any of the three locking modes, using a
  personal or shared Key, or for verifying a signature. If Decoy mode is
  checked, a popup will ask for a Decoy Password.</p>
<p>3. Write or paste into the popup box the special Password for the hidden
  message and click OK. The hidden message, if it exists,
  will appear above the main box even if the main unlocking fails. The main message
  will appear in the main box if the main unlocking is successful. In the case of signatures, the hidden message appears in the place normally used by the verification message, so if you still wish to verify the signature, you need to uncheck Decoy Mode and click Sign/Verify again so the verification message is displayed.</p>
  <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=XPwilrxhXG0" target="_blank">https://www.youtube.com/watch?v=XPwilrxhXG0</a></p></div>
  <hr style="background-color: rgb(192, 192, 192); color: #000000;">

	<address>PASSLOK v1.5.03 &#169; <a href="http://prgomez.com/" target="_blank">F. Ruiz</a> 2013
	</address>
	<address>
	engine: SJCL by <a href="http://crypto.stanford.edu/sjcl" target="_blank">Stark, Hamburg, and Boneh</a> 2012
	</address>
    <address>
    text hide trick by <a href="http://www.sivamdesign.com/scripts/" target="_blank">S. Gangadharan</a> 2005
    </address>
	<address>
    password strength meter by <a href="http://www.marketingtechblog.com/javascript-password-strength/" target="_blank">D. Karr</a> 2007
    </address>
	<address>
    Shamir secret sharing by <a href="https://github.com/amper5and/secrets.js" target="_blank">A. Stetsyuk</a> 2013
    </address>
    <address>
    text compression by <a href="https://code.google.com/p/u-lzss/" target="_blank">U-LZSS</a> 2008
    </address>
    <address>This document may be used, modified or redistributed under GNU GPL license, version 3.0 or higher.</address>
    <hr style="background-color: rgb(192, 192, 192); color: #000000;"> 
    
  <input type="button" onclick = "openClose('main');openClose('mainhelp');" value="< Back" style="font-size:medium"/>
</div>

<div id="keyhelp" class="texter" style="display: none;">
	<input type="button" onclick = "openClose('keyscr');openClose('keyhelp');" value="< Back" style="font-size:medium"/>
     <hr style="background-color: rgb(192, 192, 192); color: #000000;">
      <div onClick="openClose('a11')" style="cursor:hand; cursor:pointer">
<h3>Make a strong Key</h3>
</div>
	<div id="a11" class="texter" style="display: none;">
<p>1. Start typing in the key box, which is accessed with the Key button. As you type, a text above the key box will tell you
  how strong the Key is, based on simple rules. If you want to see what you
  are typing and don't mind people peering over your shoulder, check the
  Show checkbox.</p>
<p>2. The Key will be stronger if it contains <strong>caPiTals</strong> in unusual places,
  <strong>numb3rs</strong>, and <strong>$ymbol$</strong>. If you use common words, <strong>mispelll</strong> them to make harder a "dictionary attack." Avoid things that refer to yourself and your family, such
  as birthdays or nicknames, or anything else that might be easy to guess,
  like: asdfg, qwerty, password, PassLok, and the like. It is a good practice to <strong>append
  your email address</strong> at the end of the Key, to combat the "rainbow table" attack. Alternatively, you can use anything that is not a standard dictionary word instead of your email.</p>
<p>3. Bear in mind, however, that you should be able to <strong>remember
  your Key</strong> without having to write it down. PassLok will never
  ask you to change your Key, so this is your chance to make a truly strong Key
  that you will use for a long time.</p>
  <p>PassLok compensates for bad Keys by taking longer to do its computations. If PassLok is slow, this is likely because your Key strength is less than Medium.</p>
  <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=0Wdw_SKLOFk" target="_blank">https://www.youtube.com/watch?v=0Wdw_SKLOFk</a></p></div>
  <hr style="background-color: rgb(192, 192, 192); color: #000000;">	
  
  <div onClick="openClose('a12')" style="cursor:hand; cursor:pointer">
<h3>Make the Lock that matches your Key</h3>
</div>
<div id="a12" class="texter" style="display: none;">
<p>1. Write or paste your secret Key in the key box, which is accessed with the Key button. It is masked by default, so
  if you want to display it, check the Show checkbox.</p>
<p>2. Click the Lock/Unlock button. The lock matching that Key will appear
  in the main box. It is okay to strip the tags up to the "=" sign, or insert
  spaces, carriage returns, or special characters other than = + or / but
  not recommended. PassLok will do this automatically if the No tags checkbox is checked prior to locking. 
  The lock can be made available to anyone who wishes to
  secure messages to be read with the matching Key. You can also email the lock directly 
  by clicking Email.</p>
  <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=_t_O2oeUb_w" target="_blank">https://www.youtube.com/watch?v=_t_O2oeUb_w</a></p></div>
<hr style="background-color: rgb(192, 192, 192); color: #000000;">
  
<div onClick="openClose('a13')" style="cursor:hand; cursor:pointer">
<h3>Combine a secret Key and a Lock, usually for
making a locked and signed message</h3>
</div>
<div id="a13" class="texter" style="display: none;">
<p>1. Write or paste your secret Key in the key box, which is accessed with the Key button. It is masked by default, so
  if you want to display it, check the Show checkbox.</p>
<p>2. Paste the Lock in the main box. Click the Make Lock
  button. The shared Key resulting from the Key and the Lock 
  will appear in the key box, replacing the original Key, and the main box is cleared. 
  This is useful to make or read
  a locked and signed message, since the recipient will need the sender's Lock to
  obtain the Key that unlocks the message, in addition to his/her
  secret Key. Use it as you would use a regular Key.</p>
  <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=nTDUYPyDHgo" target="_blank">https://www.youtube.com/watch?v=nTDUYPyDHgo</a></p></div>
  <hr style="background-color: rgb(192, 192, 192); color: #000000;">
  
<div onClick="openClose('a14')" style="cursor:hand; cursor:pointer">
<h3>Unlock a message locked and signed with the sender's Key (tags are PL**mss)</h3>
</div>
<div id="a14" class="texter" style="display: none;">
<p>1. Write or paste your secret Key in the key box, which is accessed with the Key button. It is masked by default, so
  if you want to display it, check the Show checkbox.</p>
<p>2. Paste the sender's Lock in the main box. Click the Make Lock
  button. The shared Key resulting from the Key and the Lock 
  will appear in the key box, replacing the original Key. A confirming message appears in the main box.</p>
 <p>3. Paste the locked message in the main box. It is okay if it is broken up by
  spaces, carriage returns, and special characters other than = + or / or is
  missing its tags. Then click the Lock/Unlock button. The unlocked message
  will appear in the main box, replacing the locked message.</p>
  <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=nTDUYPyDHgo" target="_blank">https://www.youtube.com/watch?v=nTDUYPyDHgo</a></p></div>
  <hr style="background-color: rgb(192, 192, 192); color: #000000;">
  
<div onClick="openClose('a15')" style="cursor:hand; cursor:pointer">
<h3>Make a set of random Key and its matching Lock</h3>
</div>
<div id="a15" class="texter" style="display: none;">
<p>1. Make sure the key box, which is accessed with the Key button, is empty, then click the Make Lock button below the key box.
If the main box is not empty, a popup message will ask if you want to proceed.</p>
<p>2. A random Key will appear in the key box and its matching Lock in the main box. Use them as needed. 
If you want the Lock to appear without tags, check the No tags checkbox first.</p>
 <p>3. The main use of this function is to generate a short-term Key-Lock pair for
 instant messaging, which can be forgotten afterwards.</p>
 <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=Ceh3zMcn6zg" target="_blank">https://www.youtube.com/watch?v=Ceh3zMcn6zg</a></p></div>
  <hr style="background-color: rgb(192, 192, 192); color: #000000;">
  
  <div onClick="openClose('a16')" style="cursor:hand; cursor:pointer">
<h3>Split a Key into several parts</h3>
</div>
<div id="a16" class="texter" style="display: none;">
<p>1. Make sure the main box is empty, and then click the Key button.</p>
<p>2. Put the Key, which must be at least 5 characters long, in the key box. If you want a new random Key, follow the steps above. Then click the Split/Join button.</p>
<p>3. A popup asks for the number of parts required to retrieve the original. Write the number, which must be between 2 and 255, and click OK. The parts appear in the main box and a message confirms it. If you need more parts (the number required won't change), click Split/Join again for each additional part. Copy the parts one by one and send/store them as needed. It is okay to strip the tags up to the "=" sign, but not recommended. PassLok will do this automatically if the No tags checkbox is checked prior to locking. It is also okay to split the locked message with spaces and punctuation other than = + / or line returns.</p>
<p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=2VTWnN4lZHw" target="_blank">https://www.youtube.com/watch?v=2VTWnN4lZHw</a></p>
  </div>
<hr style="background-color: rgb(192, 192, 192); color: #000000;">	
  
  <div onClick="openClose('a17')" style="cursor:hand; cursor:pointer">
<h3>Join parts of a Key to retrieve the original Key (tags are PL**p***)</h3>
</div>
<div id="a17" class="texter" style="display: none;">
<p>1. Paste all the necessary Key parts in the main box. Make sure that each part is unique and occupies one line, and different parts are in different lines. You need as many parts the number entered when the Key was split, which is written at the end of each PL**p tag. Having more parts than the minimum is OK, so long as they belong to the same set and are not corrupt. They don't need to be placed in any particular order.</p>
<p>2. Click the Key button, and then the Click the Split/Join button. If all goes well, the reconstructed Key appears in the key box, otherwise nothing happens. Likely problems include: insufficient number of parts, incomplete or corrupt parts, parts belonging to different sets.</p>
<p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=2VTWnN4lZHw" target="_blank">https://www.youtube.com/watch?v=2VTWnN4lZHw</a></p>
  </div>
  <hr style="background-color: rgb(192, 192, 192); color: #000000;">   
  <input type="button" onclick = "openClose('keyscr');openClose('keyhelp');" value="< Back" style="font-size:medium"/>
</div>

<div id="extrahelp" class="texter" style="display: none;">
	<input type="button" onclick = "openClose('extrascr');openClose('extrahelp');" value="< Back" style="font-size:medium"/>
     <hr style="background-color: rgb(192, 192, 192); color: #000000;">
     
  <div onClick="openClose('a18')" style="cursor:hand; cursor:pointer">
<h3>Send a PassLok item (Lock, message, etc.) by email</h3>
  </div>
  <div id="a18" class="texter" style="display: none;">  
<p>1. Check that the item is in the main box.</p>
<p>2. Click the More button in order to reveal the button dealing with email, which is above the text box.</p>
<p>3. Click the Email button. If so configured in the device, a window appears containing the item and some explanatory text. You only need to supply the recipient's email address and a subject line before clicking the Send button. If you do not want any explanatory text, check the No Tags checkbox in the main screen before clicking More.</p>
<p>4. This only works for sending messages, not for receiving them. If you receive a PassLok-locked message, you must copy it into the clipboard and then paste it into the main box of PassLok, so it can be unlocked.</p>
<p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=J7waoNX9UPA" target="_blank">https://www.youtube.com/watch?v=J7waoNX9UPA</a></p>
</div>
  <hr style="background-color: rgb(192, 192, 192); color: #000000;">
  
  <div onClick="openClose('a19')" style="cursor:hand; cursor:pointer">
<h3>Send a PassLok item by Text messaging (mobile only)</h3>
  </div>
  <div id="a19" class="texter" style="display: none;">  
<p>1. Check that the item to be sent is in the main box.</p>
<p>2. Click the More button in order to reveal the button dealing with text messaging, which is labeled SMS.</p>
<p>3. Click the Select button so the text can be selected.</p>
<p>4. Then click the Copy label as it appears on screen. The item is copied to clipboard.</p>
<p>5. Now you can click the SMS button. A window appears with the default Texting app.</p>
<p>6. Touch the input box and then paste the clipboard. Send he message in the usual way.</p>
<p>7. To unlock a locked message received by texting, you must copy it to clipboard, and then paste it in the main box of PassLok.</p>
<p>If you use Short Mode to lock a message, steps 2 and 3 are automatic.</p>
<p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=J7waoNX9UPA" target="_blank">https://www.youtube.com/watch?v=J7waoNX9UPA</a></p>
</div>
  <hr style="background-color: rgb(192, 192, 192); color: #000000;">
     
  <div onClick="openClose('a20')" style="cursor:hand; cursor:pointer">
<h3>Convert a PassLok item (Lock, message, etc.) into fake text</h3>
  </div>
  <div id="a20" class="texter" style="display: none;">  
<p>1. Check that the item to be converted into fake text is in the main box.</p>
<p>2. If you wish to make text that is not English, you will have to change the cover text using the process described in the next item.</p>
<p>3. Click the More button in order to reveal the buttons dealing with the stealth functions. The Words button replaces each character of the text with a word from the cover text; the recipient of the message thus encoded must have the same cover text. The Spaces button encodes the text into the spaces of the cover text; the recipient does not need to have the original cover text, but it takes seven times more words than the other mode.
<p>4. Click either the Words button of the Spaces button. The contents of the main box are converted into text using the current cover texty and displayed in the main box, replacing the previous contents.</p>
<p>5. You can now email the fake text, which to an email scanner will be nearly indistinguishable from real text. You can change the punctuation and merge or split lines without changing the encoded material. If you used Spaces encoding, you should be careful not to add or delete any spaces within the encoded text, but it is OK to add more text to complete the sentences, which may contain additional spaces.</p>
  <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=WXYpdDlVem4" target="_blank">https://www.youtube.com/watch?v=WXYpdDlVem4</a></p></div>
  <hr style="background-color: rgb(192, 192, 192); color: #000000;">
  
  <div onClick="openClose('a21')" style="cursor:hand; cursor:pointer">
<h3>Retrieve the original PassLok item from fake text</h3>
  </div>
  <div id="a21" class="texter" style="display: none;">
<p>1. Check that the fake text is in the main box.</p>
<p>2. If the fake text was encoded with the Words method, you will have to load the cover text used to do the encoding using the process described in the next item.</p>
<p>3. Click the More button, then click either the Words button or the Spaces button. If successful, the fake text in the main box is converted back into the original item and displayed in the main box, replacing the fake text.</p>
  <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=WXYpdDlVem4" target="_blank">https://www.youtube.com/watch?v=WXYpdDlVem4</a></p></div>
  <hr style="background-color: rgb(192, 192, 192); color: #000000;">
  
  <div onClick="openClose('a22')" style="cursor:hand; cursor:pointer">
<h3>Display or change the cover text used for fake text</h3>
  </div>
  <div id="a22" class="texter" style="display: none;">
<p>To display the current cover text (which is the default cover text after reloading PassLok), click the More button, and then the Cover button with the main box empty.</p>
<p>To change the cover text (this is necessary to make fake text in a language that is not English):</p>
<p>1. Copy a sufficiently long text (must have at least 70 different words) and paste it into the main box.</p>
<p>2. Click the More button, and then the Cover button.</p>
<p>3. If the change is successful, the main box goes blank. If the change is unsuccessful, a message above the window will say why. Typically, failure to change the dictionary is due to not having a sufficient number of different words. Use a longer text and try again.</p>
<p>4. The recipient of your messages turned into fake text must have the same cover text in order to retrieve a text encoded with the Words method. One way to ensure this when using a non-English language is to display the default cover text, copy it into a translation utility such as Google Translate, and then use the translation as the new cover text.</p>
  <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=WXYpdDlVem4" target="_blank">https://www.youtube.com/watch?v=WXYpdDlVem4</a></p></div>
  <hr style="background-color: rgb(192, 192, 192); color: #000000;">

  <div onClick="openClose('a23')" style="cursor:hand; cursor:pointer">
<h3>Display the ID of a Lock</h3>
</div>
<div id="a23" class="texter" style="display: none;">
<p>1. Paste the lock in the main box. It is okay if the tags up to the "=" signs
  are missing, or extra spaces, carriage returns, or special characters
  other than = + or / have been added.</p>
<p>2. Click the More button, and then click the ID button above the main box. 
The unique ID of that lock will be
  displayed in the main box, replacing the Lock. It is useful to verify the
  authenticity of a lock by means of a phone call, video message, etc., in
  which at least one of the parties reads the ID.</p>
  <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=FtNtflnM5zk" target="_blank">https://www.youtube.com/watch?v=FtNtflnM5zk</a></p></div>
   <hr style="background-color: rgb(192, 192, 192); color: #000000;">
   
  <div onClick="openClose('a24')" style="cursor:hand; cursor:pointer">
<h3>Verify PassLok's integrity</h3>
</div>
<div id="a24" class="texter" style="display: none;">
<p>If you obtained a native version of PassLok from an app store (Apple, GooglePlay) the following does not apply, but rather you are trusting that the app store has not tampered with the code submitted by the author. If you want to make sure that a native copy of PassLok is tamper-free, you should download the authentic html version as described below, and then test it against the native PassLok by locking messages in one app and unlocking them in the other, both ways. You can also check that the same Key produces the same Lock in both versions, and that signatures made by either one can be verified by the other.</p>
<p>To check the integrity of an html version of PassLok:</p>
<p>1. Load PassLok from one of the authorized sources listed below, or from storage (local or cloud) if previously saved as html as described in step 4 below.</p>
<p>2. Direct your browser to &quot;view source&quot;. Each
  browser does this differently, but most non-mobile browsers have this capability. Typically, you load the source on a separate tab by typing CTRL-u (Windows) or option-cmd-u (OSX). On
  the page displaying the source, select all (CTRL-a or cmd-a), then copy to clipboard (CTRL-c or cmd-c). Alternatively, you can get the source from PassLok's GitHub repository at: <a href="https://github.com/fruiz500/passlok">https://github.com/fruiz500/passlok</a></p>
<p>3. Back in the PassLok page, make sure the main box is clear, then paste the clipboard into it (CTRL-v or cmd-v). Click the ID
  button. The self-ID will be displayed in the main box, replacing the previous contents.</p>
<p>4. For better security, you can do a SHA256 of the source code using an external program or online utility. In this case you may need to paste the clipboard into a text or html editor so you can save it as a file (html or txt). <strong>DO NOT save the code using the "save" command from the browser menu</strong>, since this command tends to modify the source page before it saves it. A copy of PassLok saved this way will still run, but its SHA256 will be different. If your operating system is Windows, do not use the built-in Notepad program, since it cannot save text with the appropriate encoding (UTF-8, no BOM). Be sure there are no extra spaces at top and bottom, since this would affect the result. Then obtain the SHA256 of this file using the external utility.</p>
<p>5. Click the button below and look at the ID for this version of PassLok, shown below. If this ID and the one obtained in step 3 or 4 are the
same, the program has not been tampered with.</p>
<p>All of this is explained in this video tutorial (for v1.4): <a href="https://www.youtube.com/watch?v=SYCed3jTtTU" target="_blank">https://www.youtube.com/watch?v=SYCed3jTtTU</a></p>
	<input type="button" onclick="window.open('mirrors.html','_blank');" onBlur="ce();" onFocus="ce();" value="Show PassLok's ID" style="font-size:medium"/></p>
</div>
<hr style="background-color: rgb(192, 192, 192); color: #000000;">
  
    <div onClick="openClose('a25')" style="cursor:hand; cursor:pointer">
<h3>Privacy Statement</h3>
</div>
<div id="a25" class="texter" style="display: none;">
<p>PassLok provides excellent security, since it is a self-contained piece of code that does not rely on a server for its functionality. Therefore:</p>
<p><strong>1. We'll never give your secret Key to anyone.</strong> We cannot do anything concerning your Key because we just don't have it.</p>
<p><strong>2. We'll never give you or anyone else a conterfeit Lock made from any Key</strong>. We just don't run key servers. PassLok has functions to help you to authenticate Locks, but this is still your responsibility.</p>
<p><strong>3. We'll never weaken the cryptography methods contained within PassLok at the request of a third party, private or public.</strong> This also means no backdoors will ever be added. We'd rather shut down than be forced to do this, which would betray the very essence of PassLok.</p>
<p>Since the html version of PassLok is a piece of human-readable writing, we consider it an expression of free speech, protected by the laws of many countries. Tampering with it in unauthorized ways will violate free speech and copyright protection laws.</p>
<p>On the other hand:</p>
<p>The biggest vulnerability of PassLok is how easy it is to view, <strong>and consequently modify</strong> the html code. As mentioned above, we will never weaken the underlying cryptography, but others might. Even though we are taking pains to ensure that PassLok is delivered to you in the most secure way compatible with our budget, <strong>you should still make sure that you have obtained the genuine code.</strong></p>
<p>The method described in the next item, to verify the integrity of PassLok in html form, is less than perfect but it works in most situations. Once you are sure that your copy of PassLok is pristine, you can save it and run it as many times as you want from its storage location without having to connect to the page server again.</p>
<p>PassLok contains strong cryptographic methods, which may be illegal to use in some countries. Please check the local laws before using PassLok.</p>
</div>
  <hr style="background-color: rgb(192, 192, 192); color: #000000;"> 
    <input type="button" onclick = "openClose('extrascr');openClose('extrahelp');" value="< Back" style="font-size:medium"/>
</div>
  
</body></html>