<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" manifest="passlok.appcache"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>PassLok privacy</title>
    <style type="text/css">
		html {
	    -webkit-text-size-adjust: 100%;
		}
	    body {
		font-family: Sans-Serif;
		margin-left: 1%;
		margin-right: 1%;
		background-color: #FFFFFF;
		color: #000000;
		overflow: auto;
	    }
		.black_overlay{
			display: none;
			position: absolute;
			top: 0%;
			left: 0%;
			width: 100%;
			height: 100%;
			background-color: black;
			z-index:1001;
			-moz-opacity: 0.4;
			opacity:.40;
			filter: alpha(opacity=40);
		}
		.white_content {
			display: none;
			position: absolute;
			top: 15%;
			left: 15%;
			width: 70%;
			height: 70%;
			padding: 0px;
			border: 0px solid gray;
			background-color: white;
			z-index:1002;
			overflow: auto;       
		}
	</style>
      
    <meta name="Keywords" content="passlok, URSA, browser, encryption, decryption, symmetric, public key, signature, AES, ECDH, Diffie, Hellman, elliptic curve, advanced, javascript, PGP, PRISM">
    <meta name="Description" content="PassLok privacy">
    <meta name="author" content="F. Ruiz">
    <meta name="robots" content="index">
    <meta name="viewport" content="width=device-width, minimum-scale=1, maximum-scale=1, user-scalable=no">
	
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="default">
	<link rel="apple-touch-icon" href="passlok-touch-icon.png">
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico">

<script>
        /* 
		@source: https://www.autistici.org/passlok/index.html
		   
        @licstart  The following is the entire license notice for the 
        JavaScript code in this page.

        Copyright (C) 2013  Francisco Ruiz

        The JavaScript code in this page is free software: you can
        redistribute it and/or modify it under the terms of the GNU
        General Public License (GNU GPL) as published by the Free Software
        Foundation, either version 3 of the License, or (at your option)
        any later version.  The code is distributed WITHOUT ANY WARRANTY;
        without even the implied warranty of MERCHANTABILITY or FITNESS
        FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

        As additional permission under GNU GPL version 3 section 7, you
        may distribute non-source (e.g., minimized or compacted) forms of
        that code without the copy of the GNU GPL normally required by
        section 4, provided you include this license notice and a URL
        through which recipients can access the Corresponding Source.   


        @licend  The above is the entire license notice
        for the JavaScript code in this page.
        */

    if (window.location.protocol == "http:") {				//force SSL/TLS

        var restOfUrl = window.location.href.substr(5);
        window.location = "https:" + restOfUrl;
    }

// secrets.js - by Alexander Stetsyuk - released under MIT License
//substantial edits by F. Ruiz: since RNG used is from SJCL, RNG check is left to SJCL: RNG checking code removed from here.

(function(exports, global){
var defaults = {
	bits: 8, // default number of bits
	radix: 16, // work with HEX by default
	minBits: 3,
	maxBits: 20, // this permits 1,048,575 shares, though going this high is NOT recommended in JS!
	
	bytesPerChar: 2,
	maxBytesPerChar: 6, // Math.pow(256,7) > Math.pow(2,53)
		
	// Primitive polynomials (in decimal form) for Galois Fields GF(2^n), for 2 <= n <= 30
	// The index of each term in the array corresponds to the n for that polynomial
	// i.e. to get the polynomial for n=16, use primitivePolynomials[16]
	primitivePolynomials: [null,null,1,3,3,5,3,3,29,17,9,5,83,27,43,3,45,9,39,39,9,5,3,33,27,9,71,39,9,5,83],
	
	// warning for insecure PRNG
	warning: 'WARNING:\nA secure random number generator was not found.\nUsing Math.random(), which is NOT cryptographically strong!'
};

// Protected settings object
var config = {};

function init(bits){
	if(bits && (typeof bits !== 'number' || bits%1 !== 0 || bits<defaults.minBits || bits>defaults.maxBits)){
		throw new Error('Number of bits must be an integer between ' + defaults.minBits + ' and ' + defaults.maxBits + ', inclusive.')
	}	
	config.radix = defaults.radix;
	config.bits = bits || defaults.bits;
	config.size = Math.pow(2, config.bits);
	config.max = config.size - 1;
	
	// Construct the exp and log tables for multiplication.	
	var logs = [], exps = [], x = 1, primitive = defaults.primitivePolynomials[config.bits];
	for(var i=0; i<config.size; i++){
		exps[i] = x;
		logs[x] = i;
		x <<= 1;
		if(x >= config.size){
			x ^= primitive;
			x &= config.max;
		}
	}		
	config.logs = logs;
	config.exps = exps;
};

/** @expose **/
exports.init = init;

// Divides a `secret` number String str expressed in radix `inputRadix` (optional, default 16) 
// into `numShares` shares, each expressed in radix `outputRadix` (optional, default to `inputRadix`), 
// requiring `threshold` number of shares to reconstruct the secret. 
// Optionally, zero-pads the secret to a length that is a multiple of padLength before sharing.
/** @expose **/
exports.share = function(secret, numShares, threshold, padLength){
	padLength =  padLength || 0;
		
	if(typeof secret !== 'string'){
		throw new Error('Secret must be a string.');
	}
	if(typeof numShares !== 'number' || numShares%1 !== 0 || numShares < 2){
		throw new Error('Number of shares must be an integer between 2 and 2^bits-1 (' + config.max + '), inclusive.')
	}
	if(numShares > config.max){
		var neededBits = Math.ceil(Math.log(numShares +1)/Math.LN2);
		throw new Error('Number of shares must be an integer between 2 and 2^bits-1 (' + config.max + '), inclusive. To create ' + numShares + ' shares, use at least ' + neededBits + ' bits.')	
	}
	if(typeof threshold !== 'number' || threshold%1 !== 0 || threshold < 2){
		throw new Error('Threshold number of shares must be an integer between 2 and 2^bits-1 (' + config.max + '), inclusive.');
	}
	if(threshold > config.max){
		var neededBits = Math.ceil(Math.log(threshold +1)/Math.LN2);
		throw new Error('Threshold number of shares must be an integer between 2 and 2^bits-1 (' + config.max + '), inclusive.  To use a threshold of ' + threshold + ', use at least ' + neededBits + ' bits.');
	}
	if(typeof padLength !== 'number' || padLength%1 !== 0 ){
		throw new Error('Zero-pad length must be an integer greater than 1.');
	}	
	secret = '1' + hex2bin(secret); // append a 1 so that we can preserve the correct number of leading zeros in our secret
	secret = split(secret, padLength);	
	var x = new Array(numShares), y = new Array(numShares);
	for(var i=0, len = secret.length; i<len; i++){
		var subShares = this._getShares(secret[i], numShares, threshold);
		for(var j=0; j<numShares; j++){
			x[j] = x[j] || subShares[j].x.toString(config.radix);
			y[j] = padLeft(subShares[j].y.toString(2)) + (y[j] ? y[j] : '');
		}
	}
	var padding = config.max.toString(config.radix).length;
	for(var i=0; i<numShares; i++){
		x[i] = config.bits.toString(36) + padLeft(x[i],padding) + bin2hex(y[i]);
	}		
	return x;
};

// This is the basic polynomial generation and evaluation function 
// for a `config.bits`-length secret (NOT an arbitrary length)
// Note: no error-checking at this stage! If `secrets` is NOT 
// a NUMBER less than 2^bits-1, the output will be incorrect!
/** @expose **/
exports._getShares = function(secret, numShares, threshold){	
	var shares = [];
	var coeffs = [secret];
	var limit = Math.pow(2,config.bits); 		
	for(var i=1; i<threshold; i++){
//		coeffs[i] = parseInt(config.rng(config.bits),2);		//original random decimal number of maximum size 2^config.bits
		coeffs[i]=sjcl.bn.random(limit).limbs[0];				//using SJCL RNG
	}
	for(var i=1, len = numShares+1; i<len; i++){
		shares[i-1] = {
			x: i,
			y: horner(i, coeffs)
		}
	}
	return shares;
};
	
// Polynomial evaluation at `x` using Horner's Method
// TODO: this can possibly be sped up using other methods
// NOTE: fx=fx * x + coeff[i] ->  exp(log(fx) + log(x)) + coeff[i], 
//       so if fx===0, just set fx to coeff[i] because
//       using the exp/log form will result in incorrect value
function horner(x, coeffs){
	var logx = config.logs[x];
	var fx = 0;
	for(var i=coeffs.length-1; i>=0; i--){	
		if(fx === 0){
			fx = coeffs[i];
			continue;
		}
		fx = config.exps[ (logx + config.logs[fx]) % config.max ] ^ coeffs[i];
	}
	return fx;
};

function inArray(arr,val){
	for(var i = 0,len=arr.length; i < len; i++) {
		if(arr[i] === val){
   		 return true;
	 	}
 	}
	return false;
};

function processShare(share){
	
	var bits = parseInt(share[0], 36);
	if(bits && (typeof bits !== 'number' || bits%1 !== 0 || bits<defaults.minBits || bits>defaults.maxBits)){
		throw new Error('Number of bits must be an integer between ' + defaults.minBits + ' and ' + defaults.maxBits + ', inclusive.')
	}	
	var max = Math.pow(2, bits) - 1;
	var idLength = max.toString(config.radix).length;
	
	var id = parseInt(share.substr(1, idLength), config.radix);
	if(typeof id !== 'number' || id%1 !== 0 || id<1 || id>max){
		throw new Error('Share id must be an integer between 1 and ' + config.max + ', inclusive.');
	}
	share = share.substr(idLength + 1);
	if(!share.length){
		throw new Error('Invalid share: zero-length share.')
	}
	return {
		'bits': bits,
		'id': id,
		'value': share
	};
};

/** @expose **/
secrets._processShare = processShare;

// Protected method that evaluates the Lagrange interpolation
// polynomial at x=`at` for individual config.bits-length
// segments of each share in the `shares` Array.
// Each share is expressed in base `inputRadix`. The output 
// is expressed in base `outputRadix'
function combine(at, shares){
	var setBits, share, x = [], y = [], result = '', idx;	
	
	for(var i=0, len = shares.length; i<len; i++){
		share = processShare(shares[i]);
		if(typeof setBits === 'undefined'){
			setBits = share['bits'];
		}else if(share['bits'] !== setBits){
			throw new Error('Mismatched shares: Different bit settings.')
		}		
		if(config.bits !== setBits){
			init(setBits);
		}		
		if(inArray(x, share['id'])){ // repeated x value?
			continue;
		}	
		idx = x.push(share['id']) - 1;
		share = split(hex2bin(share['value']));
		for(var j=0, len2 = share.length; j<len2; j++){
			y[j] = y[j] || [];
			y[j][idx] = share[j];
		}
	}	
	for(var i=0, len=y.length; i<len; i++){
		result = padLeft(lagrange(at, x, y[i]).toString(2)) + result;
	}
	if(at===0){// reconstructing the secret
		var idx = result.indexOf('1'); //find the first 1
		return bin2hex(result.slice(idx+1));
	}else{// generating a new share
		return bin2hex(result);
	}
};

// Combine `shares` Array into the original secret
/** @expose **/
exports.combine = function(shares){
	return combine(0, shares);
};

// Generate a new share with id `id` (a number between 1 and 2^bits-1)
// `id` can be a Number or a String in the default radix (16)
/** @expose **/
exports.newShare = function(id, shares){
	if(typeof id === 'string'){
		id = parseInt(id, config.radix);	
	}
	
	var share = processShare(shares[0]);
	var max = Math.pow(2, share['bits']) - 1;
	
	if(typeof id !== 'number' || id%1 !== 0 || id<1 || id>max){
		throw new Error('Share id must be an integer between 1 and ' + config.max + ', inclusive.');
	}

	var padding = max.toString(config.radix).length;
	return config.bits.toString(36) + padLeft(id.toString(config.radix), padding) + combine(id, shares);
};

// Evaluate the Lagrange interpolation polynomial at x = `at`
// using x and y Arrays that are of the same length, with
// corresponding elements constituting points on the polynomial.
function lagrange(at, x, y){
	var sum = 0,
		product, 
		i, j;
		
	for(var i=0, len = x.length; i<len; i++){
		if(!y[i]){
			continue; 
		}			
		product = config.logs[y[i]];
		for(var j=0; j<len; j++){
			if(i === j){ continue; }
			if(at === x[j]){ // happens when computing a share that is in the list of shares used to compute it
				product = -1; // fix for a zero product term, after which the sum should be sum^0 = sum, not sum^1
				break; 
			}
			product = ( product + config.logs[at ^ x[j]] - config.logs[x[i] ^ x[j]] + config.max/* to make sure it's not negative */ ) % config.max;
		}			
		sum = product === -1 ? sum : sum ^ config.exps[product]; // though exps[-1]= undefined and undefined ^ anything = anything in chrome, this behavior may not hold everywhere, so do the check
	}
	return sum;
};

/** @expose **/
exports._lagrange = lagrange;

// Splits a number string `bits`-length segments, after first 
// optionally zero-padding it to a length that is a multiple of `padLength.
// Returns array of integers (each less than 2^bits-1), with each element
// representing a `bits`-length segment of the input string from right to left, 
// i.e. parts[0] represents the right-most `bits`-length segment of the input string.
function split(str, padLength){
	if(padLength){
		str = padLeft(str, padLength)
	}
	var parts = [];
	for(var i=str.length; i>config.bits; i-=config.bits){
		parts.push(parseInt(str.slice(i-config.bits, i), 2));
	}	
	parts.push(parseInt(str.slice(0, i), 2));	
	return parts;
};
	
// Pads a string `str` with zeros on the left so that its length is a multiple of `bits`
function padLeft(str, bits){
	bits = bits || config.bits
	var missing = str.length % bits;
	return (missing ? new Array(bits - missing + 1).join('0') : '') + str;
};

function hex2bin(str){
	var bin = '', num;
	for(var i=str.length - 1; i>=0; i--){
		num = parseInt(str[i], 16)
		if(isNaN(num)){
			throw new Error('Invalid hex character.')
		}
		bin = padLeft(num.toString(2), 4) + bin;
	}
	return bin;
}

function bin2hex(str){
	var hex = '', num;
	str = padLeft(str, 4);
	for(var i=str.length; i>=4; i-=4){
		num = parseInt(str.slice(i-4, i), 2);
		if(isNaN(num)){
			throw new Error('Invalid binary character.')
		}
		hex = num.toString(16) + hex;
	}
	return hex;
}
	
// by default, initialize without an RNG
exports.init();
})(typeof module !== 'undefined' && module['exports'] ? module['exports'] : (window['secrets'] = {}), typeof GLOBAL !== 'undefined' ? GLOBAL : window );


//PixelJihad method for hiding text in images, by Zach Oakes

// put image in the canvas and display it
var importImage = function(e) {
	
//learn mode dialog added by F. Ruiz
	if (document.getElementById("learnmode").checked === true){
		var reply = confirm("An image stored in this device will replace the current image. Cancel if this is not what you want.");
		if(reply==false) throw("image import canceled");
	}
//end of learn mode dialog
	
    var reader = new FileReader();

    reader.onload = function(event) {
        // set the preview
        document.getElementById('preview').style.display = 'block';
        document.getElementById('preview').src = event.target.result;

        // read the data into the canvas element
        var img = new Image();
        img.onload = function() {
            var ctx = document.getElementById('canvas').getContext('2d');
            ctx.canvas.width = img.width;
            ctx.canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
        };
        img.src = event.target.result;
    };

    reader.readAsDataURL(e.target.files[0]);
	document.getElementById('imagemsg').innerHTML=''
};

// encode the image and save it
var encodeImage = function() {
	
//learn mode dialog added by F. Ruiz
	if (document.getElementById("learnmode").checked === true){
		var reply = confirm("The text in the previous box will be encoded into this image, which can then be copied and sent to others. Cancel if this is not what you want.");
		if(reply==false) throw("encode image canceled");
	}
//end of learn mode dialog
	
	var imagemsg = document.getElementById('imagemsg');
    var message = document.extra.text.value;
    var canvas = document.getElementById('canvas');
    var ctx = canvas.getContext('2d');

//bail out if this is not a PassLok string. This part inserted by F. Ruiz
	for (var i = 0; i < message.length; i++){
		var index = keystr.indexOf(message[i]);			//keystr is a global variable defined in the text steganography section
		if(index == -1){
			imagemsg.innerHTML = '<span style="color:red">The text contains illegal characters for a PassLok string</span>';
			throw("illegal characters in the box")
		}
	}
//continue Oakes code
	
        message = JSON.stringify({'text': message});

    // exit early if the message is too big for the image
    var pixelCount = ctx.canvas.width * ctx.canvas.height;
    if ((message.length + 1) * 16 > pixelCount * 4 * 0.75) {
		imagemsg.innerHTML = 'The text is too large for the image';
        return;
    }

    // encode the encrypted message with the supplied password
    var imgData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
    encodeMessage(imgData.data, sjcl.hash.sha256.hash(""), message);
    ctx.putImageData(imgData, 0, 0);

    // view the new image
	imagemsg.innerHTML = 'Text hidden in the image. Save it now.'
    preview.src = canvas.toDataURL();
};

// decode the image and display the contents if there is anything
var decodeImage = function() {
	
//learn mode dialog added by F. Ruiz
	if (document.getElementById("learnmode").checked === true){
		var reply = confirm("The text hidden in this image, if any, will be extracted and placed in the previous box, replacing its contents. This does not yet work on mobile devices. Cancel if this is not what you want.");
		if(reply==false) throw("decode image canceled");
	}
//end of learn mode dialog
	
	var imagemsg = document.getElementById('imagemsg');
	
	//not working on mobile devices, so bail out here. Inserted by F. Ruiz
	if(typeof window.orientation !== 'undefined'){
		imagemsg.innerHTML = '<span style="color:orange">Reveal unavailable on mobile devices</span>';
		throw('reveal function not working for mobile')
	}
	
    var ctx = document.getElementById('canvas').getContext('2d');
    var imgData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
    var message = decodeMessage(imgData.data, sjcl.hash.sha256.hash(""));

    // try to parse the JSON
    var obj = null;
    try {
        obj = JSON.parse(message);
		imagemsg.innerHTML = 'This image contains a message. Go back to see it.'
    } catch (e) {
		imagemsg.innerHTML = 'This image does not contain a message.'
    }
	document.extra.text.value = obj.text
};

// returns a 1 or 0 for the bit in 'location'
var getBit = function(number, location) {
   return ((number >> location) & 1);
};

// sets the bit in 'location' to 'bit' (either a 1 or 0)
var setBit = function(number, location, bit) {
   return (number & ~(1 << location)) | (bit << location);
};

// returns an array of 1s and 0s for a 2-byte number
var getBitsFromNumber = function(number) {
   var bits = [];
   for (var i = 0; i < 16; i++) {
       bits.push(getBit(number, i));
   }
   return bits;
};

// returns the next 2-byte number
var getNumberFromBits = function(bytes, history, hash) {
    var number = 0, pos = 0;
    while (pos < 16) {
        var loc = getNextLocation(history, hash, bytes.length);
        var bit = getBit(bytes[loc], 0);
        number = setBit(number, pos, bit);
        pos++;
    }
    return number;
};

// returns an array of 1s and 0s for the string 'message'
var getMessageBits = function(message) {
    var messageBits = [];
    for (var i = 0; i < message.length; i++) {
        var code = message.charCodeAt(i);
        messageBits = messageBits.concat(getBitsFromNumber(code));
    }
    return messageBits;
};

// gets the next location to store a bit
var getNextLocation = function(history, hash, total) {
    var pos = history.length;
    var loc = Math.abs(hash[pos % hash.length] * (pos + 1)) % total;
    while (true) {
        if (loc >= total) {
            loc = 0;
        } else if (history.indexOf(loc) >= 0) {
            loc++;
        } else if ((loc + 1) % 4 === 0) {
            loc++;
        } else {
            history.push(loc);
            return loc;
        }
    }
};

// encodes the supplied 'message' into the CanvasPixelArray 'colors'
var encodeMessage = function(colors, hash, message) {
    // make an array of bits from the message
    var messageBits = getBitsFromNumber(message.length);
    messageBits = messageBits.concat(getMessageBits(message));

    // this will store the color values we've already modified
    var history = [];

    // encode the bits into the pixels
    var pos = 0;
    while (pos < messageBits.length) {
        // set the next color value to the next bit
        var loc = getNextLocation(history, hash, colors.length);
        colors[loc] = setBit(colors[loc], 0, messageBits[pos]);

        // set the alpha value in this pixel to 255
        // we have to do this because browsers do premultiplied alpha
        // see for example: http://stackoverflow.com/q/4309364
        while ((loc + 1) % 4 !== 0) {
            loc++;
        }
        colors[loc] = 255;

        pos++;
    }
};

// returns the message encoded in the CanvasPixelArray 'colors'
var decodeMessage = function(colors, hash) {
    // this will store the color values we've already read from
    var history = [];

    // get the message size
    var messageSize = getNumberFromBits(colors, history, hash);

    // exit early if the message is too big for the image
    if ((messageSize + 1) * 16 > colors.length * 0.75) {
        return '';
    }

    // put each character into an array
    var message = [];
    for (var i = 0; i < messageSize; i++) {
        var code = getNumberFromBits(colors, history, hash);
        message.push(String.fromCharCode(code));
    }

    // the characters should parse into valid JSON
    return message.join('');
};


/*SJCL.js begins
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 * @author Jeff Mott
 * @author Stefan Thomas
 */

"use strict";
var sjcl = {
    cipher: {},
    hash: {},
    keyexchange: {},
    mode: {},
    misc: {},
    codec: {},
    exception: {
	corrupt: function (a) {
	    this.toString = function () {
		return "CORRUPT: " + this.message
	    };
	    this.message = a
	},
	invalid: function (a) {
	    this.toString = function () {
		return "INVALID: " + this.message
	    };
	    this.message = a
	},
	bug: function (a) {
	    this.toString = function () {
		return "BUG: " + this.message
	    };
	    this.message = a
	},
	notReady: function (a) {
	    this.toString = function () {
		return "NOT READY: " + this.message
	    };
	    this.message = a
	}
    }
};
if (typeof module != "undefined" && module.exports) module.exports = sjcl;
sjcl.cipher.aes = function (a) {
    this.h[0][0][0] || this.z();
    var b, c, d, e, f = this.h[0][4],
	g = this.h[1];
    b = a.length;
    var h = 1;
    if (b !== 4 && b !== 6 && b !== 8) throw new sjcl.exception.invalid("invalid aes key size");
    this.a = [d = a.slice(0), e = []];
    for (a = b; a < 4 * b + 28; a++) {
	c = d[a - 1];
	if (a % b === 0 || b === 8 && a % b === 4) {
	    c = f[c >>> 24] << 24 ^ f[c >> 16 & 255] << 16 ^ f[c >> 8 & 255] << 8 ^ f[c & 255];
	    if (a % b === 0) {
		c = c << 8 ^ c >>> 24 ^ h << 24;
		h = h << 1 ^ (h >> 7) * 283
	    }
	}
	d[a] = d[a - b] ^ c
    }
    for (b = 0; a; b++, a--) {
	c = d[b & 3 ? a : a - 4];
	e[b] = a <= 4 || b < 4 ? c : g[0][f[c >>> 24]] ^ g[1][f[c >> 16 & 255]] ^ g[2][f[c >> 8 & 255]] ^ g[3][f[c & 255]]
    }
};
sjcl.cipher.aes.prototype = {
    encrypt: function (a) {
	return this.I(a, 0)
    },
    decrypt: function (a) {
	return this.I(a, 1)
    },
    h: [
	[
	    [],
	    [],
	    [],
	    [],
	    []
	],
	[
	    [],
	    [],
	    [],
	    [],
	    []
	]
    ],
    z: function () {
	var a = this.h[0],
	    b = this.h[1],
	    c = a[4],
	    d = b[4],
	    e, f, g, h = [],
	    i = [],
	    k, j, l, m;
	for (e = 0; e < 0x100; e++) i[(h[e] = e << 1 ^ (e >> 7) * 283) ^ e] = e;
	for (f = g = 0; !c[f]; f ^= k || 1, g = i[g] || 1) {
	    l = g ^ g << 1 ^ g << 2 ^ g << 3 ^ g << 4;
	    l = l >> 8 ^ l & 255 ^ 99;
	    c[f] = l;
	    d[l] = f;
	    j = h[e = h[k = h[f]]];
	    m = j * 0x1010101 ^ e * 0x10001 ^ k * 0x101 ^ f * 0x1010100;
	    j = h[l] * 0x101 ^ l * 0x1010100;
	    for (e = 0; e < 4; e++) {
		a[e][f] = j = j << 24 ^ j >>> 8;
		b[e][l] = m = m << 24 ^ m >>> 8
	    }
	}
	for (e = 0; e < 5; e++) {
	    a[e] = a[e].slice(0);
	    b[e] = b[e].slice(0)
	}
    },
    I: function (a, b) {
	if (a.length !== 4) throw new sjcl.exception.invalid("invalid aes block size");
	var c = this.a[b],
	    d = a[0] ^ c[0],
	    e = a[b ? 3 : 1] ^ c[1],
	    f = a[2] ^ c[2];
	a = a[b ? 1 : 3] ^ c[3];
	var g, h, i, k = c.length / 4 - 2,
	    j, l = 4,
	    m = [0, 0, 0, 0];
	g = this.h[b];
	var n = g[0],
	    o = g[1],
	    p = g[2],
	    q = g[3],
	    r = g[4];
	for (j = 0; j < k; j++) {
	    g = n[d >>> 24] ^ o[e >> 16 & 255] ^ p[f >> 8 & 255] ^ q[a & 255] ^ c[l];
	    h = n[e >>> 24] ^ o[f >> 16 & 255] ^ p[a >> 8 & 255] ^ q[d & 255] ^ c[l + 1];
	    i = n[f >>> 24] ^ o[a >> 16 & 255] ^ p[d >> 8 & 255] ^ q[e & 255] ^ c[l + 2];
	    a = n[a >>> 24] ^ o[d >> 16 & 255] ^ p[e >> 8 & 255] ^ q[f & 255] ^ c[l + 3];
	    l += 4;
	    d = g;
	    e = h;
	    f = i
	}
	for (j = 0; j < 4; j++) {
	    m[b ? 3 & -j : j] = r[d >>> 24] << 24 ^ r[e >> 16 & 255] << 16 ^ r[f >> 8 & 255] << 8 ^ r[a & 255] ^ c[l++];
	    g = d;
	    d = e;
	    e = f;
	    f = a;
	    a = g
	}
	return m
    }
};
sjcl.bitArray = {
    bitSlice: function (a, b, c) {
	a = sjcl.bitArray.P(a.slice(b / 32), 32 - (b & 31)).slice(1);
	return c === undefined ? a : sjcl.bitArray.clamp(a, c - b)
    },
    extract: function (a, b, c) {
	var d = Math.floor(-b - c & 31);
	return ((b + c - 1 ^ b) & -32 ? a[b / 32 | 0] << 32 - d ^ a[b / 32 + 1 | 0] >>> d : a[b / 32 | 0] >>> d) & (1 << c) - 1
    },
    concat: function (a, b) {
	if (a.length === 0 || b.length === 0) return a.concat(b);
	var c = a[a.length - 1],
	    d = sjcl.bitArray.getPartial(c);
	return d === 32 ? a.concat(b) : sjcl.bitArray.P(b, d, c | 0, a.slice(0, a.length - 1))
    },
    bitLength: function (a) {
	var b = a.length;
	if (b === 0) return 0;
	return (b - 1) * 32 + sjcl.bitArray.getPartial(a[b - 1])
    },
    clamp: function (a, b) {
	if (a.length * 32 < b) return a;
	a = a.slice(0, Math.ceil(b / 32));
	var c = a.length;
	b &= 31;
	if (c > 0 && b) a[c - 1] = sjcl.bitArray.partial(b, a[c - 1] & 2147483648 >> b - 1, 1);
	return a
    },
    partial: function (a, b, c) {
	if (a === 32) return b;
	return (c ? b | 0 : b << 32 - a) + a * 0x10000000000
    },
    getPartial: function (a) {
	return Math.round(a / 0x10000000000) || 32
    },
    equal: function (a, b) {
	if (sjcl.bitArray.bitLength(a) !== sjcl.bitArray.bitLength(b)) return false;
	var c = 0,
	    d;
	for (d = 0; d < a.length; d++) c |= a[d] ^ b[d];
	return c === 0
    },
    P: function (a, b, c, d) {
	var e;
	e = 0;
	if (d === undefined) d = [];
	for (; b >= 32; b -= 32) {
	    d.push(c);
	    c = 0
	}
	if (b === 0) return d.concat(a);
	for (e = 0; e < a.length; e++) {
	    d.push(c | a[e] >>> b);
	    c = a[e] << 32 - b
	}
	e = a.length ? a[a.length - 1] : 0;
	a = sjcl.bitArray.getPartial(e);
	d.push(sjcl.bitArray.partial(b + a & 31, b + a > 32 ? c : d.pop(), 1));
	return d
    },
    k: function (a, b) {
	return [a[0] ^ b[0], a[1] ^ b[1], a[2] ^ b[2], a[3] ^ b[3]]
    }
};
sjcl.codec.utf8String = {
    fromBits: function (a) {
	var b = "",
	    c = sjcl.bitArray.bitLength(a),
	    d, e;
	for (d = 0; d < c / 8; d++) {
	    if ((d & 3) === 0) e = a[d / 4];
	    b += String.fromCharCode(e >>> 24);
	    e <<= 8
	}
	return decodeURIComponent(escape(b))
    },
    toBits: function (a) {
	a = unescape(encodeURIComponent(a));
	var b = [],
	    c, d = 0;
	for (c = 0; c < a.length; c++) {
	    d = d << 8 | a.charCodeAt(c);
	    if ((c & 3) === 3) {
		b.push(d);
		d = 0
	    }
	}
	c & 3 && b.push(sjcl.bitArray.partial(8 * (c & 3), d));
	return b
    }
};
sjcl.codec.hex = {
    fromBits: function (a) {
	var b = "",
	    c;
	for (c = 0; c < a.length; c++) b += ((a[c] | 0) + 0xf00000000000).toString(16).substr(4);
	return b.substr(0, sjcl.bitArray.bitLength(a) / 4)
    },
    toBits: function (a) {
	var b, c = [],
	    d;
	a = a.replace(/\s|0x/g, "");
	d = a.length;
	a += "00000000";
	for (b = 0; b < a.length; b += 8) c.push(parseInt(a.substr(b, 8), 16) ^ 0);
	return sjcl.bitArray.clamp(c, d * 4)
    }
};
sjcl.codec.base64 = {
    F: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    fromBits: function (a, b, c) {
	var d = "",
	    e = 0,
	    f = sjcl.codec.base64.F,
	    g = 0,
	    h = sjcl.bitArray.bitLength(a);
	if (c) f = f.substr(0, 62) + "-_";
	for (c = 0; d.length * 6 < h;) {
	    d += f.charAt((g ^ a[c] >>> e) >>> 26);
	    if (e < 6) {
		g = a[c] << 6 - e;
		e += 26;
		c++
	    } else {
		g <<= 6;
		e -= 6
	    }
	}
	for (; d.length & 3 && !b;) d += "=";
	return d
    },
    toBits: function (a, b) {
	a = a.replace(/\s|=/g, "");
	var c = [],
	    d = 0,
	    e = sjcl.codec.base64.F,
	    f = 0,
	    g;
	if (b) e = e.substr(0, 62) + "-_";
	for (b = 0; b < a.length; b++) {
	    g = e.indexOf(a.charAt(b));
	    if (g < 0) throw new sjcl.exception.invalid("this isn't base64!");
	    if (d > 26) {
		d -= 26;
		c.push(f ^ g >>> d);
		f = g << 32 - d
	    } else {
		d += 6;
		f ^= g << 32 - d
	    }
	}
	d & 56 && c.push(sjcl.bitArray.partial(d & 56, f, 1));
	return c
    }
};
sjcl.codec.base64url = {
    fromBits: function (a) {
	return sjcl.codec.base64.fromBits(a, 1, 1)
    },
    toBits: function (a) {
	return sjcl.codec.base64.toBits(a, 1)
    }
};
sjcl.hash.sha256 = function (a) {
    this.a[0] || this.z();
    if (a) {
	this.n = a.n.slice(0);
	this.i = a.i.slice(0);
	this.e = a.e
    } else this.reset()
};
sjcl.hash.sha256.hash = function (a) {
    return (new sjcl.hash.sha256).update(a).finalize()
};
sjcl.hash.sha256.prototype = {
    blockSize: 512,
    reset: function () {
	this.n = this.N.slice(0);
	this.i = [];
	this.e = 0;
	return this
    },
    update: function (a) {
	if (typeof a === "string") a = sjcl.codec.utf8String.toBits(a);
	var b, c = this.i = sjcl.bitArray.concat(this.i, a);
	b = this.e;
	a = this.e = b + sjcl.bitArray.bitLength(a);
	for (b = 512 + b & -512; b <= a; b += 512) this.D(c.splice(0, 16));
	return this
    },
    finalize: function () {
	var a, b = this.i,
	    c = this.n;
	b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1, 1)]);
	for (a = b.length + 2; a & 15; a++) b.push(0);
	b.push(Math.floor(this.e / 4294967296));
	for (b.push(this.e | 0); b.length;) this.D(b.splice(0, 16));
	this.reset();
	return c
    },
    N: [],
    a: [],
    z: function () {
	function a(e) {
	    return (e - Math.floor(e)) * 0x100000000 | 0
	}
	var b = 0,
	    c = 2,
	    d;
	a: for (; b < 64; c++) {
	    for (d = 2; d * d <= c; d++) if (c % d === 0) continue a;
	    if (b < 8) this.N[b] = a(Math.pow(c, 0.5));
	    this.a[b] = a(Math.pow(c, 1 / 3));
	    b++
	}
    },
    D: function (a) {
	var b, c, d = a.slice(0),
	    e = this.n,
	    f = this.a,
	    g = e[0],
	    h = e[1],
	    i = e[2],
	    k = e[3],
	    j = e[4],
	    l = e[5],
	    m = e[6],
	    n = e[7];
	for (a = 0; a < 64; a++) {
	    if (a < 16) b = d[a];
	    else {
		b = d[a + 1 & 15];
		c = d[a + 14 & 15];
		b = d[a & 15] = (b >>> 7 ^ b >>> 18 ^ b >>> 3 ^ b << 25 ^ b << 14) + (c >>> 17 ^ c >>> 19 ^ c >>> 10 ^ c << 15 ^ c << 13) + d[a & 15] + d[a + 9 & 15] | 0
	    }
	    b = b + n + (j >>> 6 ^ j >>> 11 ^ j >>> 25 ^ j << 26 ^ j << 21 ^ j << 7) + (m ^ j & (l ^ m)) + f[a];
	    n = m;
	    m = l;
	    l = j;
	    j = k + b | 0;
	    k = i;
	    i = h;
	    h = g;
	    g = b + (h & i ^ k & (h ^ i)) + (h >>> 2 ^ h >>> 13 ^ h >>> 22 ^ h << 30 ^ h << 19 ^ h << 10) | 0
	}
	e[0] = e[0] + g | 0;
	e[1] = e[1] + h | 0;
	e[2] = e[2] + i | 0;
	e[3] = e[3] + k | 0;
	e[4] = e[4] + j | 0;
	e[5] = e[5] + l | 0;
	e[6] = e[6] + m | 0;
	e[7] = e[7] + n | 0
    }
};
sjcl.mode.ccm = {
    name: "ccm",
    encrypt: function (a, b, c, d, e) {
	var f, g = b.slice(0),
	    h = sjcl.bitArray,
	    i = h.bitLength(c) / 8,
	    k = h.bitLength(g) / 8;
	e = e || 64;
	d = d || [];
	if (i < 7) throw new sjcl.exception.invalid("ccm: iv must be at least 7 bytes");
	for (f = 2; f < 4 && k >>> 8 * f; f++);
	if (f < 15 - i) f = 15 - i;
	c = h.clamp(c, 8 * (15 - f));
	b = sjcl.mode.ccm.H(a, b, c, d, e, f);
	g = sjcl.mode.ccm.J(a, g, c, b, e, f);
	return h.concat(g.data, g.tag)
    },
    decrypt: function (a, b, c, d, e) {
	e = e || 64;
	d = d || [];
	var f = sjcl.bitArray,
	    g = f.bitLength(c) / 8,
	    h = f.bitLength(b),
	    i = f.clamp(b, h - e),
	    k = f.bitSlice(b,
	    h - e);
	h = (h - e) / 8;
	if (g < 7) throw new sjcl.exception.invalid("ccm: iv must be at least 7 bytes");
	for (b = 2; b < 4 && h >>> 8 * b; b++);
	if (b < 15 - g) b = 15 - g;
	c = f.clamp(c, 8 * (15 - b));
	i = sjcl.mode.ccm.J(a, i, c, k, e, b);
	a = sjcl.mode.ccm.H(a, i.data, c, d, e, b);
	if (!f.equal(i.tag, a)){																//modified to add alert in PassLok
		if(document.lock.text.value.slice(0,1) == '~'){										//
			any2key();										//
			document.getElementById("keymsg").innerHTML = "<span style='color:red'>This Key won't unlock the item</span>"
		}else{
			document.getElementById("mainmsg").innerHTML = '<span>Unlocking has Failed</span>';
		}																					//
	throw new sjcl.exception.corrupt("ccm: tag doesn't match")								//
	};																						//
	return i.data
    },
    H: function (a, b, c, d, e, f) {
	var g = [],
	    h = sjcl.bitArray,
	    i = h.k;
	e /= 8;
	if (e % 2 || e < 4 || e > 16) throw new sjcl.exception.invalid("ccm: invalid tag length");
	if (d.length > 0xffffffff || b.length > 0xffffffff) throw new sjcl.exception.bug("ccm: can't deal with 4GiB or more data");
	f = [h.partial(8, (d.length ? 64 : 0) | e - 2 << 2 | f - 1)];
	f = h.concat(f, c);
	f[3] |= h.bitLength(b) / 8;
	f = a.encrypt(f);
	if (d.length) {
	    c = h.bitLength(d) / 8;
	    if (c <= 65279) g = [h.partial(16, c)];
	    else if (c <= 0xffffffff) g = h.concat([h.partial(16, 65534)], [c]);
	    g = h.concat(g, d);
	    for (d = 0; d < g.length; d += 4) f = a.encrypt(i(f, g.slice(d, d + 4).concat([0, 0, 0])))
	}
	for (d = 0; d < b.length; d += 4) f = a.encrypt(i(f, b.slice(d, d + 4).concat([0, 0, 0])));
	return h.clamp(f, e * 8)
    },
    J: function (a, b, c, d, e, f) {
	var g, h = sjcl.bitArray;
	g = h.k;
	var i = b.length,
	    k = h.bitLength(b);
	c = h.concat([h.partial(8,
	f - 1)], c).concat([0, 0, 0]).slice(0, 4);
	d = h.bitSlice(g(d, a.encrypt(c)), 0, e);
	if (!i) return {
	    tag: d,
	    data: []
	};
	for (g = 0; g < i; g += 4) {
	    c[3]++;
	    e = a.encrypt(c);
	    b[g] ^= e[0];
	    b[g + 1] ^= e[1];
	    b[g + 2] ^= e[2];
	    b[g + 3] ^= e[3]
	}
	return {
	    tag: d,
	    data: h.clamp(b, k)
	}
    }
};
sjcl.mode.ocb2 = {
    name: "ocb2",
    encrypt: function (a, b, c, d, e, f) {
	if (sjcl.bitArray.bitLength(c) !== 128) throw new sjcl.exception.invalid("ocb iv must be 128 bits");
	var g, h = sjcl.mode.ocb2.B,
	    i = sjcl.bitArray,
	    k = i.k,
	    j = [0, 0, 0, 0];
	c = h(a.encrypt(c));
	var l, m = [];
	d = d || [];
	e = e || 64;
	for (g = 0; g + 4 < b.length; g += 4) {
	    l = b.slice(g, g + 4);
	    j = k(j, l);
	    m = m.concat(k(c, a.encrypt(k(c, l))));
	    c = h(c)
	}
	l = b.slice(g);
	b = i.bitLength(l);
	g = a.encrypt(k(c, [0, 0, 0, b]));
	l = i.clamp(k(l.concat([0, 0, 0]), g), b);
	j = k(j, k(l.concat([0, 0, 0]), g));
	j = a.encrypt(k(j, k(c, h(c))));
	if (d.length) j = k(j, f ? d : sjcl.mode.ocb2.pmac(a, d));
	return m.concat(i.concat(l, i.clamp(j, e)))
    },
    decrypt: function (a, b, c, d, e, f) {
	if (sjcl.bitArray.bitLength(c) !== 128) throw new sjcl.exception.invalid("ocb iv must be 128 bits");
	e = e || 64;
	var g = sjcl.mode.ocb2.B,
	    h = sjcl.bitArray,
	    i = h.k,
	    k = [0, 0, 0, 0],
	    j = g(a.encrypt(c)),
	    l, m, n = sjcl.bitArray.bitLength(b) - e,
	    o = [];
	d = d || [];
	for (c = 0; c + 4 < n / 32; c += 4) {
	    l = i(j, a.decrypt(i(j, b.slice(c, c + 4))));
	    k = i(k, l);
	    o = o.concat(l);
	    j = g(j)
	}
	m = n - c * 32;
	l = a.encrypt(i(j, [0, 0, 0, m]));
	l = i(l, h.clamp(b.slice(c),
	m).concat([0, 0, 0]));
	k = i(k, l);
	k = a.encrypt(i(k, i(j, g(j))));
	if (d.length) k = i(k, f ? d : sjcl.mode.ocb2.pmac(a, d));
	if (!h.equal(h.clamp(k, e), h.bitSlice(b, n))) throw new sjcl.exception.corrupt("ocb: tag doesn't match");
	return o.concat(h.clamp(l, m))
    },
    pmac: function (a, b) {
	var c, d = sjcl.mode.ocb2.B,
	    e = sjcl.bitArray,
	    f = e.k,
	    g = [0, 0, 0, 0],
	    h = a.encrypt([0, 0, 0, 0]);
	h = f(h, d(d(h)));
	for (c = 0; c + 4 < b.length; c += 4) {
	    h = d(h);
	    g = f(g, a.encrypt(f(h, b.slice(c, c + 4))))
	}
	b = b.slice(c);
	if (e.bitLength(b) < 128) {
	    h = f(h, d(h));
	    b = e.concat(b, [2147483648 | 0, 0,
	    0, 0])
	}
	g = f(g, b);
	return a.encrypt(f(d(f(h, d(h))), g))
    },
    B: function (a) {
	return [a[0] << 1 ^ a[1] >>> 31, a[1] << 1 ^ a[2] >>> 31, a[2] << 1 ^ a[3] >>> 31, a[3] << 1 ^ (a[0] >>> 31) * 135]
    }
};
sjcl.misc.hmac = function (a, b) {
    this.M = b = b || sjcl.hash.sha256;
    var c = [
	[],
	[]
    ],
	d = b.prototype.blockSize / 32;
    this.l = [new b, new b];
    if (a.length > d) a = b.hash(a);
    for (b = 0; b < d; b++) {
	c[0][b] = a[b] ^ 909522486;
	c[1][b] = a[b] ^ 1549556828
    }
    this.l[0].update(c[0]);
    this.l[1].update(c[1])
};
sjcl.misc.hmac.prototype.encrypt = sjcl.misc.hmac.prototype.mac = function (a, b) {
    a = (new this.M(this.l[0])).update(a, b).finalize();
    return (new this.M(this.l[1])).update(a).finalize()
};
sjcl.misc.pbkdf2 = function (a, b, c, d, e) {
    c = c || 1E3;
    if (d < 0 || c < 0) throw sjcl.exception.invalid("invalid params to pbkdf2");
    if (typeof a === "string") a = sjcl.codec.utf8String.toBits(a);
    e = e || sjcl.misc.hmac;
    a = new e(a);
    var f, g, h, i, k = [],
	j = sjcl.bitArray;
    for (i = 1; 32 * k.length < (d || 1); i++) {
	e = f = a.encrypt(j.concat(b, [i]));
	for (g = 1; g < c; g++) {
	    f = a.encrypt(f);
	    for (h = 0; h < f.length; h++) e[h] ^= f[h]
	}
	k = k.concat(e)
    }
    if (d) k = j.clamp(k, d);
    return k
};
sjcl.random = {
    randomWords: function (a, b) {
	var c = [];
	b = this.isReady(b);
	var d;
	if (b === 0) throw new sjcl.exception.notReady("generator isn't seeded");
	else b & 2 && this.U(!(b & 1));
	for (b = 0; b < a; b += 4) {
	    (b + 1) % 0x10000 === 0 && this.L();
	    d = this.w();
	    c.push(d[0], d[1], d[2], d[3])
	}
	this.L();
	return c.slice(0, a)
    },
    setDefaultParanoia: function (a) {
	this.t = a
    },
    addEntropy: function (a, b, c) {
	c = c || "user";
	var d, e, f = (new Date).valueOf(),
	    g = this.q[c],
	    h = this.isReady(),
	    i = 0;
	d = this.G[c];
	if (d === undefined) d = this.G[c] = this.R++;
	if (g === undefined) g = this.q[c] = 0;
	this.q[c] = (this.q[c] + 1) % this.b.length;
	switch (typeof a) {
	    case "number":
		if (b === undefined) b = 1;
		this.b[g].update([d, this.u++, 1, b, f, 1, a | 0]);
		break;
	    case "object":
		c = Object.prototype.toString.call(a);
		if (c === "[object Uint32Array]") {
		    e = [];
		    for (c = 0; c < a.length; c++) e.push(a[c]);
		    a = e
		} else {
		    if (c !== "[object Array]") i = 1;
		    for (c = 0; c < a.length && !i; c++) if (typeof a[c] != "number") i = 1
		}
		if (!i) {
		    if (b === undefined) for (c = b = 0; c < a.length; c++) for (e = a[c]; e > 0;) {
			b++;
			e >>>= 1
		    }
		    this.b[g].update([d, this.u++, 2, b, f, a.length].concat(a))
		}
		break;
	    case "string":
		if (b === undefined) b = a.length;
		this.b[g].update([d, this.u++, 3, b, f, a.length]);
		this.b[g].update(a);
		break;
	    default:
		i = 1
	}
	if (i) throw new sjcl.exception.bug("random: addEntropy only supports number, array of numbers or string");
	this.j[g] += b;
	this.f += b;
	if (h === 0) {
	    this.isReady() !== 0 && this.K("seeded", Math.max(this.g, this.f));
	    this.K("progress", this.getProgress())
	}
    },
    isReady: function (a) {
	a = this.C[a !== undefined ? a : this.t];
	return this.g && this.g >= a ? this.j[0] > 80 && (new Date).valueOf() > this.O ? 3 : 1 : this.f >= a ? 2 : 0
    },
    getProgress: function (a) {
	a = this.C[a ? a : this.t];
	return this.g >= a ? 1 : this.f > a ? 1 : this.f / a
    },
    startCollectors: function () {
	if (!this.m) {
	    if (window.addEventListener) {
		window.addEventListener("load", this.o, false);
		window.addEventListener("mousemove", this.p, false)
	    } else if (document.attachEvent) {
		document.attachEvent("onload", this.o);
		document.attachEvent("onmousemove", this.p)
	    } else throw new sjcl.exception.bug("can't attach event");
	    this.m = true
	}
    },
    stopCollectors: function () {
	if (this.m) {
	    if (window.removeEventListener) {
		window.removeEventListener("load",
		this.o, false);
		window.removeEventListener("mousemove", this.p, false)
	    } else if (window.detachEvent) {
		window.detachEvent("onload", this.o);
		window.detachEvent("onmousemove", this.p)
	    }
	    this.m = false
	}
    },
    addEventListener: function (a, b) {
	this.r[a][this.Q++] = b
    },
    removeEventListener: function (a, b) {
	var c;
	a = this.r[a];
	var d = [];
	for (c in a) a.hasOwnProperty(c) && a[c] === b && d.push(c);
	for (b = 0; b < d.length; b++) {
	    c = d[b];
	    delete a[c]
	}
    },
    b: [new sjcl.hash.sha256],
    j: [0],
    A: 0,
    q: {},
    u: 0,
    G: {},
    R: 0,
    g: 0,
    f: 0,
    O: 0,
    a: [0, 0, 0, 0, 0, 0, 0, 0],
    d: [0, 0, 0, 0],
    s: undefined,
    t: 6,
    m: false,
    r: {
	progress: {},
	seeded: {}
    },
    Q: 0,
    C: [0, 48, 64, 96, 128, 192, 0x100, 384, 512, 768, 1024],
    w: function () {
	for (var a = 0; a < 4; a++) {
	    this.d[a] = this.d[a] + 1 | 0;
	    if (this.d[a]) break
	}
	return this.s.encrypt(this.d)
    },
    L: function () {
	this.a = this.w().concat(this.w());
	this.s = new sjcl.cipher.aes(this.a)
    },
    T: function (a) {
	this.a = sjcl.hash.sha256.hash(this.a.concat(a));
	this.s = new sjcl.cipher.aes(this.a);
	for (a = 0; a < 4; a++) {
	    this.d[a] = this.d[a] + 1 | 0;
	    if (this.d[a]) break
	}
    },
    U: function (a) {
	var b = [],
	    c = 0,
	    d;
	this.O = b[0] = (new Date).valueOf() + 3E4;
	for (d = 0; d < 16; d++) b.push(Math.random() * 0x100000000 | 0);
	for (d = 0; d < this.b.length; d++) {
	    b = b.concat(this.b[d].finalize());
	    c += this.j[d];
	    this.j[d] = 0;
	    if (!a && this.A & 1 << d) break
	}
	if (this.A >= 1 << this.b.length) {
	    this.b.push(new sjcl.hash.sha256);
	    this.j.push(0)
	}
	this.f -= c;
	if (c > this.g) this.g = c;
	this.A++;
	this.T(b)
    },
    p: function (a) {
	sjcl.random.addEntropy([a.x || a.clientX || a.offsetX || 0, a.y || a.clientY || a.offsetY || 0], 2, "mouse")
    },
    o: function () {
	sjcl.random.addEntropy((new Date).valueOf(), 2, "loadtime")
    },
    K: function (a, b) {
	var c;
	a = sjcl.random.r[a];
	var d = [];
	for (c in a) a.hasOwnProperty(c) && d.push(a[c]);
	for (c = 0; c < d.length; c++) d[c](b)
    }
};
try {
    var s = new Uint32Array(32);
    crypto.getRandomValues(s);
    sjcl.random.addEntropy(s, 1024, "crypto['getRandomValues']")
} catch (t) {}
sjcl.json = {
    defaults: {
	v: 1,
	iter: 1E3,
	ks: 128,
	ts: 64,
	mode: "ccm",
	adata: "",
	cipher: "aes"
    },
    encrypt: function (a, b, c, d) {
	c = c || {};
	d = d || {};
	var e = sjcl.json,
	    f = e.c({
		iv: sjcl.random.randomWords(4, 0)
	    }, e.defaults),
	    g;
	e.c(f, c);
	c = f.adata;
	if (typeof f.salt === "string") f.salt = sjcl.codec.base64.toBits(f.salt);
	if (typeof f.iv === "string") f.iv = sjcl.codec.base64.toBits(f.iv);
	if (!sjcl.mode[f.mode] || !sjcl.cipher[f.cipher] || typeof a === "string" && f.iter <= 100 || f.ts !== 64 && f.ts !== 96 && f.ts !== 128 || f.ks !== 128 && f.ks !== 192 && f.ks !== 0x100 || f.iv.length < 2 || f.iv.length > 4) throw new sjcl.exception.invalid("json encrypt: invalid parameters");
	if (typeof a === "string") {
	    g = sjcl.misc.cachedPbkdf2(a, f);
	    a = g.key.slice(0, f.ks / 32);
	    f.salt = g.salt
	}
	if (typeof b === "string") b = sjcl.codec.utf8String.toBits(b);
	if (typeof c === "string") c = sjcl.codec.utf8String.toBits(c);
	g = new sjcl.cipher[f.cipher](a);
	e.c(d, f);
	d.key = a;
	f.ct = sjcl.mode[f.mode].encrypt(g, b, f.iv, c, f.ts);
	return e.encode(f)
    },
    decrypt: function (a, b, c, d) {
	c = c || {};
	d = d || {};
	var e = sjcl.json;
	b = e.c(e.c(e.c({}, e.defaults), e.decode(b)),
	c, true);
	var f;
	c = b.adata;
	if (typeof b.salt === "string") b.salt = sjcl.codec.base64.toBits(b.salt);
	if (typeof b.iv === "string") b.iv = sjcl.codec.base64.toBits(b.iv);
	if (!sjcl.mode[b.mode] || !sjcl.cipher[b.cipher] || typeof a === "string" && b.iter <= 100 || b.ts !== 64 && b.ts !== 96 && b.ts !== 128 || b.ks !== 128 && b.ks !== 192 && b.ks !== 0x100 || !b.iv || b.iv.length < 2 || b.iv.length > 4) throw new sjcl.exception.invalid("json decrypt: invalid parameters");
	if (typeof a === "string") {
	    f = sjcl.misc.cachedPbkdf2(a, b);
	    a = f.key.slice(0, b.ks / 32);
	    b.salt = f.salt
	}
	if (typeof c === "string") c = sjcl.codec.utf8String.toBits(c);
	f = new sjcl.cipher[b.cipher](a);
	c = sjcl.mode[b.mode].decrypt(f, b.ct, b.iv, c, b.ts);
	e.c(d, b);
	d.key = a;
	return sjcl.codec.utf8String.fromBits(c)
    },
    encode: function (a) {
	var b, c = "{",
	    d = "";
	for (b in a) if (a.hasOwnProperty(b)) {
	    if (!b.match(/^[a-z0-9]+$/i)) throw new sjcl.exception.invalid("json encode: invalid property name");
	    c += d + '"' + b + '":';
	    d = ",";
	    switch (typeof a[b]) {
		case "number":
		case "boolean":
		    c += a[b];
		    break;
		case "string":
		    c += '"' + escape(a[b]) + '"';
		    break;
		case "object":
		    c += '"' + sjcl.codec.base64.fromBits(a[b], 1) + '"';
		    break;
		default:
		    throw new sjcl.exception.bug("json encode: unsupported type");
	    }
	}
	return c + "}"
    },
    decode: function (a) {
	a = a.replace(/\s/g, "");
	if (!a.match(/^\{.*\}$/)) throw new sjcl.exception.invalid("json decode: this isn't json!");
	a = a.replace(/^\{|\}$/g, "").split(/,/);
	var b = {}, c, d;
	for (c = 0; c < a.length; c++) {
	    if (!(d = a[c].match(/^(?:(["']?)([a-z][a-z0-9]*)\1):(?:(\d+)|"([a-z0-9+\/%*_.@=\-]*)")$/i))) throw new sjcl.exception.invalid("json decode: this isn't json!");
	    b[d[2]] = d[3] ? parseInt(d[3], 10) : d[2].match(/^(ct|salt|iv)$/) ? sjcl.codec.base64.toBits(d[4]) : unescape(d[4])
	}
	return b
    },
    c: function (a, b, c) {
	if (a === undefined) a = {};
	if (b === undefined) return a;
	var d;
	for (d in b) if (b.hasOwnProperty(d)) {
	    if (c && a[d] !== undefined && a[d] !== b[d]) throw new sjcl.exception.invalid("required parameter overridden");
	    a[d] = b[d]
	}
	return a
    },
    W: function (a, b) {
	var c = {}, d;
	for (d in a) if (a.hasOwnProperty(d) && a[d] !== b[d]) c[d] = a[d];
	return c
    },
    V: function (a, b) {
	var c = {}, d;
	for (d = 0; d < b.length; d++) if (a[b[d]] !== undefined) c[b[d]] = a[b[d]];
	return c
    }
};
sjcl.encrypt = sjcl.json.encrypt;
sjcl.decrypt = sjcl.json.decrypt;
sjcl.misc.S = {};
sjcl.misc.cachedPbkdf2 = function (a, b) {
    var c = sjcl.misc.S,
	d;
    b = b || {};
    d = b.iter || 1E3;
    c = c[a] = c[a] || {};
    d = c[d] = c[d] || {
	firstSalt: b.salt && b.salt.length ? b.salt.slice(0) : sjcl.random.randomWords(2, 0)
    };
    c = b.salt === undefined ? d.firstSalt : b.salt;
    d[c] = d[c] || sjcl.misc.pbkdf2(a, c, b.iter);
    return {
	key: d[c].slice(0),
	salt: c.slice(0)
    }
};

//SHA512.js begins (also from SJCL)
/** @fileOverview Javascript SHA-512 implementation.
 *
 * This implementation was written for CryptoJS by Jeff Mott and adapted for
 * SJCL by Stefan Thomas.
 *
 * CryptoJS (c) 2009-2012 by Jeff Mott. All rights reserved.
 * Released with New BSD License
 */

/**
 * Context for a SHA-512 operation in progress.
 * @constructor
 * @class Secure Hash Algorithm, 512 bits.
 */
sjcl.hash.sha512 = function (hash) {
  if (!this._key[0]) { this._precompute(); }
  if (hash) {
    this._h = hash._h.slice(0);
    this._buffer = hash._buffer.slice(0);
    this._length = hash._length;
  } else {
    this.reset();
  }
};

/**
 * Hash a string or an array of words.
 * @static
 * @param {bitArray|String} data the data to hash.
 * @return {bitArray} The hash value, an array of 16 big-endian words.
 */
sjcl.hash.sha512.hash = function (data) {
  return (new sjcl.hash.sha512()).update(data).finalize();
};

sjcl.hash.sha512.prototype = {
  /**
   * The hash's block size, in bits.
   * @constant
   */
  blockSize: 1024,
   
  /**
   * Reset the hash state.
   * @return this
   */
  reset:function () {
    this._h = this._init.slice(0);
    this._buffer = [];
    this._length = 0;
    return this;
  },
  
  /**
   * Input several words to the hash.
   * @param {bitArray|String} data the data to hash.
   * @return this
   */
  update: function (data) {
    if (typeof data === "string") {
      data = sjcl.codec.utf8String.toBits(data);
    }
    var i, b = this._buffer = sjcl.bitArray.concat(this._buffer, data),
        ol = this._length,
        nl = this._length = ol + sjcl.bitArray.bitLength(data);
    for (i = 1024+ol & -1024; i <= nl; i+= 1024) {
      this._block(b.splice(0,32));
    }
    return this;
  },
  
  /**
   * Complete hashing and output the hash value.
   * @return {bitArray} The hash value, an array of 16 big-endian words.
   */
  finalize:function () {
    var i, b = this._buffer, h = this._h;

    // Round out and push the buffer
    b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1,1)]);

    // Round out the buffer to a multiple of 32 words, less the 4 length words.
    for (i = b.length + 4; i & 31; i++) {
      b.push(0);
    }

    // append the length
    b.push(0);
    b.push(0);
    b.push(Math.floor(this._length / 0x100000000));
    b.push(this._length | 0);

    while (b.length) {
      this._block(b.splice(0,32));
    }

    this.reset();
    return h;
  },

  /**
   * The SHA-512 initialization vector, to be precomputed.
   * @private
   */
  _init:[],

  /**
   * Least significant 24 bits of SHA512 initialization values.
   *
   * Javascript only has 53 bits of precision, so we compute the 40 most
   * significant bits and add the remaining 24 bits as constants.
   *
   * @private
   */
  _initr: [ 0xbcc908, 0xcaa73b, 0x94f82b, 0x1d36f1, 0xe682d1, 0x3e6c1f, 0x41bd6b, 0x7e2179 ],

   /**
   * The SHA-512 hash key, to be precomputed.
   * @private
   */
  _key:[],

  /**
   * Least significant 24 bits of SHA512 key values.
   * @private
   */
  _keyr:
  [0x28ae22, 0xef65cd, 0x4d3b2f, 0x89dbbc, 0x48b538, 0x05d019, 0x194f9b, 0x6d8118,
   0x030242, 0x706fbe, 0xe4b28c, 0xffb4e2, 0x7b896f, 0x1696b1, 0xc71235, 0x692694,
   0xf14ad2, 0x4f25e3, 0x8cd5b5, 0xac9c65, 0x2b0275, 0xa6e483, 0x41fbd4, 0x1153b5,
   0x66dfab, 0xb43210, 0xfb213f, 0xef0ee4, 0xa88fc2, 0x0aa725, 0x03826f, 0x0e6e70,
   0xd22ffc, 0x26c926, 0xc42aed, 0x95b3df, 0xaf63de, 0x77b2a8, 0xedaee6, 0x82353b,
   0xf10364, 0x423001, 0xf89791, 0x54be30, 0xef5218, 0x65a910, 0x71202a, 0xbbd1b8,
   0xd2d0c8, 0x41ab53, 0x8eeb99, 0x9b48a8, 0xc95a63, 0x418acb, 0x63e373, 0xb2b8a3,
   0xefb2fc, 0x172f60, 0xf0ab72, 0x6439ec, 0x631e28, 0x82bde9, 0xc67915, 0x72532b,
   0x26619c, 0xc0c207, 0xe0eb1e, 0x6ed178, 0x176fba, 0xc898a6, 0xf90dae, 0x1c471b,
   0x047d84, 0xc72493, 0xc9bebc, 0x100d4c, 0x3e42b6, 0x657e2a, 0xd6faec, 0x475817],

  /**
   * Function to precompute _init and _key.
   * @private
   */
  _precompute: function () {
    // XXX: This code is for precomputing the SHA256 constants, change for
    //      SHA512 and re-enable.
    var i = 0, prime = 2, factor;

    function frac(x)  { return (x-Math.floor(x)) * 0x100000000 | 0; }
    function frac2(x) { return (x-Math.floor(x)) * 0x10000000000 & 0xff; }

    outer: for (; i<80; prime++) {
      for (factor=2; factor*factor <= prime; factor++) {
        if (prime % factor === 0) {
          // not a prime
          continue outer;
        }
      }

      if (i<8) {
        this._init[i*2] = frac(Math.pow(prime, 1/2));
        this._init[i*2+1] = (frac2(Math.pow(prime, 1/2)) << 24) | this._initr[i];
      }
      this._key[i*2] = frac(Math.pow(prime, 1/3));
      this._key[i*2+1] = (frac2(Math.pow(prime, 1/3)) << 24) | this._keyr[i];
      i++;
    }
  },

  /**
   * Perform one cycle of SHA-512.
   * @param {bitArray} words one block of words.
   * @private
   */
  _block:function (words) {
    var i, wrh, wrl,
        w = words.slice(0),
        h = this._h,
        k = this._key,
        h0h = h[ 0], h0l = h[ 1], h1h = h[ 2], h1l = h[ 3],
        h2h = h[ 4], h2l = h[ 5], h3h = h[ 6], h3l = h[ 7],
        h4h = h[ 8], h4l = h[ 9], h5h = h[10], h5l = h[11],
        h6h = h[12], h6l = h[13], h7h = h[14], h7l = h[15];

    // Working variables
    var ah = h0h, al = h0l, bh = h1h, bl = h1l,
        ch = h2h, cl = h2l, dh = h3h, dl = h3l,
        eh = h4h, el = h4l, fh = h5h, fl = h5l,
        gh = h6h, gl = h6l, hh = h7h, hl = h7l;

    for (i=0; i<80; i++) {
      // load up the input word for this round
      if (i<16) {
        wrh = w[i * 2];
        wrl = w[i * 2 + 1];
      } else {
        // Gamma0
        var gamma0xh = w[(i-15) * 2];
        var gamma0xl = w[(i-15) * 2 + 1];
        var gamma0h =
          ((gamma0xl << 31) | (gamma0xh >>> 1)) ^
          ((gamma0xl << 24) | (gamma0xh >>> 8)) ^
           (gamma0xh >>> 7);
        var gamma0l =
          ((gamma0xh << 31) | (gamma0xl >>> 1)) ^
          ((gamma0xh << 24) | (gamma0xl >>> 8)) ^
          ((gamma0xh << 25) | (gamma0xl >>> 7));

        // Gamma1
        var gamma1xh = w[(i-2) * 2];
        var gamma1xl = w[(i-2) * 2 + 1];
        var gamma1h =
          ((gamma1xl << 13) | (gamma1xh >>> 19)) ^
          ((gamma1xh << 3)  | (gamma1xl >>> 29)) ^
           (gamma1xh >>> 6);
        var gamma1l =
          ((gamma1xh << 13) | (gamma1xl >>> 19)) ^
          ((gamma1xl << 3)  | (gamma1xh >>> 29)) ^
          ((gamma1xh << 26) | (gamma1xl >>> 6));

        // Shortcuts
        var wr7h = w[(i-7) * 2];
        var wr7l = w[(i-7) * 2 + 1];

        var wr16h = w[(i-16) * 2];
        var wr16l = w[(i-16) * 2 + 1];

        // W(round) = gamma0 + W(round - 7) + gamma1 + W(round - 16)
        wrl = gamma0l + wr7l;
        wrh = gamma0h + wr7h + ((wrl >>> 0) < (gamma0l >>> 0) ? 1 : 0);
        wrl += gamma1l;
        wrh += gamma1h + ((wrl >>> 0) < (gamma1l >>> 0) ? 1 : 0);
        wrl += wr16l;
        wrh += wr16h + ((wrl >>> 0) < (wr16l >>> 0) ? 1 : 0);
      }

      w[i*2]     = wrh |= 0;
      w[i*2 + 1] = wrl |= 0;

      // Ch
      var chh = (eh & fh) ^ (~eh & gh);
      var chl = (el & fl) ^ (~el & gl);

      // Maj
      var majh = (ah & bh) ^ (ah & ch) ^ (bh & ch);
      var majl = (al & bl) ^ (al & cl) ^ (bl & cl);

      // Sigma0
      var sigma0h = ((al << 4) | (ah >>> 28)) ^ ((ah << 30) | (al >>> 2)) ^ ((ah << 25) | (al >>> 7));
      var sigma0l = ((ah << 4) | (al >>> 28)) ^ ((al << 30) | (ah >>> 2)) ^ ((al << 25) | (ah >>> 7));

      // Sigma1
      var sigma1h = ((el << 18) | (eh >>> 14)) ^ ((el << 14) | (eh >>> 18)) ^ ((eh << 23) | (el >>> 9));
      var sigma1l = ((eh << 18) | (el >>> 14)) ^ ((eh << 14) | (el >>> 18)) ^ ((el << 23) | (eh >>> 9));

      // K(round)
      var krh = k[i*2];
      var krl = k[i*2+1];

      // t1 = h + sigma1 + ch + K(round) + W(round)
      var t1l = hl + sigma1l;
      var t1h = hh + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0);
      t1l += chl;
      t1h += chh + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0);
      t1l += krl;
      t1h += krh + ((t1l >>> 0) < (krl >>> 0) ? 1 : 0);
      t1l += wrl;
      t1h += wrh + ((t1l >>> 0) < (wrl >>> 0) ? 1 : 0);

      // t2 = sigma0 + maj
      var t2l = sigma0l + majl;
      var t2h = sigma0h + majh + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0);

      // Update working variables
      hh = gh;
      hl = gl;
      gh = fh;
      gl = fl;
      fh = eh;
      fl = el;
      el = (dl + t1l) | 0;
      eh = (dh + t1h + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;
      dh = ch;
      dl = cl;
      ch = bh;
      cl = bl;
      bh = ah;
      bl = al;
      al = (t1l + t2l) | 0;
      ah = (t1h + t2h + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0;
    }

    // Intermediate hash
    h0l = h[1] = (h0l + al) | 0;
    h[0] = (h0h + ah + ((h0l >>> 0) < (al >>> 0) ? 1 : 0)) | 0;
    h1l = h[3] = (h1l + bl) | 0;
    h[2] = (h1h + bh + ((h1l >>> 0) < (bl >>> 0) ? 1 : 0)) | 0;
    h2l = h[5] = (h2l + cl) | 0;
    h[4] = (h2h + ch + ((h2l >>> 0) < (cl >>> 0) ? 1 : 0)) | 0;
    h3l = h[7] = (h3l + dl) | 0;
    h[6] = (h3h + dh + ((h3l >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;
    h4l = h[9] = (h4l + el) | 0;
    h[8] = (h4h + eh + ((h4l >>> 0) < (el >>> 0) ? 1 : 0)) | 0;
    h5l = h[11] = (h5l + fl) | 0;
    h[10] = (h5h + fh + ((h5l >>> 0) < (fl >>> 0) ? 1 : 0)) | 0;
    h6l = h[13] = (h6l + gl) | 0;
    h[12] = (h6h + gh + ((h6l >>> 0) < (gl >>> 0) ? 1 : 0)) | 0;
    h7l = h[15] = (h7l + hl) | 0;
    h[14] = (h7h + hh + ((h7l >>> 0) < (hl >>> 0) ? 1 : 0)) | 0;
  }
};
//SHA512.js ends

//SJCL-SCRYPT.JS, by joe-invincible begins
var B, X, SIZE_MAX = Math.pow(2, 32) - 1;

sjcl.misc.scrypt = function(passwd, salt, N, r, p, dkLen) {

  function flipEndian(x) {
    var first = x & 0xFF;
    var second = (x >>> 8) & 0xFF;
    var third = (x >>> 16) & 0xFF;
    var fourth = (x >>> 24) & 0xFF;
    return (first << 24) | (second << 16) | (third << 8) | fourth;
  }
  
  function sanityCheck() {
    if (r * p >= Math.pow(2, 30)) {
      throw "The parameters r, p must satisfy r * p < 2^30";
    }
    if ((N < 2) || (N & (N - 1) != 0)) {
      throw "The parameter N must be a power of 2.";
    }
    SIZE_MAX = Math.pow(2, 32) - 1;
    if (N > SIZE_MAX / 128 / r) {
    throw "N too big.";
    }
    if (r > SIZE_MAX / 128 / p) {
      throw "r too big.";
    }
  }

  function scrypt(passwd, salt, N, r, p, dkLen) {
    B = sjcl.misc.pbkdf2(passwd, salt, 1, p * 128 * r * 8);
    var V = []; 
    var XY = [];
    for (var i = 0; i < p; i++) {
      smix(B, i * 128 * r, r, N, V, XY);
    }
    return sjcl.misc.pbkdf2(passwd, B, 1, dkLen * 8);
  };

  function salsa20_8(B) {

    function R(a, b) {
      return (a << b) | (a >>> (32 - b));
    }
    
    var B32 = [];
    for (var i = 0; i < 16; i++) {
      B32[i] = flipEndian(B[i]);  
    }
  
    var x = [];
    for (var i = 0; i < 16; i++) {
      x[i] = B32[i] | 0;
    }
  
    for (i = 8; i > 0; i -= 2) {
      x[4] ^= R(x[0] + x[12], 7);
      x[8] ^= R(x[4] + x[0], 9);
      x[12] ^= R(x[8] + x[4], 13);
      x[0] ^= R(x[12] + x[8], 18);
      x[9] ^= R(x[5] + x[1], 7);
      x[13] ^= R(x[9] + x[5], 9);
      x[1] ^= R(x[13] + x[9], 13);
      x[5] ^= R(x[1] + x[13], 18);
      x[14] ^= R(x[10] + x[6], 7);
      x[2] ^= R(x[14] + x[10], 9);
      x[6] ^= R(x[2] + x[14], 13);
      x[10] ^= R(x[6] + x[2], 18);
      x[3] ^= R(x[15] + x[11], 7);
      x[7] ^= R(x[3] + x[15], 9);
      x[11] ^= R(x[7] + x[3], 13);
      x[15] ^= R(x[11] + x[7], 18);
      x[1] ^= R(x[0] + x[3], 7);
      x[2] ^= R(x[1] + x[0], 9);
      x[3] ^= R(x[2] + x[1], 13);
      x[0] ^= R(x[3] + x[2], 18);
      x[6] ^= R(x[5] + x[4], 7);
      x[7] ^= R(x[6] + x[5], 9);
      x[4] ^= R(x[7] + x[6], 13);
      x[5] ^= R(x[4] + x[7], 18);
      x[11] ^= R(x[10] + x[9], 7);
      x[8] ^= R(x[11] + x[10], 9);
      x[9] ^= R(x[8] + x[11], 13);
      x[10] ^= R(x[9] + x[8], 18);
      x[12] ^= R(x[15] + x[14], 7);
      x[13] ^= R(x[12] + x[15], 9);
      x[14] ^= R(x[13] + x[12], 13);
      x[15] ^= R(x[14] + x[13], 18);
    }
  
    for (var i = 0; i < 16; i++) {
      B32[i] = (B32[i] + x[i]) | 0;
    }
    
    for (var i = 0; i < 16; i++) {
      B[i] = flipEndian(B32[i]);  
    }
  
    return B;
  }

  function blockxor(S, Si, D, Di, len) {
    len /= 4;
    Si /= 4;
    Di /= 4;
    for (var i = 0; i < len; i++) {
      D[Di + i] ^= S[Si + i] | 0;
    }
  }
  
  function blockcopy(S, Si, D, Di, len) {
    len /= 4;
    Si /= 4;
    Di /= 4;
    for (var i = 0; i < len; i++) {
      D[Di + i] = S[Si + i] | 0;
    }
  }
  
  function blockmix_salsa8(BY, Bi, Yi, r) {
    X = [];
    var i;
  
    blockcopy(BY, Bi + (2 * r - 1) * 64, X, 0, 64);
  
    for (i = 0; i < 2 * r; i++) {
        blockxor(BY, i * 64, X, 0, 64);
        salsa20_8(X);
        blockcopy(X, 0, BY, Yi + (i * 64), 64);
    }
  
    for (i = 0; i < r; i++) {
        blockcopy(BY, Yi + (i * 2) * 64, BY, Bi + (i * 64), 64);
    }
  
    for (i = 0; i < r; i++) {
        blockcopy(BY, Yi + (i * 2 + 1) * 64, BY, Bi + (i + r) * 64, 64);
    }
  }
  
  function smix(B, Bi, r, N, V, XY) {
    var Xi = 0;
    var Yi = 128 * r;
    var i;
  
    blockcopy(B, Bi, XY, Xi, Yi);
  
    for (i = 0; i < N; i++) {
      blockcopy(XY, Xi, V, i * Yi, Yi);
      blockmix_salsa8(XY, Xi, Yi, r);
    }
  
    for (i = 0; i < N; i++) {
      var j = integerify(XY, Xi, r) & (N - 1);
      blockxor(V, j * Yi, XY, Xi, Yi);
      blockmix_salsa8(XY, Xi, Yi, r);
    }
  
    blockcopy(XY, Xi, B, Bi, Yi);
  }
  
  function integerify(B, Bi, r) {
    Bi = Bi + (2 * r - 1) * 64;
    return flipEndian(B[Bi / 4]);
  }

  sanityCheck();
  return scrypt(passwd, salt, N, r, p, dkLen);
}
//SJCL-SCRYPT.JS ends

//BN.js begins (also from SJCL)
/**
 * Constructs a new bignum from another bignum, a number or a hex string.
 */
sjcl.bn = function(it) {
  this.initWith(it);
};

sjcl.bn.prototype = {
  radix: 24,
  maxMul: 8,
  _class: sjcl.bn,
  
  copy: function() {
    return new this._class(this);
  },

  /**
   * Initializes this with it, either as a bn, a number, or a hex string.
   */
  initWith: function(it) {
    var i=0, k, n, l;
    switch(typeof it) {
    case "object":
      this.limbs = it.limbs.slice(0);
      break;
      
    case "number":
      this.limbs = [it];
      this.normalize();
      break;
      
    case "string":
      it = it.replace(/^0x/, '');
      this.limbs = [];
      // hack
      k = this.radix / 4;
      for (i=0; i < it.length; i+=k) {
	this.limbs.push(parseInt(it.substring(Math.max(it.length - i - k, 0), it.length - i),16));
      }
      break;

    default:
      this.limbs = [0];
    }
    return this;
  },

  /**
   * Returns true if "this" and "that" are equal.  Calls fullReduce().
   * Equality test is in constant time.
   */
  equals: function(that) {
    if (typeof that === "number") { that = new this._class(that); }
    var difference = 0, i;
    this.fullReduce();
    that.fullReduce();
    for (i = 0; i < this.limbs.length || i < that.limbs.length; i++) {
      difference |= this.getLimb(i) ^ that.getLimb(i);
    }
    return (difference === 0);
  },
  
  /**
   * Get the i'th limb of this, zero if i is too large.
   */
  getLimb: function(i) {
    return (i >= this.limbs.length) ? 0 : this.limbs[i];
  },
  
  /**
   * Constant time comparison function.
   * Returns 1 if this >= that, or zero otherwise.
   */
  greaterEquals: function(that) {
    if (typeof that === "number") { that = new this._class(that); }
    var less = 0, greater = 0, i, a, b;
    i = Math.max(this.limbs.length, that.limbs.length) - 1;
    for (; i>= 0; i--) {
      a = this.getLimb(i);
      b = that.getLimb(i);
      greater |= (b - a) & ~less;
      less |= (a - b) & ~greater;
    }
    return (greater | ~less) >>> 31;
  },
  
  /**
   * Convert to a hex string.
   */
  toString: function() {
    this.fullReduce();
    var out="", i, s, l = this.limbs;
    for (i=0; i < this.limbs.length; i++) {
      s = l[i].toString(16);
      while (i < this.limbs.length - 1 && s.length < 6) {
	s = "0" + s;
      }
      out = s + out;
    }
    return "0x"+out;
  },
  
  /** this += that.  Does not normalize. */
  addM: function(that) {
    if (typeof(that) !== "object") { that = new this._class(that); }
    var i, l=this.limbs, ll=that.limbs;
    for (i=l.length; i<ll.length; i++) {
      l[i] = 0;
    }
    for (i=0; i<ll.length; i++) {
      l[i] += ll[i];
    }
    return this;
  },
  
  /** this *= 2.  Requires normalized; ends up normalized. */
  doubleM: function() {
    var i, carry=0, tmp, r=this.radix, m=this.radixMask, l=this.limbs;
    for (i=0; i<l.length; i++) {
      tmp = l[i];
      tmp = tmp+tmp+carry;
      l[i] = tmp & m;
      carry = tmp >> r;
    }
    if (carry) {
      l.push(carry);
    }
    return this;
  },
  
  /** this /= 2, rounded down.	Requires normalized; ends up normalized. */
  halveM: function() {
    var i, carry=0, tmp, r=this.radix, l=this.limbs;
    for (i=l.length-1; i>=0; i--) {
      tmp = l[i];
      l[i] = (tmp+carry)>>1;
      carry = (tmp&1) << r;
    }
    if (!l[l.length-1]) {
      l.pop();
    }
    return this;
  },

  /** this -= that.  Does not normalize. */
  subM: function(that) {
    if (typeof(that) !== "object") { that = new this._class(that); }
    var i, l=this.limbs, ll=that.limbs;
    for (i=l.length; i<ll.length; i++) {
      l[i] = 0;
    }
    for (i=0; i<ll.length; i++) {
      l[i] -= ll[i];
    }
    return this;
  },
  
  mod: function(that) {
    that = new sjcl.bn(that).normalize(); // copy before we begin
    var out = new sjcl.bn(this).normalize(), ci=0;
    
    for (; out.greaterEquals(that); ci++) {

      that.doubleM();
    }
    for (; ci > 0; ci--) {
      that.halveM();
      if (out.greaterEquals(that)) {
	out.subM(that).normalize();
      }
    }
    return out.trim();
  },
  
  /** return inverse mod prime p.  p must be odd. Binary extended Euclidean algorithm mod p. */
  inverseMod: function(p) {
    var a = new sjcl.bn(1), b = new sjcl.bn(0), x = new sjcl.bn(this), y = new sjcl.bn(p), tmp, i, nz=1;
    
    if (!(p.limbs[0] & 1)) {
      throw (new sjcl.exception.invalid("inverseMod: p must be odd"));
    }
    
    // invariant: y is odd
    do {
      if (x.limbs[0] & 1) {
	if (!x.greaterEquals(y)) {
	  // x < y; swap everything
	  tmp = x; x = y; y = tmp;
	  tmp = a; a = b; b = tmp;
	}
	x.subM(y);
	x.normalize();
	
	if (!a.greaterEquals(b)) {
	  a.addM(p);
	}
	a.subM(b);
      }
      
      // cut everything in half
      x.halveM();
      if (a.limbs[0] & 1) {
	a.addM(p);
      }
      a.normalize();
      a.halveM();
      
      // check for termination: x ?= 0
      for (i=nz=0; i<x.limbs.length; i++) {
	nz |= x.limbs[i];
      }
    } while(nz);
    
    if (!y.equals(1)) {
      throw (new sjcl.exception.invalid("inverseMod: p and x must be relatively prime"));
    }
    
    return b;
  },
  
  /** this + that.  Does not normalize. */
  add: function(that) {
    return this.copy().addM(that);
  },

  /** this - that.  Does not normalize. */
  sub: function(that) {
    return this.copy().subM(that);
  },
  
  /** this * that.  Normalizes and reduces. */
  mul: function(that) {
    if (typeof(that) === "number") { that = new this._class(that); }
    var i, j, a = this.limbs, b = that.limbs, al = a.length, bl = b.length, out = new this._class(), c = out.limbs, ai, ii=this.maxMul;

    for (i=0; i < this.limbs.length + that.limbs.length + 1; i++) {
      c[i] = 0;
    }
    for (i=0; i<al; i++) {
      ai = a[i];
      for (j=0; j<bl; j++) {
	c[i+j] += ai * b[j];
      }
     
      if (!--ii) {
	ii = this.maxMul;
	out.cnormalize();
      }
    }
    return out.cnormalize().reduce();
  },

  /** this ^ 2.  Normalizes and reduces. */
  square: function() {
    return this.mul(this);
  },

  /** this ^ n.  Uses square-and-multiply.  Normalizes and reduces. */
  power: function(l) {
    if (typeof(l) === "number") {
      l = [l];
    } else if (l.limbs !== undefined) {
      l = l.normalize().limbs;
    }
    var i, j, out = new this._class(1), pow = this;

    for (i=0; i<l.length; i++) {
      for (j=0; j<this.radix; j++) {
	if (l[i] & (1<<j)) {
	  out = out.mul(pow);
	}
	pow = pow.square();
      }
    }
    
    return out;
  },

  /** this * that mod N */
  mulmod: function(that, N) {
    return this.mod(N).mul(that.mod(N)).mod(N);
  },

  /** this ^ x mod N */
  powermod: function(x, N) {
    var result = new sjcl.bn(1), a = new sjcl.bn(this), k = new sjcl.bn(x);
    while (true) {
      if (k.limbs[0] & 1) { result = result.mulmod(a, N); }
      k.halveM();
      if (k.equals(0)) { break; }
      a = a.mulmod(a, N);
    }
    return result.normalize().reduce();
  },

  trim: function() {
    var l = this.limbs, p;
    do {
      p = l.pop();
    } while (l.length && p === 0);
    l.push(p);
    return this;
  },
  
  /** Reduce mod a modulus.  Stubbed for subclassing. */
  reduce: function() {
    return this;
  },

  /** Reduce and normalize. */
  fullReduce: function() {
    return this.normalize();
  },
  
  /** Propagate carries. */
  normalize: function() {
    var carry=0, i, pv = this.placeVal, ipv = this.ipv, l, m, limbs = this.limbs, ll = limbs.length, mask = this.radixMask;
    for (i=0; i < ll || (carry !== 0 && carry !== -1); i++) {
      l = (limbs[i]||0) + carry;
      m = limbs[i] = l & mask;
      carry = (l-m)*ipv;
    }
    if (carry === -1) {
      limbs[i-1] -= this.placeVal;
    }
    return this;
  },

  /** Constant-time normalize. Does not allocate additional space. */
  cnormalize: function() {
    var carry=0, i, ipv = this.ipv, l, m, limbs = this.limbs, ll = limbs.length, mask = this.radixMask;
    for (i=0; i < ll-1; i++) {
      l = limbs[i] + carry;
      m = limbs[i] = l & mask;
      carry = (l-m)*ipv;
    }
    limbs[i] += carry;
    return this;
  },
  
  /** Serialize to a bit array */
  toBits: function(len) {
    this.fullReduce();
    len = len || this.exponent || this.limbs.length * this.radix;
    var i = Math.floor((len-1)/24), w=sjcl.bitArray, e = (len + 7 & -8) % this.radix || this.radix,
	out = [w.partial(e, this.getLimb(i))];
    for (i--; i >= 0; i--) {
      out = w.concat(out, [w.partial(this.radix, this.getLimb(i))]);
    }
    return out;
  },
  
  /** Return the length in bits, rounded up to the nearest byte. */
  bitLength: function() {
    this.fullReduce();
    var out = this.radix * (this.limbs.length - 1),
	b = this.limbs[this.limbs.length - 1];
    for (; b; b >>= 1) {
      out ++;
    }
    return out+7 & -8;
  }
};

sjcl.bn.fromBits = function(bits) {
  var Class = this, out = new Class(), words=[], w=sjcl.bitArray, t = this.prototype,
      l = Math.min(this.bitLength || 0x100000000, w.bitLength(bits)), e = l % t.radix || t.radix;
  
  words[0] = w.extract(bits, 0, e);
  for (; e < l; e += t.radix) {
    words.unshift(w.extract(bits, e, t.radix));
  }

  out.limbs = words;
  return out;
};

sjcl.bn.prototype.ipv = 1 / (sjcl.bn.prototype.placeVal = Math.pow(2,sjcl.bn.prototype.radix));
sjcl.bn.prototype.radixMask = (1 << sjcl.bn.prototype.radix) - 1;

/**
 * Creates a new subclass of bn, based on reduction modulo a pseudo-Mersenne prime,
 * i.e. a prime of the form 2^e + sum(a * 2^b),where the sum is negative and sparse.
 */
sjcl.bn.pseudoMersennePrime = function(exponent, coeff) {
  function p(it) {
    this.initWith(it);
    /*if (this.limbs[this.modOffset]) {
      this.reduce();
    }*/
  }

  var ppr = p.prototype = new sjcl.bn(), i, tmp, mo;
  mo = ppr.modOffset = Math.ceil(tmp = exponent / ppr.radix);
  ppr.exponent = exponent;
  ppr.offset = [];
  ppr.factor = [];
  ppr.minOffset = mo;
  ppr.fullMask = 0;
  ppr.fullOffset = [];
  ppr.fullFactor = [];
  ppr.modulus = p.modulus = new sjcl.bn(Math.pow(2,exponent));
  
  ppr.fullMask = 0|-Math.pow(2, exponent % ppr.radix);

  for (i=0; i<coeff.length; i++) {
    ppr.offset[i] = Math.floor(coeff[i][0] / ppr.radix - tmp);
    ppr.fullOffset[i] = Math.ceil(coeff[i][0] / ppr.radix - tmp);
    ppr.factor[i] = coeff[i][1] * Math.pow(1/2, exponent - coeff[i][0] + ppr.offset[i] * ppr.radix);
    ppr.fullFactor[i] = coeff[i][1] * Math.pow(1/2, exponent - coeff[i][0] + ppr.fullOffset[i] * ppr.radix);
    ppr.modulus.addM(new sjcl.bn(Math.pow(2,coeff[i][0])*coeff[i][1]));
    ppr.minOffset = Math.min(ppr.minOffset, -ppr.offset[i]); // conservative
  }
  ppr._class = p;
  ppr.modulus.cnormalize();

  /** Approximate reduction mod p.  May leave a number which is negative or slightly larger than p. */
  ppr.reduce = function() {
    var i, k, l, mo = this.modOffset, limbs = this.limbs, aff, off = this.offset, ol = this.offset.length, fac = this.factor, ll;

    i = this.minOffset;
    while (limbs.length > mo) {
      l = limbs.pop();
      ll = limbs.length;
      for (k=0; k<ol; k++) {
	limbs[ll+off[k]] -= fac[k] * l;
      }
      
      i--;
      if (!i) {
	limbs.push(0);
	this.cnormalize();
	i = this.minOffset;
      }
    }
    this.cnormalize();

    return this;
  };
  
  ppr._strongReduce = (ppr.fullMask === -1) ? ppr.reduce : function() {
    var limbs = this.limbs, i = limbs.length - 1, k, l;
    this.reduce();
    if (i === this.modOffset - 1) {
      l = limbs[i] & this.fullMask;
      limbs[i] -= l;
      for (k=0; k<this.fullOffset.length; k++) {
	limbs[i+this.fullOffset[k]] -= this.fullFactor[k] * l;
      }
      this.normalize();
    }
  };

  /** mostly constant-time, very expensive full reduction. */
  ppr.fullReduce = function() {
    var greater, i;
    // massively above the modulus, may be negative
    
    this._strongReduce();
    // less than twice the modulus, may be negative

    this.addM(this.modulus);
    this.addM(this.modulus);
    this.normalize();
    // probably 2-3x the modulus
    
    this._strongReduce();
    // less than the power of 2.  still may be more than
    // the modulus

    // HACK: pad out to this length
    for (i=this.limbs.length; i<this.modOffset; i++) {
      this.limbs[i] = 0;
    }
    
    // constant-time subtract modulus
    greater = this.greaterEquals(this.modulus);
    for (i=0; i<this.limbs.length; i++) {
      this.limbs[i] -= this.modulus.limbs[i] * greater;
    }
    this.cnormalize();

    return this;
  };

  ppr.inverse = function() {
    return (this.power(this.modulus.sub(2)));
  };

  p.fromBits = sjcl.bn.fromBits;

  return p;
};

// a small Mersenne prime
sjcl.bn.prime = {
  // NIST primes
  p192: sjcl.bn.pseudoMersennePrime(192, [[0,-1],[64,-1]]),
  p224: sjcl.bn.pseudoMersennePrime(224, [[0,1],[96,-1]]),
  p256: sjcl.bn.pseudoMersennePrime(256, [[0,-1],[96,1],[192,1],[224,-1]]),
  p384: sjcl.bn.pseudoMersennePrime(384, [[0,-1],[32,1],[96,-1],[128,-1]]),
  p521: sjcl.bn.pseudoMersennePrime(521, [[0,-1]])
};

sjcl.bn.random = function(modulus, paranoia) {
  if (typeof modulus !== "object") { modulus = new sjcl.bn(modulus); }
  var words, i, l = modulus.limbs.length, m = modulus.limbs[l-1]+1, out = new sjcl.bn();
  while (true) {
    // get a sequence whose first digits make sense
    do {
      words = sjcl.random.randomWords(l, paranoia);
      if (words[l-1] < 0) { words[l-1] += 0x100000000; }
    } while (Math.floor(words[l-1] / m) === Math.floor(0x100000000 / m));
    words[l-1] %= m;

    // mask off all the limbs
    for (i=0; i<l-1; i++) {
      words[i] &= modulus.radixMask;
    }

    // check the rest of the digitssj
    out.limbs = words;
    if (!out.greaterEquals(modulus)) {
      return out;
    }
  }
};

//ECC.js begins
//F. Ruiz: I added the 521-bit curve, took out elGamal etc. at the end, replaced by my own functions. Modifications are noted)

sjcl.ecc = {};

/**
 * Represents a point on a curve in affine coordinates.
 * @constructor
 * @param {sjcl.ecc.curve} curve The curve that this point lies on.
 * @param {bigInt} x The x coordinate.
 * @param {bigInt} y The y coordinate.
 */
sjcl.ecc.point = function(curve,x,y) {
  if (x === undefined) {
    this.isIdentity = true;
  } else {
    this.x = x;
    this.y = y;
    this.isIdentity = false;
  }
  this.curve = curve;
};

sjcl.ecc.point.prototype = {
  toJac: function() {
    return new sjcl.ecc.pointJac(this.curve, this.x, this.y, new this.curve.field(1));
  },

  mult: function(k) {
    return this.toJac().mult(k, this).toAffine();
  },
  
  /**
   * Multiply this point by k, added to affine2*k2, and return the answer in Jacobian coordinates.
   * @param {bigInt} k The coefficient to multiply this by.
   * @param {bigInt} k2 The coefficient to multiply affine2 this by.
   * @param {sjcl.ecc.point} affine The other point in affine coordinates.
   * @return {sjcl.ecc.pointJac} The result of the multiplication and addition, in Jacobian coordinates.
   */
  mult2: function(k, k2, affine2) {
    return this.toJac().mult2(k, this, k2, affine2).toAffine();
  },
  
  multiples: function() {
    var m, i, j;
    if (this._multiples === undefined) {
      j = this.toJac().doubl();
      m = this._multiples = [new sjcl.ecc.point(this.curve), this, j.toAffine()];
      for (i=3; i<16; i++) {
	j = j.add(this);
	m.push(j.toAffine());
      }
    }
    return this._multiples;
  },

  isValid: function() {
    return this.y.square().equals(this.curve.b.add(this.x.mul(this.curve.a.add(this.x.square()))));
  },

  toBits: function() {
    return sjcl.bitArray.concat(this.x.toBits(), this.y.toBits());
  }
};

/**
 * Represents a point on a curve in Jacobian coordinates. Coordinates can be specified as bigInts or strings (which
 * will be converted to bigInts).
 *
 * @constructor
 * @param {bigInt/string} x The x coordinate.
 * @param {bigInt/string} y The y coordinate.
 * @param {bigInt/string} z The z coordinate.
 * @param {sjcl.ecc.curve} curve The curve that this point lies on.
 */
sjcl.ecc.pointJac = function(curve, x, y, z) {
  if (x === undefined) {
    this.isIdentity = true;
  } else {
    this.x = x;
    this.y = y;
    this.z = z;
    this.isIdentity = false;
  }
  this.curve = curve;
};

sjcl.ecc.pointJac.prototype = {
  /**
   * Adds S and T and returns the result in Jacobian coordinates. Note that S must be in Jacobian coordinates and T must be in affine coordinates.
   * @param {sjcl.ecc.pointJac} S One of the points to add, in Jacobian coordinates.
   * @param {sjcl.ecc.point} T The other point to add, in affine coordinates.
   * @return {sjcl.ecc.pointJac} The sum of the two points, in Jacobian coordinates. 
   */
  add: function(T) {
    var S = this, sz2, c, d, c2, x1, x2, x, y1, y2, y, z;
    if (S.curve !== T.curve) {
      throw("sjcl.ecc.add(): Points must be on the same curve to add them!");
    }

    if (S.isIdentity) {
      return T.toJac();
    } else if (T.isIdentity) {
      return S;
    }

    sz2 = S.z.square();
    c = T.x.mul(sz2).subM(S.x);

    if (c.equals(0)) {
      if (S.y.equals(T.y.mul(sz2.mul(S.z)))) {
	// same point
	return S.doubl();
      } else {
	// inverses
	return new sjcl.ecc.pointJac(S.curve);
      }
    }
    
    d = T.y.mul(sz2.mul(S.z)).subM(S.y);
    c2 = c.square();

    x1 = d.square();
    x2 = c.square().mul(c).addM( S.x.add(S.x).mul(c2) );
    x  = x1.subM(x2);

    y1 = S.x.mul(c2).subM(x).mul(d);
    y2 = S.y.mul(c.square().mul(c));
    y  = y1.subM(y2);

    z  = S.z.mul(c);

    return new sjcl.ecc.pointJac(this.curve,x,y,z);
  },
  
  /**
   * doubles this point.
   * @return {sjcl.ecc.pointJac} The doubled point.
   */
  doubl: function() {
    if (this.isIdentity) { return this; }

    var
      y2 = this.y.square(),
      a  = y2.mul(this.x.mul(4)),
      b  = y2.square().mul(8),
      z2 = this.z.square(),
      c  = this.x.sub(z2).mul(3).mul(this.x.add(z2)),
      x  = c.square().subM(a).subM(a),
      y  = a.sub(x).mul(c).subM(b),
      z  = this.y.add(this.y).mul(this.z);
    return new sjcl.ecc.pointJac(this.curve, x, y, z);
  },

  /**
   * Returns a copy of this point converted to affine coordinates.
   * @return {sjcl.ecc.point} The converted point.
   */  
  toAffine: function() {
    if (this.isIdentity || this.z.equals(0)) {
      return new sjcl.ecc.point(this.curve);
    }
    var zi = this.z.inverse(), zi2 = zi.square();
    return new sjcl.ecc.point(this.curve, this.x.mul(zi2).fullReduce(), this.y.mul(zi2.mul(zi)).fullReduce());
  },
  
  /**
   * Multiply this point by k and return the answer in Jacobian coordinates.
   * @param {bigInt} k The coefficient to multiply by.
   * @param {sjcl.ecc.point} affine This point in affine coordinates.
   * @return {sjcl.ecc.pointJac} The result of the multiplication, in Jacobian coordinates.
   */
  mult: function(k, affine) {
    if (typeof(k) === "number") {
      k = [k];
    } else if (k.limbs !== undefined) {
      k = k.normalize().limbs;
    }
    
    var i, j, out = new sjcl.ecc.point(this.curve).toJac(), multiples = affine.multiples();

    for (i=k.length-1; i>=0; i--) {
      for (j=sjcl.bn.prototype.radix-4; j>=0; j-=4) {
	out = out.doubl().doubl().doubl().doubl().add(multiples[k[i]>>j & 0xF]);
      }
    }
    
    return out;
  },
  
/**
   * Multiply this point by k, added to affine2*k2, and return the answer in Jacobian coordinates.
   * @param {bigInt} k The coefficient to multiply this by.
   * @param {sjcl.ecc.point} affine This point in affine coordinates.
   * @param {bigInt} k2 The coefficient to multiply affine2 this by.
   * @param {sjcl.ecc.point} affine The other point in affine coordinates.
   * @return {sjcl.ecc.pointJac} The result of the multiplication and addition, in Jacobian coordinates.
   */
  mult2: function(k1, affine, k2, affine2) {
    if (typeof(k1) === "number") {
      k1 = [k1];
    } else if (k1.limbs !== undefined) {
      k1 = k1.normalize().limbs;
    }
    
    if (typeof(k2) === "number") {
      k2 = [k2];
    } else if (k2.limbs !== undefined) {
      k2 = k2.normalize().limbs;
    }
    
    var i, j, out = new sjcl.ecc.point(this.curve).toJac(), m1 = affine.multiples(),
        m2 = affine2.multiples(), l1, l2;

    for (i=Math.max(k1.length,k2.length)-1; i>=0; i--) {
      l1 = k1[i] | 0;
      l2 = k2[i] | 0;
      for (j=sjcl.bn.prototype.radix-4; j>=0; j-=4) {
        out = out.doubl().doubl().doubl().doubl().add(m1[l1>>j & 0xF]).add(m2[l2>>j & 0xF]);
      }
    }
    
    return out;
  },
  
  isValid: function() {
    var z2 = this.z.square(), z4 = z2.square(), z6 = z4.mul(z2);
    return this.y.square().equals(
	    this.curve.b.mul(z6).add(this.x.mul(
	      this.curve.a.mul(z4).add(this.x.square()))));
  }
};

/**
 * Construct an elliptic curve. Most users will not use this and instead start with one of the NIST curves defined below.
 *
 * @constructor
 * @param {bigInt} p The prime modulus.
 * @param {bigInt} r The prime order of the curve.
 * @param {bigInt} a The constant a in the equation of the curve y^2 = x^3 + ax + b (for NIST curves, a is always -3).
 * @param {bigInt} x The x coordinate of a base point of the curve.
 * @param {bigInt} y The y coordinate of a base point of the curve.
 */
sjcl.ecc.curve = function(Field, r, a, b, x, y) {
  this.field = Field;
  this.r = Field.prototype.modulus.sub(r);
  this.a = new Field(a);
  this.b = new Field(b);
  this.G = new sjcl.ecc.point(this, new Field(x), new Field(y));
};

sjcl.ecc.curve.prototype.fromBits = function (bits) {
  var w = sjcl.bitArray, l = this.field.prototype.exponent + 7 & -8,
      p = new sjcl.ecc.point(this, this.field.fromBits(w.bitSlice(bits, 0, l)),
			    this.field.fromBits(w.bitSlice(bits, l, 2*l)));
  if (!p.isValid()) {															//modified to add alert in PassLok								//
	document.getElementById("mainmsg").innerHTML = '<span>Invalid Lock</span>';	//
    throw new sjcl.exception.corrupt("not on the curve!");						//
  }																				//
  return p;
};

//F. Ruiz: Added the NIST 521-bit elliptic curve parameters, removed the other curves since they are not used in PassLok

sjcl.ecc.curves = {
	
  c521: new sjcl.ecc.curve(				//these parameters are my addition to ecc.js
	sjcl.bn.prime.p521,
	"0x5AE79787C40D069948033FEB708F65A2FC44A36477663B851449048E16EC79BF6",
	- 3,
"0x051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00",
"0xc6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66",
"0x11839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650")
};

//End of SJCL code, some of its elGamal, ECDSA code is used in the functions below 


//Now the ORIGINAL PASSLOK CODE BEGINS

//set global variables for lock DB functions
if(!("lockDB" in localStorage)) localStorage["lockDB"] = "{}";  //initialize lockDB, which is a nested object
var lockDB = JSON.parse(localStorage.lockDB);					//database in Object form
var lockNames = [''].concat(Object.keys(lockDB));				//array for finding lock names

//function to test key strength and come up with appropriate key stretching
function keyStrength(pwd,display) {
var iter = 6000;
var keymsg = document.getElementById("keymsg");
var decoymsg = document.getElementById("decoymsg");
var strongRegex = new RegExp("^(?=.{7,})(?=.*[A-Z])(?=.*[a-z])(?=.*[0-9])(?=.*[^a-zA-Z0-9]).*$", "g");
var goodRegex = new RegExp("^(?=.{7,})(((?=.*[A-Z])(?=.*[a-z])(?=.*[0-9]))|((?=.*[^a-zA-Z0-9])(?=.*[a-z])(?=.*[0-9]))|((?=.*[A-Z])(?=.*[^a-zA-Z0-9])(?=.*[0-9]))|((?=.*[A-Z])(?=.*[a-z])(?=.*[^a-zA-Z0-9]))).*$", "g");
var mediumRegex = new RegExp("^(?=.{7,})(((?=.*[A-Z])(?=.*[a-z]))|((?=.*[A-Z])(?=.*[0-9]))|((?=.*[a-z])(?=.*[0-9]))|((?=.*[a-z])(?=.*[^a-zA-Z0-9]))|((?=.*[A-Z])(?=.*[^a-zA-Z0-9]))|((?=.*[0-9])(?=.*[^a-zA-Z0-9]))).*$", "g");
var enoughRegex = new RegExp("(?=.{7,}).*", "g");
	pwd = pwd.replace(/^\d+/,'').replace(/\d+$/,'');									//no credit for initial and trailing numbers
	pwd = pwd.replace(/^[a-zA-Z]/,'');													//no credit for initial letter, small or capital
	pwd = pwd.replace(/\s/g,'');														//no credit for spaces
if (pwd.length==0) {
var msg = "&nbsp";
} else if (false === enoughRegex.test(pwd)) {
var msg = '<span style="color:magenta"> Terrible!</span>';								//less than 8 good characters
iter = 6000;
} else if (strongRegex.test(pwd)) {
var msg = '<span style="color:blue">  Great!</span>';									//at least 8 comprising all: lowercase, caps, numbers, and sp chars
iter = 2;
} else if (goodRegex.test(pwd)) {
var msg = '<span style="color:green">  Good!</span>';									//at least 8 of three kinds: lowercase, caps, numbers, and sp chars
iter = 500;
} else if (mediumRegex.test(pwd)) {
var msg = '<span style="color:orange">  Medium</span>';									//at least 8 of either two of: lowercase, caps, numbers, sp chars
iter = 1500;
} else {
var msg = '<span style="color:red">  Weak!</span>';										//at least 8 of one kind of characters
iter = 2500;
};
if(display){
	if(document.getElementById("keyscr").style.display=="block") keymsg.innerHTML = msg;
	if(document.getElementById("decoyIn").style.display=="block") decoymsg.innerHTML = msg;	
}
return iter
};

//if secret Key box is empty, this displays a random Key in that box and its Lock in the main box, otherwise display Lock in main box
function fillkeys(){
	var learnOn = document.getElementById("learnmode").checked;
	var keymsg = document.getElementById("keymsg"),				//for displaying messages above key box
		mainmsg = document.getElementById("mainmsg");
		keymsg.innerHTML = "";
		mainmsg.innerHTML = "";
	var lockstr = document.lock.text.value.replace(/[^a-zA-Z0-9+/=]+/g, '');					//remove whatever is not base64 or =
		lockstr = lockstr.split("=").sort(function (a, b) { return b.length - a.length; })[0];	//remove end tags
	var keystr = document.key.text.value.trim();				//cut trailing spaces
	
	if(keystr==""){												//if the key box is empty, display a warning
		keymsg.innerHTML = '<span style="color:red">First write your Key in the box</span>';
		throw("no Key");	
	} else {													//replace the main box with Lock made from the key box
		if (learnOn){
			var reply = confirm("The Lock matching the Key in this box will be placed in the main box, replacing its contents. Cancel if this is not what you want.");
			if(reply===false) throw("lock canceled");
		};
		showpub(keystr);
		keymsg.innerHTML = 'Lock in the main box';
		mainmsg.innerHTML = 'This is the Lock matching your Key';
	};	
};

//displays the public key on the main screen
function showpub(secstr){
	var pubstr = makepub(secstr);
	if (document.getElementById("notags").checked === false){
		document.main.text.value = "PL17lok=" + pubstr + "=PL17lok";
	}else{
		document.main.text.value = pubstr;
	}
};

//makes the public string of a private string
function makepub(secstr){
	var curve = sjcl.ecc.curves["c521"],						//make curve object
		sec = toexponent(secstr),								//retrieve Key, correctly formatted as an EC exponent
	    pub = curve.G.mult(sec),								//make public key or Lock
		pubstr = sjcl.codec.base64.fromBits(pub.toBits());
	return pubstr.slice(1,88)									//strip initial "A", only x part
};

//key reformatting and stretching for secret Key (shared key is formatted automatically by sjcl) for 521 bit keys
function toexponent(string){
	var iter = keyStrength(string,false);						//get number of iterations from Key strength meter
	var w = sjcl.bitArray;	
	return sjcl.bn.fromBits(w.bitSlice(sjcl.misc.scrypt(string,"",iter,8,1,66)))	//use no salt, iteration number variable according to Key strength, 528 bits
};

//this one makes the shared secret
function makeshared(secstr,xstr){
	var curve = sjcl.ecc.curves["c521"],
		sec = toexponent(secstr),
		ystr = yfromx(curve,'A' + xstr),				      	//retrieve y coordinate from x coordinate. Add the spurious 'A' that SJCL adds to a 521-bit number
		pub = curve.fromBits(sjcl.codec.base64.toBits('A'+xstr+ystr)),  //make public key object containing both x and y
		sharedsec = pub.mult(sec),
		sharedstr = sjcl.codec.base64.fromBits(sharedsec.toBits());
	return sharedstr.slice(2,88)  								//strip spurious initial "A", only x part. Strip also 2nd char so it's not mistaken for a Lock
};

function yfromx(curve,xstr){
	var x = sjcl.bn.fromBits(sjcl.codec.base64.toBits(xstr)),   //the following to retrieve y coordinate from x coordinate
		y = curve.b.add(x.mul(curve.a.add(x.square())));		//this is actually y^2, square root by special case of Tonelli-Shanks follows
	var i;
	for (i=0; i<519; i++) {
  		y = y.square();											//performs y^((p+1)/4), since p = 2^521 - 1, (p+1)/4=2^519, all is mod p
		};
	return sjcl.codec.base64.fromBits(y.toBits());
};

//display a hash of the textarea for authentication purposes
function showhash(){
	var mine = document.extra.text.value.trim(),				//remove spaces at start and end
		extramsg = document.getElementById("extramsg");
	if (mine.length < 267){										//if it's the length of a signature or shorter remove spaces, tags and anything that is not base64
		mine = striptags(mine)
	}
	if (mine != '') {    										//take hash, make it hex, cut into 4-char pieces and join with dashes
		extramsg.innerHTML = 'ID: ' + sjcl.codec.hex.fromBits(sjcl.hash.sha256.hash(mine)).match(/.{1,4}/g).join("-")
	} else { extramsg.innerHTML = ''}
};

//this strips initial and final tags, plus spaces and non-base64 characters in the middle
function striptags(string){
	string = string.replace(/\s/g,'');															//remove spaces
	string = string.split("=").sort(function (a, b) { return b.length - a.length; })[0];		//remove tags								
	string = string.replace(/[^a-zA-Z0-9+/ ]+/g, ''); 											//takes out anything that is not base64
	return string
}

var encrypting;		//global flag so decoy input doesn't get confused

//AES encryption process: determines the kind of encryption by looking at the radio buttons and check boxes under the main box and the length of the presumed Lock
//This function handles short mode encryption only (no List). Otherwise, Encrypt_for_List() is called
function Encrypt_text(){
	var shortOn = document.getElementById("shortmode").checked,
		learnOn = document.getElementById("learnmode").checked,
		tagsOff = document.getElementById("notags").checked,
		signedOn = document.getElementById("signedmode").checked,
		pfsOn = document.getElementById("pfsmode").checked,
		anonOn = document.getElementById("anonmode").checked,
		mainmsg = document.getElementById("mainmsg"),
		extramsg = document.getElementById("extramsg"),
		lockmsg = document.getElementById("lockmsg"),
		name = lockmsg.innerHTML,
		clipped = false,
		secstr = document.lock.text.value.trim();
	var	pubstr = striptags(secstr);
	if (secstr === ""){
		main2lock();
		lockmsg.innerHTML = '<span style="color:red">Enter a Lock, shared Key, or List</span>';
		throw("lock box empty");
	}
	var listArray = secstr.split('\n');

	if(!shortOn){								//this function handles only short mode, otherwise Encrypt_for_List() is called instead
		Encrypt_for_List(listArray);
		return
	}
	if (listArray.length > 1 && listArray[1].slice(0,4) != 'http'){			//this is a List, which is not compatible with short mode
		mainmsg.innerHTML = '<span style="color:red">Short mode not available for multiple recipients</span>';
		throw('multiple Locks for short mode')
	}
	
	if(pubstr.length != 87){					//key-locked mode, if no Lock is entered
		if (learnOn){
			var reply3 = confirm("The contents of the main box will be locked with the shared Key in the Locks box, and the result will replace the main box. Cancel if this is not what you want.");
			if(reply3===false) throw("sym encryption canceled");
		};
		var iter = keyStrength(secstr,false);							//get number of iterations from Key strength meter, minimum is 101
		var iv = sjcl.codec.base64.fromBits(sjcl.random.randomWords('2','0')),
			salt = makesalt(iv,37),										//salt can hide 37 chars in short mode
			text = encodeURI(document.main.text.value).replace(/%20/g, ' ');
		if (text.length > 58) clipped = true;	
			text = text + "                                                         ";  //clip or add spaces to make a 58 char message 
			text = text.slice(0,58);
		var keyStretched = sjcl.codec.base64.fromBits(sjcl.misc.scrypt(secstr,salt,iter,8,1,33));
		var cipherj = JSON.parse(sjcl.encrypt(keyStretched,text,{"iv":iv,"salt":salt,"ks":256,"iter":101}));
		if (learnOn){
			alert(name + " will need to place the same Key in the Locks box to unlock the message in the main box.");
		};
		document.main.text.value = "@" + cipherj.iv + cipherj.salt + cipherj.ct;
		if(typeof window.orientation !== 'undefined'){					//detect mobile
			main2extra();
			extramsg.innerHTML = 'Locking successful. Copy and click SMS';
			selectExtra()
		}
	}
		
	else if (pfsOn){										//PFS mode, similar to Lock mode, but uses permanent storage
		if (learnOn){
			var reply3 = confirm("The contents of the main box will be locked, in PFS mode, with the item selected in the Locks box, and the result will replace the main box. Cancel if this is not what you want. Cancel if this is not what you want.");
			if(reply3===false) throw("PFS locking canceled");
		};
		var key = readKey();												//secret Key for encrypting dummy Key before storage, check before anything
		if (lockDB[name] == null){											//no name selected
			main2lock();
			lockmsg.innerHTML = '<span style="color:red">Select a recipient with a valid Lock by name</span>';
			throw("invalid name")
		}
		var lastLockcipher = lockDB[name][3],								//retrieve dummy Lock from storage, [0] is the permanent Lock by that name
			turnstring = lockDB[name][4];									//this strings says whose turn it is to encrypt
		if (turnstring=='next unlock'){
			var reply4 = confirm("It's not your turn to encrypt a PFS message for " + name + ". If you go ahead, the PFS conversation with this recipient may become corrupted. Cancel if this is not what you want.");
			if(reply4===false) throw("PFS locking canceled");
			}
		if (lastLockcipher != null) {										//if dummy exists, decrypt it first
			var lastLock = keyDecrypt(key,lastLockcipher);
		} else {															//use permanent Lock, minus tags, if dummy doesn't exist
			if (pubstr.length == 87){
				var lastLock = pubstr
			} else {														//if it's a shared Key, use the Lock deriving from it
				var lastLock = makepub(pubstr);
			}
		}
		var newKey = sjcl.codec.base64.fromBits(sjcl.random.randomWords('17','0')).slice(0,86),	//new dummy Key
			newLock = makepub(newKey);	
		var lastKeycipher = lockDB[name][2];							//short mode uses last Key and last Lock. The new lock is sent unencrypted
		if (lastKeycipher != null){	
			var lastKey = keyDecrypt(key,lastKeycipher)
		} else {
			var lastKey = key																	//use permanent Key, if dummy doesn't exist
		}
		var keystr = makeshared(lastKey,lastLock),
			iv = sjcl.codec.base64.fromBits(sjcl.random.randomWords('2','0')),					//11 char serial in short mode, no salt
			salt = "",
			text = encodeURI(document.main.text.value).replace(/%20/g, ' ');
		if (text.length > 37) clipped = true;
			text = text + "                                                         ";   		//clip or add spaces to make a 37 char message 
			text = text.slice(0,37);
		var cipherj = JSON.parse(sjcl.encrypt(keystr,text,{"iv":iv,"salt":salt,"ks":256,"iter": 101}));
		document.main.text.value = "$" + cipherj.iv + cipherj.salt + newLock + cipherj.ct;
		if(typeof window.orientation !== 'undefined'){											//detect mobile
			main2extra();
			extramsg.innerHTML = 'Locking successful. To be unlocked by ' + name + ' in PFS mode. Copy and click SMS. Must be first locked after reading.';
			selectExtra()
		}							
		lockDB[name][2] = keyEncrypt(key,newKey);							//new Key is stored in the permanent database
		lockDB[name][4] = 'next unlock';
		localStorage.lockDB = JSON.stringify(lockDB);
	}
	
	else if (signedOn){								//signed mode, make encryption key from secret Key and recipient's Lock
		if (learnOn){
			var reply3 = confirm("The contents of the main box will be locked with your secret secret Key and the Lock in the Locks box, and the result will replace the main box. Cancel if this is not what you want.");
			if(reply3===false) throw("signed encryption canceled");
		};
		var key = readKey();
		if (pubstr.length != 87){
				main2lock();
				lockmsg.innerHTML = "<span style='color:red'>The recipient's Lock is needed</span>";	
				throw("no Lock found");
		}
		
		if (lockDB[name]) var sharedKeycipher = lockDB[name][1];
		if (sharedKeycipher != null){
			var sharedKey = keyDecrypt(key,sharedKeycipher)
		} else {
			var sharedKey = makeshared(key,pubstr);
			if (lockDB[name]){
				lockDB[name][1] = keyEncrypt(key,sharedKey);
				localStorage.lockDB = JSON.stringify(lockDB)
			}
		}
		var iv = sjcl.codec.base64.fromBits(sjcl.random.randomWords('2','0')),
			salt = makesalt(iv,37),														//salt can hide 37 chars in short mode
			text = encodeURI(document.main.text.value).replace(/%20/g, ' ');
		if (text.length > 58) clipped = true;
			text = text + "                                                         ";  //clip or add spaces to make a 58 char message 
			text = text.slice(0,58);
		var cipherj = JSON.parse(sjcl.encrypt(sharedKey,text,{"iv":iv,"salt":salt,"ks":256,"iter": 101}));
		if (learnOn){
			alert(lockmsg + " will need your Lock and his/her secret Key to unlock the message in the main box.");
		};
		document.main.text.value = "#" + cipherj.iv + cipherj.salt + cipherj.ct;
		if(typeof window.orientation !== 'undefined'){									//detect mobile
			main2extra();
			extramsg.innerHTML = 'Locking successful. Copy and click SMS';
			selectExtra()
		}
	}
	
	else if (anonOn){								//anonymous mode, using only the recipient's Lock
		if (learnOn){
			var reply = confirm("The contents of the main box will be locked with the Lock in the Locks box and the result will be placed in the main box. This is irreversible. Cancel if this is not what you want.");
			if(reply===false) throw("public encryption canceled");
		};
		if(name=='') name = "the recipient";
		if (pubstr.length != 87){
			main2lock();
			lockmsg.innerHTML = "<span style='color:red'>The recipient's Lock is needed</span>";	
			throw("no Lock found");
		}
		var secstrdum = sjcl.codec.base64.fromBits(sjcl.random.randomWords('17','0')).slice(0,87),	//make dummy Key
			pubstrdum = makepub(secstrdum);															//makes 87 char dummy public key, initial A stripped	
		var keystr = makeshared(secstrdum,pubstr);													//make AES key from dummy secret and recipient's public key
		var iv = sjcl.codec.base64.fromBits(sjcl.random.randomWords('2','0')),						//11 char serial in short mode, no salt
			salt = "",
			text = encodeURI(document.main.text.value).replace(/%20/g, ' ');
		if (text.length > 38) clipped = true;
			text = text + "                                                         ";  			//clip or add spaces to make a 38 char message 
			text = text.slice(0,38);			
		var cipherj = JSON.parse(sjcl.encrypt(keystr,text,{"iv":iv,"salt":salt,"ks":256,"iter": 101}));   //use 256 bit keys, min stretching for random key
		if (learnOn){
			alert(name + " will need to place his/her secret Key in the key box to unlock the message in the main box.");
		}		
		document.main.text.value = cipherj.iv + cipherj.salt + pubstrdum + cipherj.ct;	//display adding dummy public key and anonymous tags, depending on mode
		if(typeof window.orientation !== 'undefined'){
			main2extra();
			extramsg.innerHTML = 'Locking successful. Copy and click SMS';
			selectExtra()
		}		
	}
	if (clipped) mainmsg.innerHTML = "<span style='color:orange'>The message has been truncated</span>"	
	document.decoyIn.text.value = "";
	document.decoyIn.key.value = "";
	document.decoyOut.key.value = "";
};

//encrypts for a list of recipients. First makes a 256-bit message key, then gets the Lock or shared Key for each recipient and encrypts the message key with it
//the output string contains each encrypted key along with 66 bits of an encrypted form of the recipient's item, so he/she can find the right encrypted key 
function Encrypt_for_List(listArray){
	var shortOn = document.getElementById("shortmode").checked,
		learnOn = document.getElementById("learnmode").checked,
		tagsOff = document.getElementById("notags").checked,
		signedOn = document.getElementById("signedmode").checked,
		pfsOn = document.getElementById("pfsmode").checked,
		anonOn = document.getElementById("anonmode").checked,
		mainmsg = document.getElementById("mainmsg"),
		lockmsg = document.getElementById("lockmsg");
	if(shortOn){
		mainmsg.innerHTML = '<span style="color:red">Short mode not available for multiple recipients</span>'
		throw('short mode not available')
	}
	
	var warningList = "";
	for (var index = 0; index < listArray.length; index++){										//scan lines and pop a warning if some are not on DB or aren't Locks
		var name = listArray[index].trim();
		if (name.slice(0,4)=='http') {
			listArray[index] = '';
			name = ''
		}
		if (name != ''){
			if(lockDB[name] == null) {					//not on database; see if it's a Lock, and otherwise add to warning list
				var namestr = striptags(name);
				if(namestr.length!=87){
					if (warningList==""){warningList = name} else {warningList = warningList + '\n' + name}
				}
			}
		}
	}
	if (warningList!=''){
		var agree = confirm('The names on the list below were not found in your local directory. If you go ahead, they will be used as shared Keys for locking and unlocking the message. This could be a serious security hazard:\n\n' + warningList);
		if (!agree) throw('list encryption terminated by user')
	}
	
	var	msgkey = sjcl.codec.base64.fromBits(sjcl.random.randomWords('8','0')).slice(0,43),		//message key a little over 256-bit
		iv = sjcl.codec.base64.fromBits(sjcl.random.randomWords('4','0')),
		text = document.main.text.value;
	if (anonOn) {
		if (learnOn){
			var reply = confirm("The contents of the main box will be anonymously locked with the Locks of the recipients listed in the Locks box, so that all of them can read it with their respective Keys, and the result will replace the main box. Cancel if this is not what you want.");
			if(reply===false) throw("anonymous list encryption canceled");
		}
		var salt = makesalt(iv,87);											//salt hides 87 chars in anonymous, 152 otherwise. Tags are different, too
		if(tagsOff){														//initial tag
			var outString = "!"
		} else {
			var outString = "PL17msa=!"
		}
	} else if(pfsOn){
		if (learnOn){
			var reply = confirm("The contents of the main box will be locked in PFS mode with the Locks of the recipients listed in the Locks box, so that all of them can read it with their respective Keys, and the result will replace the main box. Cancel if this is not what you want.");
			if(reply===false) throw("anonymous list encryption canceled");
		}
		var salt = makesalt(iv,87);
		if(tagsOff){
			var outString = "$"
		} else {
			var outString = "PL17msp=$"
		}				
	} else {
		if (learnOn){
			var reply = confirm("The contents of the main box will be locked with the Locks of the recipients listed in the Locks box and signed with your Key, so that all of them can read it by supplying your Lock, and the result will replace the main box. Cancel if this is not what you want.");
			if(reply===false) throw("signed list encryption canceled");
		}
		var salt = makesalt(iv,152);
		if(tagsOff){
			var outString = "#"
		} else {
			var outString = "PL17mss=#"
		}
	}
	var cipherj = JSON.parse(sjcl.encrypt(msgkey,text,{"iv":iv,"salt":salt,"ks":256,"iter":101}));		 //main encryption event, but don't add it yet 
	outString = outString + cipherj.iv + cipherj.salt;
	
	if (anonOn) {															//for anonymous mode, make dummy Lock and add it to the output string
		var secstrdum = sjcl.codec.base64.fromBits(sjcl.random.randomWords('17','0')).slice(0,87),
			pubstrdum = makepub(secstrdum);	
		outString = outString + pubstrdum
	}
	
	//for each item on the List (unless empty), encrypt the message key and add it, prefaced by the first 256 bits of the ciphertext when the item is encrypted with message iv and salt, and the shared key
	for (var index = 0; index < listArray.length; index++){
		var name = listArray[index].trim();
		if (name != ''){
			if(lockDB[name] != null) {										//get item from the lockDB database and decrypt it before using it
				if (key == null) var key = readKey();
				var string = lockDB[name][0],
					secstr = keyDecrypt(key,string.slice(1,string.length));
			} else var secstr = name;										//allow for adding items directly to the List, now strip tags to see if it's a Lock				
			var pubstr = striptags(secstr);		
			if (pubstr.length == 87){										//if it's a Lock, do anonymous, PFS or signed encryption, and add the result to the output			
				if (signedOn){
					if (key == null) var key = readKey();
					if(lockDB[name]!=null){
						var sharedKeycipher = lockDB[name][1];					//permanent key shared with recipient, for encrypting the new dummy Lock
						if (sharedKeycipher != null){
							var sharedKey = keyDecrypt(key,sharedKeycipher);
						} else {
							var sharedKey = makeshared(key,pubstr);
							lockDB[name][1] = keyEncrypt(key,dualKey);		
						}
					} else {
						var sharedKey = makeshared(key,pubstr)
					}
					var	cipherj2 = JSON.parse(sjcl.encrypt(sharedKey,msgkey,{"iv":iv,"salt":salt,"ks":256,"iter": 101})),
						idtag = JSON.parse(sjcl.encrypt(sharedKey,pubstr,{"iv":iv,"salt":salt,"ks":256,"iter": 101}));			
				} else if (anonOn){
					var sharedKey = makeshared(secstrdum,pubstr);
					var	cipherj2 = JSON.parse(sjcl.encrypt(sharedKey,msgkey,{"iv":iv,"salt":salt,"ks":256,"iter": 101})),
						idtag = JSON.parse(sjcl.encrypt(sharedKey,pubstr,{"iv":iv,"salt":salt,"ks":256,"iter": 101}));
				} else if (pfsOn){
					if(lockDB[name] == null){
						if(lockDB[lockmsg.innerHTML] != null && listArray.length == 1){
							name = lockmsg.innerHTML
						} else {
							mainmsg.innerHTML = 'In PFS mode, recipient Locks must be stored and their names displayed';
							throw('name not on lockDB')
						}
					}
					if (key == null) var key = readKey();					
					var dualKeycipher = lockDB[name][1],
						turnstring = lockDB[name][4];
					if (turnstring=='next unlock'){
						var reply4 = confirm("It's not your turn to encrypt a PFS message for " + name + ". If you go ahead, the PFS conversation with this recipient may become corrupted. Cancel if this is not what you want.");
						if(reply4===false) throw("PFS locking canceled");
					}
					if (dualKeycipher != null){
						var dualKey = keyDecrypt(key,dualKeycipher);
					} else {					
						var dualKey = makeshared(key,pubstr)
						lockDB[name][1] = keyEncrypt(key,dualKey);		
					}					
					
					var lastLockcipher = lockDB[name][3];						//retrieve dummy Lock from storage, [0] is the permanent Lock by that name
					if (lastLockcipher != null) {								//if dummy exists, decrypt it first
						var lastLock = keyDecrypt(key,lastLockcipher);
					} else {													//use permanent Lock, minus tags, if dummy doesn't exist
						var lastLock = pubstr				
					}
					
					var secstrdum = sjcl.codec.base64.fromBits(sjcl.random.randomWords('17','0')).slice(0,87),		//different dummy key for each recipient
						pubstrdum = makepub(secstrdum);					
					var sharedKey = makeshared(secstrdum,lastLock);
					lockDB[name][2] = keyEncrypt(key,secstrdum);				//new Key is stored in the permanent database
					lockDB[name][4] = 'next unlock';
					localStorage.lockDB = JSON.stringify(lockDB);

				//sharedKey depends on the newLock, so use the permanent shared Key instead for making the idtag and encrypting the newLock
					var	cipherj2 = JSON.parse(sjcl.encrypt(sharedKey,msgkey,{"iv":iv,"salt":salt,"ks":256,"iter": 101})),
						idtag = JSON.parse(sjcl.encrypt(dualKey,pubstr,{"iv":iv,"salt":salt,"ks":256,"iter": 101})),
						newLockcipher = JSON.parse(sjcl.encrypt(dualKey,pubstrdum,{"iv":iv,"salt":salt,"ks":256,"iter": 101}));
				}
			} else {														//if it's not a Lock, do a symmetric encryption instead, with appropriate key stretching
				var iter = keyStrength(secstr,false),
					keyStretched = sjcl.codec.base64.fromBits(sjcl.misc.scrypt(secstr,salt,iter,8,1,33)),
					cipherj2 = JSON.parse(sjcl.encrypt(keyStretched,msgkey,{"iv":iv,"salt":salt,"ks":256,"iter":101})),
					idtag = JSON.parse(sjcl.encrypt(secstr,secstr,{"iv":iv,"salt":salt,"ks":256,"iter":101}));
			}
			if (pfsOn && pubstr.length == 87){
				outString = outString + '%' + idtag.ct.slice(0,11) + '%' + newLockcipher.ct + cipherj2.ct;
			} else {
				outString = outString + '%' + idtag.ct.slice(0,11) + '%' + cipherj2.ct;
			}
		}
	}
	
	//finish off by adding the encrypted message and tags
	outString = outString + '%' + cipherj.ct
	if (tagsOff) {
			document.main.text.value = outString
	} else {
		if(anonOn){
			document.main.text.value = outString + "=PL17msa"
		} else if(pfsOn){
			document.main.text.value = outString + "=PL17msp"
		} else {
			document.main.text.value = outString + "=PL17mss"
		}
	}
	mainmsg.innerHTML = 'Locking successful'
}

//reads key box and stops if there's something wrong or the timer has run out
function readKey(){
	if ((new Date().getTime()) - keytimer > 300000) document.key.text.value = '';		//erase key after 5 minutes
	var key = document.key.text.value.trim();
	if (key == ""){
		any2key();
		document.getElementById("keymsg").innerHTML = 'Please enter your secret Key and retry.';
		throw ('secret Key needed to encrypt item')
	}
	keytimer = new Date().getTime();													//reset key timer
	return key
}

//decrypts a string encrypted with the secret Key, 11 char serial, no salt, variable key stretching
function keyDecrypt(key,cipherstring){
	var	iv = cipherstring.slice(0,11),
		ct = cipherstring.slice(11,cipherstring.length),
		iter = keyStrength(key,false);
	var keyStretched = sjcl.codec.base64.fromBits(sjcl.misc.scrypt(key,'',iter,8,1,33));
	var cipherstr2 = '{"iv":"' + iv + '","salt":"' + '' + '","ct":"' + ct + '","ks":256,"iter":101}';
	return sjcl.decrypt(keyStretched,cipherstr2)	
}

//encrypts a string with the secret Key, 11 char serial, no salt, variable key stretching
function keyEncrypt(key,plainstring){
	var	iv = sjcl.codec.base64.fromBits(sjcl.random.randomWords('2','0')),				//minimum iterations = 101
		iter = keyStrength(key,false);
	var keyStretched = sjcl.codec.base64.fromBits(sjcl.misc.scrypt(key,'',iter,8,1,33));
	var cipherj2 = JSON.parse(sjcl.encrypt(keyStretched,plainstring,{"iv":iv,"salt":"","ks":256,"iter":101}));	
	return cipherj2.iv + cipherj2.ct
}

//encrypts a hidden message into the salt value used by regular encryption, or makes a random salt also encoded by AES so it's indistinguishable
function makesalt(iv,leng){
	if (document.getElementById("decoymode").checked === true){
		if (document.getElementById("learnmode").checked === true){
			var reply = confirm("You are adding a hidden message in Decoy mode. Cancel if this is not what you want, then uncheck Decoy mode below.");
			if(reply===false) throw("decoy encryption canceled");
		};
		if ((document.decoyIn.key.value.trim() == "")||(document.decoyIn.text.value.trim() == "")){ //stop to display the decoy entry form if there is no hidden message or key
			document.getElementById("decoyIn").style.display = "block";					//display decoy form, and back shadow
			document.getElementById("shadow").style.display = "block";			
			throw ("stopped for decoy input")				
		}
		var key = document.decoyIn.key.value,
			text = encodeURI(document.decoyIn.text.value.replace(/%20/g, ' ')),
			iter = keyStrength(key,false);												//key may be weak, so stretch it
	} else {																			//no decoy mode, so salt comes from random text and key, no extra stretching
		var key = sjcl.codec.base64.fromBits(sjcl.random.randomWords('8','0')),
			text = sjcl.codec.base64.fromBits(sjcl.random.randomWords('57','0')).slice(0,214),
			iter = 2;
	};
	while (text.length < leng) {														//clip or add spaces to make the number of characters required
			text = text + "          ";
		};
		text = text.slice(0,leng);
		var keyStretched = sjcl.codec.base64.fromBits(sjcl.misc.scrypt(key,'',iter,8,1,33));
		var cipherj = JSON.parse(sjcl.encrypt(keyStretched,text,{"iv":iv,"salt":"","ks":256,"iter":101}));
		return cipherj.ct;
};

//AES decryption process: determines which kind of encryption by looking at first character after the initial tag. Calls Encrypt_text as appropriate
function Decrypt_text(){
	encrypting = true;
	var decoyOn = document.getElementById("decoymode").checked,
		learnOn = document.getElementById("learnmode").checked,
		keymsg = document.getElementById("keymsg"),
		mainmsg = document.getElementById("mainmsg"),
		lockmsg = document.getElementById("lockmsg");
	keymsg.innerHTML = "";
	mainmsg.innerHTML = "";
	var name = lockmsg.innerHTML,
		cipherstr = document.main.text.value.trim(),
		secstr = document.lock.text.value.trim();
	if (cipherstr===""){																//if the main box is empty, display a warning
		mainmsg.innerHTML = '<span style="color:red">Nothing to lock or unlock</span>';
		throw("main box empty");
	};
	cipherstr = cipherstr.split("=").sort(function (a, b) { return b.length - a.length; })[0];   //remove end tags
		
	//here detect if the message is for multiple recipients, and if so call the appropriate program
	var cipherArray = cipherstr.split('%');
	if(cipherArray.length > 3){
		if (cipherArray[1].length == 11){
			Decrypt_from_List(cipherArray);
			return
		}
	}
	var pubstr = striptags(secstr);
	var type = cipherstr.slice(0,1);													//get encryption type. !=public, @=symmetric, #=signed
		cipherstr = cipherstr.replace(/[^a-zA-Z0-9+/ ]+/g, '');							//remove anything that is not base64
	
	if (cipherstr.length==160){					//short asymmetric decryption
		if (learnOn){
			var reply = confirm("The short message in the main box was locked with your personal Lock, and will now be unlocked if your secret Key has been entered, replacing the locked message. Cancel if this is not what you want.");
			if(reply===false) throw("public decryption canceled");
		};
		var key = readKey();
		var	iv = cipherstr.slice(0,11),													//get iv, salt, and later ct data and public key
			salt = "";			
		var pubstrdum = cipherstr.slice(11,98);
		var keystr = makeshared(key,pubstrdum);
		var	ct = cipherstr.slice(98,cipherstr.length);
		cipherstr = '{"iv":"' + iv + '","salt":"' + salt + '","ct":"' + ct + '","ks":256,"iter":101}';	//add labels and keylength to data, minimum keystretching
		document.main.text.value = sjcl.decrypt(keystr,cipherstr).trim();
		if(!decoyOn) mainmsg.innerHTML = 'Unlock successful'
	}
	
	else if (type == "~"){																//secret Key encrypted item, such as a complete lockDB database
		if (learnOn){
			var reply = confirm("The message in the main box was locked with your secret Key, and will now be unlocked if your secret Key has been entered, and placed in the Locks screen so you can merge it into the stored database. Cancel if this is not what you want.");
			if(reply===false) throw("secret Key decryption canceled");
		};
		var key = readKey();
		document.lock.text.value = keyDecrypt(key,cipherstr);
		document.getElementById("lockmsg").innerHTML = 'Decrypted items. Click Merge or Save to add them to this device.';
		main2lock();
	}
	
	else if (type === "!"){							//regular asymmetric decryption
		if (learnOn){
			var reply = confirm("The message in the main box was locked with your personal Lock, and will now be unlocked if your secret Key has been entered, replacing the locked message. Cancel if this is not what you want.");
			if(reply===false) throw("public decryption canceled");
		};
		var key = readKey();
		var	iv = cipherstr.slice(0,22),													//get iv, salt, and later ct data and public key
			salt = cipherstr.slice(22,149);			
		if (decoyOn) decoydecrypt(iv,salt); 											//do decoy decryption first, in case regular fails
		var pubstrdum = cipherstr.slice(149,236);
		var keystr = makeshared(key,pubstrdum),
			ct = cipherstr.slice(236,cipherstr.length);
		cipherstr = '{"iv":"' + iv + '","salt":"' + salt + '","ct":"' + ct + '","ks":256,"iter":101}';	//add labels and keylength to data, minimum keystretching
		document.main.text.value = sjcl.decrypt(keystr,cipherstr);
		if (!decoyOn) mainmsg.innerHTML = 'Unlock successful'
	}	
	
	else if (type == "$"){							//PFS decryption
		if (learnOn){
			var reply = confirm("The message in the main box was locked in PFS mode with your personal Lock and will now be unlocked, replacing the locked message, if your secret Key has been entered. Cancel if this is not what you want.");
			if(reply===false) throw("public decryption canceled");
		};
		if (lockDB[name] == null){														//no name selected
			main2lock();
			lockmsg.innerHTML = '<span style="color:red">Select a sender with a valid Lock</span>';
			throw("invalid name")
		}
		var key = readKey();
		var lastKeycipher = lockDB[name][2],											//retrieve dummy Key from storage, [0] is the permanent Lock by that name
			turnstring = lockDB[name][4];												//this strings says whose turn it is to encrypt
		if (turnstring=='next lock'){
			var reply4 = confirm("It's not your turn to decrypt a PFS message from " + name + ". If you go ahead, the PFS conversation with this sender may become corrupted. Cancel if this is not what you want.");
			if(reply4===false) throw("PFS unlocking canceled");
		}
		if (lastKeycipher != null) {
			var lastKey = keyDecrypt(key,lastKeycipher)	
		} else {																		//if it doesn't exist, use permanent Key, or shared Key if no Lock
			if (pubstr.length == 87){
				lastKey = key
			} else {
				lastKey = pubstr
			}			
		}			
		var lastLockcipher = lockDB[name][3];										//short mode uses last Key and last Lock
		if (lastLockcipher != null) {												//if dummy exists, decrypt it first
			var lastLock = keyDecrypt(key,lastLockcipher)
		} else {																	//use permanent Lock, minus tags, if dummy doesn't exist
			if (pubstr.length != 87){
				main2lock();
				lockmsg.innerHTML = "<span style='color:red'>The recipient's Lock is needed</span>";	
				throw("no Lock found");
			}
			var lastLock = pubstr;
		}
		var	iv = cipherstr.slice(0,11),
			salt = "",
			newLock = cipherstr.slice(11,98),
			ct = cipherstr.slice(98,cipherstr.length),			
			keystr = makeshared(lastKey,lastLock),
			cipherstr2 = '{"iv":"' + iv + '","salt":"' + salt + '","ct":"' + ct + '","ks":256,"iter":101}';
		document.main.text.value = sjcl.decrypt(keystr,cipherstr2).trim();
		if (!decoyOn) mainmsg.innerHTML = 'Unlock successful. You can read this only once.'
		lockDB[name][3] = keyEncrypt(key,newLock);
		lockDB[name][4] = 'next lock';
		localStorage.lockDB = JSON.stringify(lockDB);
	}	
	
	else if (type === "#"){							//signed decryption
		if (learnOn){
			var reply = confirm("The message in the main box was locked with your Lock and the sender's Key, and will now be unlocked, replacing the locked message, if your secret Key has been entered. Cancel if this is not what you want.");
			if(reply===false) throw("signed decryption canceled");
		};
		if (pubstr == ''){
			main2lock();
			lockmsg.innerHTML = "<span style='color:red'>Enter the sender's Lock</span>";
			throw("lock box empty");
		}
		var key = readKey();
		if (lockDB[name]) var sharedKeycipher = lockDB[name][1];
		if (sharedKeycipher != null){
			var sharedKey = keyDecrypt(key,sharedKeycipher)
		} else {
			var sharedKey = makeshared(key,pubstr)
			if (lockDB[name]) {
				lockDB[name][1] = keyEncrypt(key,sharedKey);
				localStorage.lockDB = JSON.stringify(lockDB)
			}
		}
		var	iv = cipherstr.slice(0,11),
			salt = cipherstr.slice(11,71),
			ct = cipherstr.slice(71,cipherstr.length);
		if (decoyOn) decoydecrypt(iv,salt);
		var cipherstr2 = '{"iv":"' + iv + '","salt":"' + salt + '","ct":"' + ct + '","ks":256,"iter":101}';
		if (cipherstr.length == 159){
			document.main.text.value = sjcl.decrypt(sharedKey,cipherstr2).trim();
			if (!decoyOn) mainmsg.innerHTML = 'Unlock successful'
		}else{
			document.main.text.value = sjcl.decrypt(sharedKey,cipherstr2);
			if (!decoyOn) mainmsg.innerHTML = 'Unlock successful'
		}
	}
	
	else if (type === "@"){							//symmetric decryption
		if (learnOn){
			var reply2 = confirm("The message in the main box was locked with a shared Key, and will now be unlocked if the same Key is present in the Locks box. The result will replace the locked message. Cancel if this is not what you want.");
			if(reply2===false) throw("sym decryption canceled");
		};
		if (secstr == ''){
			main2lock();
			lockmsg.innerHTML = '<span style="color:red">Enter shared Key</span>';
			throw("symmetric key empty");
		}
		var	iv = cipherstr.slice(0,11),
			salt = cipherstr.slice(11,71),
			ct = cipherstr.slice(71,cipherstr.length);			
		var keystr = secstr;
		if (decoyOn) decoydecrypt(iv,salt);
		var iter = keyStrength(keystr,false);											//get number of iterations from Key strength meter
		var keyStretched=sjcl.codec.base64.fromBits(sjcl.misc.scrypt(keystr,salt,iter,8,1,33));
		var cipherstr2 = '{"iv":"' + iv + '","salt":"' + salt + '","ct":"' + ct + '","ks":256,"iter":101}';
		if (cipherstr.length == 159){
			document.main.text.value = sjcl.decrypt(keyStretched,cipherstr2).trim();
			if (!decoyOn) mainmsg.innerHTML = 'Unlock successful'
		}else{
			document.main.text.value = sjcl.decrypt(keyStretched,cipherstr2);
			if (!decoyOn) mainmsg.innerHTML = 'Unlock successful'
		}	
	}else{
		Encrypt_text()								//none of the known encrypted types, therefore encrypt rather than decrypt
	};
};

//decrypts a message encrypted for multiple recipients. Encryption can be signed, anonymous, or symmetric
function Decrypt_from_List(cipherArray){
	encrypting = true;
	var decoyOn = document.getElementById("decoymode").checked,
		learnOn = document.getElementById("learnmode").checked,
		keymsg = document.getElementById("keymsg"),
		mainmsg = document.getElementById("mainmsg"),
		lockmsg = document.getElementById("lockmsg");
	keymsg.innerHTML = "";
	mainmsg.innerHTML = "";
	var name = lockmsg.innerHTML,
		type = cipherArray[0].slice(0,1);
	for (var i=0; i < cipherArray.length; i++){
		cipherArray[i] = cipherArray[i].replace(/[^a-zA-Z0-9+/ ]+/g, '')				//take out anything that is not base64
	}
	var iv = cipherArray[0].slice(0,22);
	if (type == '!' || type == '$') {
		var salt = cipherArray[0].slice(22,149),
			pubstrdum = cipherArray[0].slice(149,236)	
	} else {
		var salt = cipherArray[0].slice(22,236)
	}
	if (decoyOn) decoydecrypt(iv,salt);													//decoy decryption
	var ct = cipherArray[cipherArray.length - 1],
		secstr = document.lock.text.value.trim(),
		pubstr = striptags(secstr);
		
	//now make the idtag to be searched for, depending on the type of encryption. First the shared Key that encrypts the idtag
	
	if (type == '#' || type == '$'){				//signed mode first, PFS is the same at this point
		if (learnOn){
			var reply = confirm("The contents of the message in the main box will be unlocked with your secret Key, provided you have placed the sender's Lock or shared Key in the Locks box. Cancel if this is not what you want.");
			if(reply===false) throw("signed list decryption canceled");
		}
		if (pubstr == ''){
			main2lock();
			lockmsg.innerHTML = "<span style='color:red'>Enter the sender's Lock or shared Key</span>";
			throw("lock box empty");
		}
		if (pubstr.length == 87){														//assuming this is a Lock, not a shared Key. See below for the other case
			var key = readKey();
			if (lockDB[name]) var sharedKeycipher = lockDB[name][1];					//get permanent shared Key from storage, or make it if not stored
			if (sharedKeycipher != null){
				var sharedKey = keyDecrypt(key,sharedKeycipher)
			} else {
				var sharedKey = makeshared(key,pubstr)
				if (lockDB[name]) {
					lockDB[name][1] = keyEncrypt(key,sharedKey);
					localStorage.lockDB = JSON.stringify(lockDB)
				}	
			}
			var string = lockDB['myself'][0];
			secstr = keyDecrypt(key,string.slice(1,string.length))						//this contains my Lock
		} else {																		//assuming it's a regular shared Key in common with the sender
			var sharedKey = secstr
		}
		
	} else {										//anonymous mode
		if (learnOn){
			var reply = confirm("The contents of the message in the main box will be unlocked with your secret Key. Cancel if this is not what you want.");
			if(reply===false) throw("anonymous list decryption canceled");
		}
		if (pubstr.length == 87 || pubstr == ''){
			if (key == null) var key = readKey();
			var sharedKey = makeshared(key,pubstrdum),
				string = lockDB['myself'][0];
			secstr = keyDecrypt(key,string.slice(1,string.length))
		} else {
			var sharedKey = secstr
		}
	}
	var iter = keyStrength(sharedKey,false);										//should be 2 for everything except bad shared Keys
	var keyStretched = sjcl.codec.base64.fromBits(sjcl.misc.scrypt(sharedKey,salt,iter,8,1,33));
	var	idtag = JSON.parse(sjcl.encrypt(sharedKey,secstr,{"iv":iv,"salt":salt,"ks":256,"iter":101})).ct.slice(0,11);
				
	//look for the id tag and return the string that follows it
	for (i = 1; i < cipherArray.length; i++){
		if (idtag == cipherArray[i]) {
			var msgkeycipher = cipherArray[i+1];
		}
	}
	
	//got the encrypted message key, now decrypt it, and finally the main message. The process for PFS mode is more involved
	if ((pubstr.length != 87) && (pubstr.length != 0)){
		var keyStretched = sjcl.codec.base64.fromBits(sjcl.misc.scrypt(sharedKey,salt,iter,8,1,33))
		var cipherstr2 = '{"iv":"' + iv + '","salt":"' + salt + '","ct":"' + msgkeycipher + '","ks":256,"iter":101}',
			msgkey = sjcl.decrypt(keyStretched,cipherstr2).trim();
	} else if (type != '$'){
		var cipherstr2 = '{"iv":"' + iv + '","salt":"' + salt + '","ct":"' + msgkeycipher + '","ks":256,"iter":101}',
			msgkey = sjcl.decrypt(sharedKey,cipherstr2).trim();
			
	//for PFS mode, first we separate the encrypted new Lock from the proper message key, then decrypt the new Lock and combine it with the stored Key (if any) to get the ephemeral shared Key, which unlocks the message Key
	} else {
		var newLockcipher = msgkeycipher.slice(0,127);
		msgkeycipher = msgkeycipher.slice(127,msgkeycipher.length);
		var cipherstr2 = '{"iv":"' + iv + '","salt":"' + salt + '","ct":"' + newLockcipher + '","ks":256,"iter":101}',
			newLock = sjcl.decrypt(sharedKey,cipherstr2).trim();
		var lastKeycipher = lockDB[name][2],											//retrieve dummy Key from storage
			turnstring = lockDB[name][4];												//this strings says whose turn it is to encrypt
		if (turnstring=='next lock'){
			var reply4 = confirm("It's not your turn to decrypt a PFS message from " + name + ". If you go ahead, the PFS conversation with this sender may become corrupted. Cancel if this is not what you want.");
			if(reply4===false) throw("PFS unlocking canceled");
		}
		if (lastKeycipher != null) {
			var lastKey = keyDecrypt(key,lastKeycipher)
		} else {																		//if a dummy Key doesn't exist, use permanent Key
			var lastKey = key
		}
		var	keystr = makeshared(lastKey,newLock),
			cipherstr2 = '{"iv":"' + iv + '","salt":"' + salt + '","ct":"' + msgkeycipher + '","ks":256,"iter":101}',
			msgkey = sjcl.decrypt(keystr,cipherstr2).trim();
		lockDB[name][3] = keyEncrypt(key,newLock);										//store the new dummy Lock
		lockDB[name][4] = 'next lock';
		localStorage.lockDB = JSON.stringify(lockDB);
	}	
	var cipherstr = '{"iv":"' + iv + '","salt":"' + salt + '","ct":"' + ct + '","ks":256,"iter":101}';
	document.main.text.value = sjcl.decrypt(msgkey,cipherstr);
	if (!decoyOn) mainmsg.innerHTML = 'Unlock successful'	
}

//decrypt the message hidden in the salt, for decoy mode
function decoydecrypt(iv,ct){
	var mainmsg = document.getElementById("mainmsg");
	mainmsg.innerHTML = "";
	if (document.getElementById("learnmode").checked === true){
		var	key2 = prompt("Decoy mode is selected, so please write the Password used to lock the hidden message. If you don't expect a hidden message, uncheck Decoy mode below.");
	} else {
	if (document.decoyOut.key.value.trim() == ""){										//stop to display the decoy key entry form if there is no key entered
		document.getElementById("decoyOut").style.display = "block";
		document.getElementById("shadow").style.display = "block";			
		throw ("stopped for decoy input")				
	}	
	var key2 = document.decoyOut.key.value,
		iter = keyStrength(key2,false);
	document.decoyOut.key.value = ""
	};
	var keyStretched = sjcl.codec.base64.fromBits(sjcl.misc.scrypt(key2,'',iter,8,1,33))
	var	cipherstr2 = '{"iv":"' + iv + '","salt":"' + "" + '","ct":"' + ct + '","ks":256,"iter":101}';
	mainmsg.innerHTML = 'Hidden message: <span style="color:blue">' + decodeURI(sjcl.decrypt(keyStretched,cipherstr2)) + '</span>'
};

//takes a SHA512 hash of the plaintext and generates an ECDSA signature
function Signhash(){
	var keymsg = document.getElementById("keymsg"),
		mainmsg = document.getElementById("mainmsg");
		keymsg.innerHTML = "";
		mainmsg.innerHTML = "";
	var secstr = readKey();
	if (document.getElementById("learnmode").checked === true){
		var reply = confirm("A signature matching the contents of the main box will be made using your secret Key, and the resulting signature will be added to the end of the main box. Cancel if this is not what you want.");
		if(reply===false) throw("signature canceled");
	};
	var pubstr = striptags(secstr);
	if (pubstr.length===87){															//this is a Lock, not a Key
		any2key();
		keymsg.innerHTML = '<span style="color:red">This is a Lock. Enter your Key here</span>';	
		throw("lock instead of key")
	};
	var hash = sjcl.hash.sha512.hash(document.main.text.value.trim()),					//take SHA512 hash of plaintext, trimming space at ends
		sec = toexponent(secstr),
		curve = sjcl.ecc.curves["c521"],
		R = curve.r,
		l = R.bitLength(),
    	k = sjcl.bn.random(R.sub(1), 0).add(1),
    	r = curve.G.mult(k).x.mod(R),
		s = sjcl.bn.fromBits(hash).add(r.mul(sec)).mul(k.inverseMod(R)).mod(R),
		sigstr = sjcl.codec.base64.fromBits(sjcl.bitArray.concat(r.toBits(l), s.toBits(l)));	//make it base64
	var iv = sjcl.codec.base64.fromBits(sjcl.random.randomWords('2','0')),				//for hidden message, if activated
		padding = makesalt(iv,40);
	if (document.getElementById("notags").checked === false){
			//strip initial "A" and add decoy iv & padding and tags
		document.main.text.value = document.main.text.value + "\n\n" + "PL17sig=" + sigstr.slice(1,sigstr.length) + iv.slice(0,11) + padding + "=PL17sig";
	}else{
		document.main.text.value = document.main.text.value + "\n\n" + sigstr.slice(1,sigstr.length) + iv.slice(0,11) + padding
	}
};	

//verifies the ECDSA signature of a hash of the plaintext, calls Signhash as appropriate. Algorithm from SJCL ecc.js, but not the latest version
function Verifyhash(){
	encrypting = false;
	var keymsg = document.getElementById("keymsg"),
		lockmsg = document.getElementById("lockmsg"),
		mainmsg = document.getElementById("mainmsg");
		keymsg.innerHTML = "";
		mainmsg.innerHTML = "";
	var text = document.main.text.value.trim();
	if (text==""){																		//nothing in text box
		mainmsg.innerHTML = '<span style="color:red">Nothing to sign or verify</span>';
		throw("no text")
	};
	var	sign = text.split(/\r?\n/);
		sign = sign[sign.length-1];														//this is a signature if added as last line of text
	var sigstr = striptags(sign);
	if (!(sigstr.length == 250)){													//no signature tag, therefore making sign	
		Signhash();
		throw("no signature, creating one")
	};
	var	pubstr = document.lock.text.value.trim();
	if (pubstr==""){
		main2lock();
		lockmsg.innerHTML = '<span style="color:red">Enter a Lock to verify the signature</span>';	
		throw("no lock present")
	};
	if (document.getElementById("learnmode").checked === true){
		var reply = confirm("The text in the main box has been signed with somebody's secret Key. I will now verify if the sign is correct for this text and the matching Lock, which should be present in the Locks box, and will display the result in a popup. Cancel if this is not what you want.");
		if(reply===false) throw("sign verification canceled");
	};
		pubstr = striptags(pubstr);
	if (!(pubstr.length == 87)){
		lockmsg.innerHTML = '<span style="color:red">Enter a valid Lock and try again</span>';
		throw("invalid public key")
	};
		text = text.replace(/\r?\n?[^\r\n]*$/, "");										//remove last line
	var hash = sjcl.hash.sha512.hash(text.trim()),										//take SHA512 hash of plaintext, ignoring initial and end spaces			
		curve = sjcl.ecc.curves["c521"],
		xstr = "A" + pubstr.slice(0,pubstr.length),
		ystr = yfromx(curve,xstr),
	 	pub = curve.fromBits(sjcl.codec.base64.toBits(xstr+ystr)),
		rs = sjcl.codec.base64.toBits("A" + sigstr.slice(0,175)),						//recover signature part
		w = sjcl.bitArray,
        R = curve.r,
        l = R.bitLength(),
        r = sjcl.bn.fromBits(w.bitSlice(rs,0,l)),
        s = sjcl.bn.fromBits(w.bitSlice(rs,l,2*l)),
		u = s.inverseMod(R),	
        hG = sjcl.bn.fromBits(hash).mul(u).mod(R),	
        hA = r.mul(u).mod(R),
		check = true,	
		r2 = curve.G.mult2(hG, hA, pub).x.mod(R);
		if (!r2.equals(r)){																//hack from when y is the wrong root of y^2
			var y = sjcl.bn.fromBits(sjcl.codec.base64.toBits(ystr)),
				p = curve.field.modulus.copy(),
				y2 = p.sub(y),															//this should be the right y
				ystr2 = sjcl.codec.base64.fromBits(y2.toBits());		
			pub = curve.fromBits(sjcl.codec.base64.toBits(xstr+ystr2));
			r2 = curve.G.mult2(hG, hA, pub).x.mod(R);
		};																				//end of wrong root hack
    if (r.equals(0) || s.equals(0) || r.greaterEquals(R) || s.greaterEquals(R) || !r2.equals(r)) check = false;
	if (check) {
		mainmsg.innerHTML = '<span style="color:green">The signature is VERIFIED</span>'
		}
	else {
		mainmsg.innerHTML = '<span style="color:magenta">The signature has FAILED verification</span>'
		};
	if (document.getElementById("decoymode").checked === true){							//this part to extract the hidden message, if it exists
		var iv = sigstr.slice(175,186),
			padding = sigstr.slice(186,250);
		decoydecrypt(iv, padding);
	};
};


//displays how many characters are left, in Short mode
function charsLeft(){
	var mainmsg = document.getElementById("mainmsg");
	if(document.getElementById("shortmode").checked){									//don't do anything unless it's short mode
		var chars = encodeURI(document.main.text.value).replace(/%20/g, ' ').length;
		var pubstr = striptags(document.lock.text.value);	
		if(pubstr.length != 87){														//symmetric mode, 58 chars
			var limit = 58
		} else if(document.getElementById("anonmode").checked){							//anonymous mode, 38 chars
			var limit = 38
		} else if(document.getElementById("signedmode").checked){						//signed mode, 58 chars
			var limit = 58
		} else if(document.getElementById("pfsmode").checked){							//pfs mode, 37 chars
			var limit = 37
		}
		if (chars <= limit){
			mainmsg.innerHTML = chars + " characters out of " + limit + " used"
		} else {
			mainmsg.innerHTML = '<span style="color:orange">Maximum length exceeded. The message will be truncated</span>'
		}
	} else {
		mainmsg.innerHTML = ''
	}
}

//formats results depending on tags present and sends to default email
function sendMail() {
	var	extramsg = document.getElementById("extramsg");
		extramsg.innerHTML = "";
	if (document.getElementById("learnmode").checked === true){
		var reply = confirm("A new tab will open, including the contents of this box in your default email. You still need to supply the recipient's address and a title. Only Locks and locked or signed text are allowed. Cancel if this is not what you want.");
		if(reply===false) throw("email canceled");
	};
	var cipherstr = document.extra.text.value;
	cipherstr = cipherstr.split("=").sort(function (a, b) { return b.length - a.length; })[0];
	var type = cipherstr.slice(0,1);
if (document.getElementById("notags").checked === false){							//add tags if checked, add explanatory text	
	if(type==="!"){
    	var link = "mailto:"+ "?subject=" + "&body=Message locked with PassLok v.1.7 %0D%0A%0D%0AUnlock with your secret Key. %0D%0A%0D%0A" + encodeURIComponent(document.extra.text.value) + "%0D%0A%0D%0AGet PassLok at http://passlok.com";
	} else if (type==="@"){
		var link = "mailto:"+ "?subject=" + "&body=Message locked with PassLok v.1.7 %0D%0A%0D%0AUnlock with shared Key. %0D%0A%0D%0A" + encodeURIComponent(document.extra.text.value) + "%0D%0A%0D%0AGet PassLok at http://passlok.com";
	} else if (type==="#"){
		var link = "mailto:"+ "?subject=" + "&body=Message locked with PassLok v.1.7 %0D%0A%0D%0AUnlock with your secret Key and the sender's Lock. %0D%0A%0D%0A" + encodeURIComponent(document.extra.text.value) + "%0D%0A%0D%0AGet PassLok at http://passlok.com";
	} else if (type==="$"){
		var link = "mailto:"+ "?subject=" + "&body=PFS message locked with PassLok v.1.7 %0D%0A%0D%0AUnlock with your secret Key and the sender's Lock. %0D%0A%0D%0A" + encodeURIComponent(document.extra.text.value) + "%0D%0A%0D%0AGet PassLok at http://passlok.com";
	} else if (cipherstr.length===87){
		var link = "mailto:"+ "?subject=" + "&body=This is my PassLok v.1.7 Lock, use it to send me messages and verify my signature. %0D%0A%0D%0A" + encodeURIComponent(document.extra.text.value) +"%0D%0A%0D%0AGet PassLok at http://passlok.com";		
	} else if (cipherstr.length===160){
		var link = "mailto:"+ "?subject=" + "&body=Short message locked with PassLok v.1.7 %0D%0A%0D%0AStrip everything but the locked message and unlock normally.%0D%0A%0D%0A" + encodeURIComponent(document.extra.text.value) + "%0D%0A%0D%0AGet PassLok at http://passlok.com";
	} else if (cipherstr.length===250){
		var link = "mailto:"+ "?subject=" + "&body=The following is a text signed with PassLok v.1.7. Verify using the signer's Lock.%0D%0A%0D%0AGet PassLok at http://passlok.com%0D%0A%0D%0AThe text, followed by the signature,  BEGINS BELOW THIS LINE:%0D%0A%0D%0A" + encodeURIComponent(document.extra.text.value);
			
	} else {																		//may be a longish signed text, so try a little harder
		var cipherstrArray = document.extra.text.value.split('\n'),
			length = cipherstrArray.length,
			cipherstr = cipherstrArray[length-1];
		cipherstr = cipherstr.split("=").sort(function (a, b) { return b.length - a.length; })[0];
		if (cipherstr.length==250){
			var link = "mailto:"+ "?subject=" + "&body=The following is a text signed with PassLok v.1.7. Verify using the signer's Lock.%0D%0A%0D%0AGet PassLok at http://passlok.com%0D%0A%0D%0AThe text, followed by the signature,  BEGINS BELOW THIS LINE:%0D%0A%0D%0A" + encodeURIComponent(document.extra.text.value);			
		} else {
			extramsg.innerHTML = 'Only Locks, and locked or signed text are allowed for Email';
			throw("illegal text")
		}
	}
}else{																				//tags unchecked, no extra text
	if((type=="!")||(type=="@")||(type=="#")||(type=="$")||(cipherstr.length==87)||(cipherstr.length==250)||(cipherstr.length==160)){
		var link = "mailto:"+ "?subject=" + "&body=" + encodeURIComponent(document.extra.text.value);
	}else{
		extramsg.innerHTML = '<span style="color:red">Only Locks, and locked or signed text are allowed for Email</span>';		
		throw("illegal text")
	}
}
	if(typeof window.orientation !== 'undefined'){ 	 								//new window for PC, same window for mobile
		window.open(link,"_parent")
	} else {
		window.open(link,"_blank")
	}
}

//calls SMS app (works on mobile only)
function sendSMS() {
	if (document.getElementById("learnmode").checked === true){
		var reply = confirm("The default SMS (texting) app will now open. You need to have copied your short locked message to the clipboard before doing this, if you want to send one. This only works in smartphones. Cancel if this is not what you want.");
		if(reply===false) throw("SMS canceled");
	};
	if(typeof window.orientation !== 'undefined') window.open("SMS:","_parent");
};

//this function implements the Shamir Secret Sharing Scheme, taking the secret from the key box and putting the result in the main box, and vice-versa. To do: capture errors due to insufficient or malformed parts
function secretshare(){
	var learnOn = document.getElementById("learnmode").checked;
	var extramsg = document.getElementById("extramsg"),
		mainmsg = document.getElementById("mainmsg");
	var main = document.main.text.value.trim(),
		sec = document.extra.text.value;
	if((main.slice(0,8).match(/p\d{3}/) && main.slice(0,2)=='PL') || (main.match(/\n\nA/) && main.slice(0,1)=='A')){		//main box has parts: join parts or make one more part
		var shares = main.replace(/\n\s*\n/g, '\n').split("\n"),					//go from newline-containing string to array
			n = shares.length,
			quorumarr = main.match(/p\d{3}/);															//quorum in tags is "p" plus 3 digits in a row, first instance
		if(quorumarr == null) {var quorum = n} else {var quorum = parseInt(quorumarr[0].slice(1,4))};	//if tags are missing, ignore quorum, otherwise read it form tags
		if(n < quorum){																//not enough parts
			extramsg.innerHTML = '<span style="color:red">According to the tags, you need ' + (quorum - n) + ' more parts in the main box</span>'
		};	
		for (var i=0; i < shares.length; i++) {
			shares[i] = shares[i].split("=").sort(function (a, b) { return b.length - a.length; })[0];	//remove tags
			var isLock = shares[i].length;
			shares[i] = "8" + sjcl.codec.hex.fromBits(sjcl.codec.base64.toBits(shares[i].replace(/[^a-zA-Z0-9+/ ]+/g, '')));	//retrieve from base64 back to hex and add initial "8" to each item
		};
		if(sec == ""){																//box empty: join parts from main box
			if (learnOn){
				var reply = confirm("The parts in the main box will be joined to retrieve the original item, which will be placed in this box. Please make sure that there are enough parts. Cancel if this is not what you want.");
				if(reply===false) throw("SSSS join canceled");
			};
			if(n === 1){
				extramsg.innerHTML = '<span style="color:red">Only one part in main box</span>';
				throw("insufficient parts")
			};
			var	sechex = secrets.combine(shares),
				secret = sjcl.codec.utf8String.fromBits(sjcl.codec.hex.toBits(sechex));
			document.extra.text.value = secret;
			extramsg.innerHTML = 'Join successful';
		} else {																	//box not empty: add a part to the main box instead
			if (learnOn){
				var reply = confirm("Provided there are sufficient parts in the main box, an additional part will be added to the main box.  Cancel if this is not what you want.");
				if(reply===false) throw("SSSS part addition canceled");
			};
			if(n > 254){
				extramsg.innerHTML = '<span style="color:red">Maximum number of parts is 255</span>';		
				throw("max part number reached")
			} else if(isLock === 87){
				extramsg.innerHTML = '<span style="color:red">The main box contains a Lock. Delete it and try again</span>';
				throw("Lock instead of parts")
			} else if(isLock === 250){
				extramsg.innerHTML = '<span style="color:red">The main box contains a signature. Delete it and try again</span>';		
				throw("signature instead of parts")
			} else if(n === 1){
				extramsg.innerHTML = '<span style="color:red">You need more than one part in the main box</span>';				
				throw("insufficient parts")
			};
			var	sechex = secrets.combine(shares),									//first check that the box has the right Key = parts in the main box are good
				secret = sjcl.codec.utf8String.fromBits(sjcl.codec.hex.toBits(sechex));
			if(sec===secret){														//if OK, add more parts. Get index as the highest of all the indices present
				var maxindex = 1,
					index = 1;
				for (var i=0; i < shares.length; i++) {								//get greatest index on the set
					index = parseInt(shares[i].slice(1,3),16);
					if (index > maxindex){maxindex = index};
				};
				var	newshare = secrets.newShare(maxindex+1,shares);
					shares = shares.concat(newshare);
				displayshare(shares,quorum);										//required number of parts was read from tag
				extramsg.innerHTML = 'Part added to main box';
				parsInBox = true
			} else {
				extramsg.innerHTML = '<span style="color:red">Wrong item in the box. Please delete it and try again</span>';
				throw("bad item in extra box");	
			};				
		};
	} else {																		//main box empty: split secret in the box
		if (sec == "") {
			extramsg.innerHTML = '<span style="color:red">The box is empty</span>';
			throw("No key in the key box")
		};
		if (learnOn){
			var reply = confirm("The item in the box will be split into several partial items, which will replace the contents of the main box. A popup will ask for number of parts needed to reconstruct the original item. Extra parts can be made by clicking Split/Join again. Cancel if this is not what you want.");
			if(reply===false) throw("SSSS split canceled");
		};
		if (document.partsIn.text.value.trim() == ""){								//stop to display the entry form if it is empty
			document.getElementById("partsIn").style.display = "block";
			document.getElementById("shadow").style.display = "block";			
			throw ("stopped for # of parts input")				
		}	
		var quorum = document.partsIn.text.value;									//on re-execution, read the box and reset it
		document.partsIn.text.value = "";
		quorum = parseInt(quorum);
		if(quorum < 2){quorum = 2} else if(quorum > 255) {quorum = 255};
		var	sechex = sjcl.codec.hex.fromBits(sjcl.codec.utf8String.toBits(document.extra.text.value)),
			shares = secrets.share(sechex,quorum,quorum);
		displayshare(shares,quorum);
		extramsg.innerHTML = '<span style>' + quorum + ' parts in main box</span>';
		partsInBox = true
	};
	document.getElementById("partsIn").style.display = "none";
	document.getElementById("shadow").style.display = "none"
};

function displayshare(shares,quorum){
	var length = shares[0].length,
		quorumst = "00" + quorum,
		tagsOff = document.getElementById("notags").checked;
		quorumst = quorumst.substr(quorumst.length-3);
		
	//strip initial "8" and display each share in a new line, base 64, with tags
	if(!tagsOff){	
		var	output = "PL17p" + quorumst + "=" + sjcl.codec.base64.fromBits(sjcl.codec.hex.toBits(shares[0].slice(1,length))).replace(/=+/g, '') + "=PL17p" + quorumst;	
	
	//trim final "=" and display with tags
	}else{
		var	output = sjcl.codec.base64.fromBits(sjcl.codec.hex.toBits(shares[0].slice(1,length))).replace(/=+/g, '')
	}
	for (var i=1; i < shares.length; i++) {
		if(!tagsOff){
			output = output + "\n\n" + "PL17p" + quorumst + "=" + sjcl.codec.base64.fromBits(sjcl.codec.hex.toBits(shares[i].slice(1,length))).replace(/=+/g, '') + "=PL17p" + quorumst;
		}else{
			output = output + "\n\n" + sjcl.codec.base64.fromBits(sjcl.codec.hex.toBits(shares[i].slice(1,length))).replace(/=+/g, '')
		}
	};	
	document.main.text.value = output;
};

//this looks for a string in the blacklist array and refuses to take it as a Key or decoy password if it is found there
function checkBlacklist(string){
//this makes an array with the 500 most frequent passwords as of 2008, from www.whatsmypass.com/the-top-500-worst-passwords-of-all-time, plus a few more
var blacklist = "i2e4sg password i2e4sgtb i2e4 pussy i2e4s dragon qwerty gggggg mustang letmein baseball master michael football shadow monkey abci2e pass fuckme gggg jordan harley ranger iwantu jennifer hunter fuck 2ooo test batman trustnoi thomas tigger robert access love buster i2e4sgt soccer hockey killer george sexy andrew charlie superman asshole fuckyou dallas jessica panties pepper iiii austin william daniel golfer summer heather hammer yankees joshua maggie biteme enter ashley thunder cowboy silver richard fucker orange merlin michelle corvette bigdog cheese matthew i2i2i2 patrick martin freedom ginger blowjob nicole sparky yellow camaro secret dick falcon taylor iiiiii ieieie i2ei2e bitch hello scooter please porsche guitar chelsea black diamond nascar jackson cameron gs4e2i computer amanda wizard xxxxxxxx money phoenix mickey bailey knight iceman tigers purple andrea horny dakota aaaaaa player sunshine morgan starwars boomer cowboys edward charles girls booboo coffee xxxxxx bulldog nccitoi rabbit peanut john johnny gandalf spanky winter brandy compaq carlos tennis james mike brandon fender anthony blowme ferrari cookie chicken maverick chicago joseph diablo sexsex hardcore willie welcome chris panther yamaha justin banana driver marine angels fishing david maddog hooters wilson butthead dennis fucking captain bigdick chester smokey xavier steven viking snoopy blue eagles winner samantha house miller flower jack firebird butter united turtle steelers tiffany zxcvbn tomcat golf bondoot bear tiger doctor gateway gators angel junior thxiieb porno badboy debbie spider melissa booger i2i2 flyers fish porn matrix teens scooby jason walter cumshot boston braves yankee lover barney victor tucker princess mercedes siso doggie zzzzzz gunner horney bubba 2ii2 fred johnson xxxxx tits member boobs donald bigdaddy bronco penis voyager rangers birdie trouble white topgun bigtits bitches green super qazwsx magic lakers rachel slayer scott 2222 asdf video london tttt marlboro srinivas internet action carter jasper monster teresa jeremy iiiiiiii bill crystal peter pussies cock beer rocket theman oliver prince beach amateur ttttttt muffin redsox star testing shannon murphy frank hannah dave eaglei iiiii mother nathan raiders steve forever angela viper oubi2 jake lovers suckit gregory buddy whatever young nicholas lucky helpme jackie monica midnight college baby cunt brian mark startrek sierra leather 2e2e2e 4444 beavis bigcock happy sophie ladies naughty giants booty blonde fucked golden o fire sandra pookie packers einstein dolphins o chevy winston warrior sammy slut bgtseog zxcvbnm nipples power victoria asdfgh vagina toyota travis hotdog paris rock xxxx extreme redskins erotic dirty ford freddy arsenal accessi4 wolf nipple iloveyou alex florida eric legend movie success rosebud jaguar great cool cooper ieie scorpio mountain madison gbtgs4 brazil lauren japan naked squirt stars apple alexis aaaa bonnie peaches jasmine kevin matt qwertyui danielle beaver 4e2i 4i2b runner swimming dolphin gordon casper stupid shit saturn gemini apples august eeee canada blazer cumming hunting kitty rainbow ii22ee arthur cream calvin shaved surfer samson kelly paul mine king racing ssss eagle hentai newyork little redwings smith sticky cocacola animal broncos private skippy marvin blondes enjoy girl apollo parker qwert time sydney women voodoo magnum juice abgrtyu tttttt dreams maxwell music rush2ii2 russia scorpion rebecca tester mistress phantom billy gggg albert asdfg zxcvb passwordi opensesame ggg i2e4sgtbg i2e4sgtbgo key keys lock locks mykey masterkey passlok passlock decoy decoypassword correcthorsebatterystaple".split(' ');

	var keymsg = document.getElementById("keymsg");			//take into account common substitutions, ignore spaces and case
	if(blacklist.indexOf(string.toLowerCase().replace(/[$5]/g,'s').replace(/[0]/g,'o').replace(/[@]/g,'a').replace(/[!1]/g,'i').replace(/[3]/g,'e').replace(/[7]/g,'t').replace(/[8]/g,'b').replace(/[69]/g,'g').replace(/\s/g,'')) != -1){
		if(document.getElementById("keyscr").style.display == "block"){
			keymsg.innerHTML = '<span style="color:purple">This is a known bad Key. Choose another</span>'
		} else if(document.getElementById("decoyIn").style.display == "block"){
			decoymsg.innerHTML = '<span style="color:purple">This is a known bad Password. Choose another</span>'
		}
		throw("Key blacklisted");
	}
}

//The following code is to convert the contents of main box into fake text, and backward. This can be useful against email scanners.

if (typeof code == 'undefined'){			//default text for base64 to words conversion, global variable
	var covertext = "The licenses for most software and other practical works are designed to take away your freedom to share and change the works. By contrast, the GNU General Public License is intended to guarantee your freedom to share and change all versions of a program to make sure it remains free software for all its users. We, the Free Software Foundation, use the GNU General Public License for most of our software; it applies also to any other work released this way by its authors. You can apply it to your programs, too. When we speak of free software, we are referring to freedom, not price. Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for them if you wish), that you receive source code or can get it if you want it, that you can change the software or use pieces of it in new free programs, and that you know you can do these things. To protect your rights, we need to prevent others from denying you these rights or asking you to surrender the rights. Therefore, you have certain responsibilities if you distribute copies of the software, or if you modify it: responsibilities to respect the freedom of others. For example, if you distribute copies of such a program, whether gratis or for a fee, you must pass on to the recipients the same freedoms that you received. You must make sure that they, too, receive or can get the source code. And you must show them these terms so they know their rights. Developers that use the GNU GPL protect your rights with two steps: (1) assert copyright on the software, and (2) offer you this License giving you legal permission to copy, distribute and or modify it. For the developers' and authors' protection, the GPL clearly explains that there is no warranty for this free software. For both users' and authors' sake, the GPL requires that modified versions be marked as changed, so that their problems will not be attributed erroneously to authors of previous versions.";
		covertext = covertext.replace(/   +/g, "\t").replace(/  +/g, " ").replace(/\n /g,"\n\t");	//remove multiple spaces, space after linefeed
	var code = covertext.toLowerCase().replace(/[\.,-\/#!$%\^&\*;:{}=\-_`~()'"]|_/g, "").replace(/\s+/g, " ").split(" ");
		code = code.filter(function(n){return n});													//remove nulls
		code = code.filter(function(elem, pos, self) {return self.indexOf(elem) == pos;});			//global array containing the words, no duplicates
	var keystr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=~!@#$%" + "\n",	//base64 plus other characters used in PassLok strings
		remainder = code.length % keystr.length,
		noptions = Math.floor(code.length / keystr.length);
}

//This function checks for words or spaces encoding and calls the approrpiate decoders. If no encoding is detected, it calls the words encoder
function words(){
	var extramsg = document.getElementById("extramsg");
		extramsg.innerHTML = "";
	if(document.extra.text.value.match(/  +/g) != null) {								//detect double spaces and if there are any invoke spaces decoder
		fromSpaces()	
	}else{
		var text = document.extra.text.value;											//get rid of null characters, if any
		if(text.trim() == ""){
			extramsg.innerHTML = '<span style="color:red">No text in the box</span>';
			throw("no text")
		}
		var	textlow = text.toLowerCase().replace(/[,\.]+/g,'').replace(/\n+/g,' '),		//make lowercase and strip periods, commas and newlines
			textvector = textlow.split(" "),											//break up the main box into an array of words
			inwords = true,
			indices = new Array();
		for (var i = 0; i < textvector.length; i++){									//find the words in the covertext
			var index = searchStringInArray(textvector[i],code);
			indices[i] = index;															//put the indices into an array
			if(index == -1) inwords = false												//if any word is not in the covertext, this was not encoded with Words method
		}
		if (inwords) {																	//if encoded in words, call words decoder
			fromWords(indices);
			extramsg.innerHTML = 'Message extracted from Words encoding'
		} else {																		//otherwise call words encoder
			toWords(text);
			extramsg.innerHTML = 'Message encoded into words of this text. Decoding requires the same Cover text'
		}
	}
}

//this is almost the same as above, but if it doesn't detect encoding present, it calls the spaces encoder instead
function spaces(){
	var extramsg = document.getElementById("extramsg");
		extramsg.innerHTML = "";
	if(document.extra.text.value.match(/  +/g) != null) {								//detect double spaces and if there are any invoke spaces decoder
		fromSpaces()
	}else{
		var text = document.extra.text.value;
		if(text.trim() == ""){
			extramsg.innerHTML = '<span style="color:red">No text in the box</span>';
			throw("no text");
		}
		var	textlow = text.toLowerCase().replace(/[,\.]+/g,'').replace(/\n+/g,' '),		//make lowercase and strip periods, commas and newlines
			textvector = textlow.split(" "),											//break up the main box into an array of words
			inwords = true,
			indices = new Array();
		for (var i = 0; i < textvector.length; i++){									//find the words in the covertext
			var index = searchStringInArray(textvector[i],code);
			indices[i] = index;															//put the indices into an array
			if(index == -1) inwords = false												//if any word is not in the covertext, this was not encoded with Words method
		}
		if (inwords) {																	//if encoded in words, call words decoder
			fromWords(indices);
			extramsg.innerHTML = 'Message extracted from Words encoding'
		} else {																		//otherwise call spaces encoder
			toSpaces();
			if(extramsg.innerHTML=="") extramsg.innerHTML = 'Message encoded into spaces of this text. Decoding does not require the same Cover text'
		}
	}
}

//the following two are to encode or decode each character of the main box into a word from the covertext
function toWords(text){
	var extramsg = document.getElementById("extramsg");
		extramsg.innerHTML = "";
	if (document.getElementById("learnmode").checked === true){
			var reply = confirm("The contents of the main box will be replaced with fake text containing it in encoded form. The recipient must have the same Cover text. Cancel if this is not what you want.");
			if(reply===false) throw("toWords canceled");
	}
		var output = code[randomindex(keystr.indexOf(text[0]))];
		for (var i = 1; i < text.length; i++){
			var index = keystr.indexOf(text[i]);
			if(index == -1){
				extramsg.innerHTML = '<span style="color:red">This text contains illegal characters for a PassLok string</span>'; 
				throw("illegal characters in the main box")
			}
			output = output + randompunct() + code[randomindex(index)]					//add some random commas and periods, and spaces between words
		}
		//capitalize initial and after period, add final period.
		output = output.replace(/[.][\s\n][a-z]/g,function(a){return a.toUpperCase();}).replace(/[a-z]/,function(a){return a.toUpperCase();}) + ".";
		document.extra.text.value = output
}

function fromWords(indices){
	if (document.getElementById("learnmode").checked === true){
		var reply = confirm("The encoded text in the main box will be replaced with the original text from which it came. Cancel if this is not what you want.");
		if(reply===false) throw("fromWords canceled");
	}
		var output = "";
		for (var i = 0; i < indices.length; i++){
			output = output + keystr[indices[i] % keystr.length]
		}
		document.extra.text.value = output		
}

//Computes an index taking the full range of words in the covertext
function randomindex(index){
	if(index >= remainder){
		var choice = Math.floor(Math.random() * noptions)
	}else{
		var choice = Math.floor(Math.random() * (noptions + 1))
	}
	return index + choice*keystr.length
}

//To find words in the code. Returns the index if found, or -1 if not found
function searchStringInArray (str, strArray) {
    for (var j = 0; j < strArray.length; j++) {
        if (strArray[j] == str) return j;
    }
    return -1;
}

//This is to generate random periods, commans and newlines, per the percentage brackets below, plus spaces when appropriate
function randompunct(){
	var percent = Math.ceil(Math.random() * 100);
	if (percent < 7) {
		return ". "
	} else if(percent < 13) {
		return ", "
	} else if(percent < 14) {
		return ".\n"	
	} else {
		return " "
	}
}

//the following functions are to hide text into a text cover, as binary double spaces. It needs 7 cover words for each ASCII characters, 42 for non-ASCII
function encoder(bin){
	var textsplit = covertext.split(" ");
	var spaces = textsplit.length - 1;
	var missing = bin.length - spaces;
	var turns = 0;
	if (spaces < bin.length){
		while (spaces < bin.length){
			textsplit = textsplit.concat(covertext.split(" "));
			spaces = textsplit.length - 1;
			turns = turns + 1
		}
		extramsg.innerHTML = '<span style="color:red">The cover text was too short. It was repeated ' + turns + ' times. If this is not acceptable, repeat with a larger cover.</span>'; 
	}
		textsplit = textsplit.slice(0,bin.length+2);
	var newtext = textsplit[0];
	for(var i=0; i < textsplit.length-1; i++){
		newtext = newtext + stegospace(bin.slice(i,i+1)) + textsplit[i+1]
	}
	return newtext
}

function decoder(text){
	var bin = "";
	var textsplit = text.split(" ");
	for(var i=1; i < textsplit.length-1; i++){
		if (textsplit[i] == ""){
			bin = bin + "1";
			i = i + 1					//skip next word
		}else{
			bin = bin + "0"
		}
	}
	return bin
}

function stegospace(bin){
	if(bin == "1"){
		return "  "						//double space
	}else{
		return " "						//regular space
	}
}

function toSpaces() {
	var extramsg = document.getElementById("extramsg");
		extramsg.innerHTML = "";
	if (document.getElementById("learnmode").checked === true){
		var reply = confirm("The contents of the main box will be replaced with encoded text which contains the original text as irregular spacing. Cancel if this is not what you want.");
		if(reply===false) throw("toSpaces canceled");
	}	
  var output=""; 
	var input = document.extra.text.value.trim();
    for (var i=0; i < input.length; i++) {
		if(keystr.indexOf(input[i]) == -1){
			extramsg.innerHTML = '<span style="color:red">This text contains illegal characters for a PassLok string</span>'; 			
			throw("illegal characters in the main box")
		}
		var bin = "000" + input[i].charCodeAt(0).toString(2);
        output = output + bin.slice(bin.length-7,bin.length);
    }
	document.extra.text.value = encoder(output)
}

function fromSpaces() {
	if (document.getElementById("learnmode").checked === true){
		var reply = confirm("The encoded text in the main box will be replaced with the original text from which it came. Cancel if this is not what you want.");
		if(reply===false) throw("fromWords canceled");
	}
	var extramsg = document.getElementById("extramsg");
	var output=""; 
	var input=decoder(document.extra.text.value);
    for (var i=0; i < input.length; i=i+7) {
		var bin = input.slice(i,i+7);
        output = output + String.fromCharCode(parseInt(bin,2));
    }
	document.extra.text.value = output.replace(/\x00/g,'');							//take out nulls, in case text was added to finish the last sentence.
	extramsg.innerHTML = 'Message extracted from Spaces encoding'
}

//this one is to display the cover text or change it as requested
function newcover(string){
	var extramsg = document.getElementById("extramsg");
		extramsg.innerHTML = "";
	if(string.trim() == ""){														//if the box is empty display the cover text
		if (document.getElementById("learnmode").checked === true){
			var reply = confirm("The cover text will be displayed in the main box. Cancel if this is not what you want.");
			if(reply==false) throw("covertext display canceled");
		}	
		document.extra.text.value = covertext
	}else{																			//otherwise store new cover text
		if (document.getElementById("learnmode").checked === true){
			var reply = confirm("If you go ahead, the cover text will be replaced with the contents of this box, which will be deleted.");
			if(reply==false) throw("covertext change canceled");
		}	
		var newcovertext = string.replace(/   +/g, "\t").replace(/  +/g, " ").replace(/\n /g,"\n\t");				//remove multiple spaces, spaces after linefeed
		if (newcovertext.match(/[\u3400-\u9FBF]/) != null) newcovertext = newcovertext.split('').join(' ').replace(/  +/g, ' ');		//add spaces if Chinese, Korean, or Japanese
		var	newcode = newcovertext.toLowerCase().replace(/[\.,-\/#!$%\^&\*;:{}=\-_`~()'"]|_/g, "").replace(/\s+/g, " ").split(" ");  	//removes punctuation, collapses spaces to single space
			newcode = newcode.filter(function(n){return n});																			//remove nulls
			newcode = newcode.filter(function(elem, pos, self) {return self.indexOf(elem) == pos;});									//remove repeats
		if (newcode.length >= keystr.length){										//enough length for words method
			code = newcode;															//store into global variables
			covertext = newcovertext;			
			remainder = code.length % keystr.length;
			noptions = Math.floor(code.length / keystr.length);
			document.extra.text.value = "";
			extramsg.innerHTML = 'Cover text changed'
		} else {
			extramsg.innerHTML = '<span style="color:red">This text is too short for a Cover</span>';
			throw("text sample too short");
		}	
	}
}      

//get name and Lock from form and merge them with the lockDB object, then store
function addLock(){
	if (document.getElementById("learnmode").checked === true){
		var reply = confirm("The item in the box will be added to the permanent directory. Cancel if this is not what you want.");
		if(reply==false) throw("lockDB add canceled");
	}
	var lockmsg = document.getElementById("lockmsg");
	var name = document.lockname.text.value.trim(),
		lock = document.lock.text.value.trim();
	if (lock ==''){
		var ran = true;
		lock = sjcl.codec.base64.fromBits(sjcl.random.randomWords('17','0')).slice(0,86);   //make a random Key and store it below if a name is provided
		document.lock.text.value = lock;
	}
	if (name !=''){
		var key = readKey();
			lock = '~' + keyEncrypt(key,lock);												//add prefix so it can be identified as encrypted
		var newEntry = JSON.parse('{"' + name + '":["' + lock + '"]}');
			lockDB = sortObject(mergeObjects(lockDB,newEntry));
			localStorage.lockDB = JSON.stringify(lockDB);
			lockNames = [''].concat(Object.keys(lockDB));
		if (ran) {lockmsg.innerHTML = 'Random Key stored'} else {lockmsg.innerHTML = 'Item stored'}
	} else {
		lockmsg.innerHTML = '<span style="color:red">Cannot save without a name</span>'	
	}
}

//delete a particular key in Object lockDB, then store
function removeLock(){
	if (document.getElementById("learnmode").checked === true){
		var reply = confirm("The item displayed in the box will be removed from the permanent directory. This is irreversible. Cancel if this is not what you want.");
		if(reply==false) throw("lockDB remove canceled");
	}
	var lockmsg = document.getElementById("lockmsg");
	var name = lockmsg.innerHTML;
	if (lockDB[name] == null){
		lockmsg.innerHTML = 'To remove an item, its name must be displayed <strong>here</strong>';
		throw('bad name')
	}
	delete lockDB[name];
	localStorage.lockDB = JSON.stringify(lockDB);
	lockNames = [''].concat(Object.keys(lockDB));
	lockmsg.innerHTML = name + ' deleted'
}

//this is to just delete the PFS data for a particular key (or reset the current list)
function resetPFS(){
	var lockmsg = document.getElementById("lockmsg");
	if (document.lock.text.value.trim().split('\n').length > 1){		//use button to reset current list if a list is displayed, nothing to do with normal use
		if (document.getElementById("learnmode").checked === true){
			var reply = confirm("The list currently being formed will be reset. Cancel if this is not what you want.");
			if(reply==false) throw("PFS reset canceled");
		}
		currentList = '';
		lockmsg.innerHTML = 'Current list reset';
		return
	}
	
	//now the real stuff
	if (document.getElementById("learnmode").checked === true){
		var reply = confirm("The data needed to maintain a PFS conversation with this sender/recipient will be deleted, so the ongoing conversation cannot be continued. This is irreversible. Cancel if this is not what you want.");
		if(reply==false) throw("PFS reset canceled");
	}
	var name = lockmsg.innerHTML;
	if (lockDB[name] == null){
		lockmsg.innerHTML = 'The item to be reset must be displayed first';
		throw('bad name')
	}
	if ((lockDB[name][1] == null) && (lockDB[name][2] == null) && (lockDB[name][3] == null)){
		lockmsg.innerHTML = 'Nothing to reset';
		throw('no PFS data')
	}
	lockDB[name].splice(1,4);
	localStorage.lockDB = JSON.stringify(lockDB);
	lockmsg.innerHTML = 'PFS data for ' + name + ' deleted'
}

//searches for name in Locks database and returns the Lock, displays full name as well. Invoked as the user types
function findLock(){
	var lockmsg = document.getElementById("lockmsg");
	lockmsg.innerHTML = '';
	var string = document.lockname.text.value;
	var index = searchStringInArrayDB(string,lockNames);
	if (index > 0){
		var name = lockNames[index];
		lockmsg.innerHTML = name;
		document.lock.text.value = lockDB[name][0]
	}else{
		lockmsg.innerHTML = '';
		document.lock.text.value = ''
	}	
}

//if a newline is entered, puts the expanded contents of the name box in the lock box, and waits for another item
var currentList = '';

function addToList(){
	if (document.getElementById("learnmode").checked === true){
		var reply = confirm("The item displayed will be added to the current list. Cancel if this is not what you want.");
		if(reply==false) throw("add to list canceled");
	}
	var lockmsg = document.getElementById("lockmsg"),
		currentItem = document.lock.text.value;
	if(lockmsg.innerHTML != ''){
		var namenumber = currentItem.split('\n').length
		if (namenumber > 1 || document.lockname.text.value==''){	//if the item is itself a list or there is no name, add the contents rather than the displayed name
			if(currentList == ''){	
				currentList = currentItem
			}else{
				currentList = currentList + '\n' + currentItem				
			}
			lockmsg.innerHTML = namenumber + ' items added to the current list'
		} else {
			if(currentList == ''){
				currentList = lockmsg.innerHTML				
			}else{
				currentList = currentList + '\n' + lockmsg.innerHTML
			}
			lockmsg.innerHTML = lockmsg.innerHTML + ' added to the current list'
		}
	} else {
		if (currentList !=''){
			lockmsg.innerHTML = 'This is the (temporary) current list'
		} else {
			lockmsg.innerHTML = 'No items on the current list'
		}
	}
	var listArray = currentList.replace(/\n+/g,'\n').split('\n');
	listArray = listArray.filter(function(elem, pos, self) {return self.indexOf(elem) == pos;});	//remove duplicates
	currentList = listArray.join('\n');
	document.lock.text.value = currentList.trim();
	currentList = document.lock.text.value;
}

//automatically decrypts an item stored encrypted in the lockDB database. It uses the permanent Key
function decryptItem(){
	var	key = readKey(),
		string = document.lock.text.value.trim();
	if(string == "") throw('nothing to decrypt');
	string = string.slice(1,string.length);															//strip initial '~'
	document.lock.text.value = keyDecrypt(key,string);
	document.getElementById("mainmsg").innerHTML = 'Item ready'
}

//add a few spaces and newlines, then remove brackets, etc., extra spaces, put in alphabetical order
function showLockDB(){
	if (document.getElementById("learnmode").checked === true){
		var reply = confirm("The complete directory of Locks, shared Keys, etc. stored in this device will be displayed. Cancel if this is not what you want.");
		if(reply==false) throw("lockDB show canceled");
	}
	var lockmsg = document.getElementById("lockmsg");
	if(localStorage.lockDB != "{}"){		
		var alphalockDB = lockDB;
		document.lock.text.value = JSON.stringify(alphalockDB,null,4).replace(/[{}"\[\]]/g,'').replace(/\n    /g,'\n').replace(/ \n/g,'\n').replace(/,\n/g,'\n').trim();
		lockmsg.innerHTML = 'These are the items stored in this device';
	}else{
		lockmsg.innerHTML = '<span style="color:red">There are no stored items</span>'
	}
}

//reconstruct the original JSON string from the newlines and spaces as displayed by showLockDB
function mergeLockDB(){
	var learnOn = document.getElementById("learnmode").checked === true;
	
	var lockmsg = document.getElementById("lockmsg"),	
		lockstr = document.lock.text.value.trim(),				//see if these are Locks for a possible DH merge, which is not the main function of this button
		mainstr = document.main.text.value.trim();
	if (lockstr == ''){
		lockmsg.innerHTML = 'Nothing to merge';
		throw('invalid merge')
	}
	if (lockstr.slice(0,1) == '~') {
		var key = readKey();
		lockstr = keyDecrypt(key,lockstr.slice(1,lockstr.length))
	}
	var lockstr2 = striptags(lockstr),
		mainstr2 = striptags(mainstr);
	if((lockstr2.length == 87 && mainstr2.length == 87) || (lockstr2.length != 87 && mainstr2.length != 87 && lockstr.split('\n').length == 1)){
		lockmsg.innerHTML = '<span style="color:orange">One and only one of the items to be merged must be a Lock<span>';
		throw('invalid DH merge')
	}
	if (lockstr2.length == 87){							//if it's a Lock in the lock box, merge it with the Key, clear lock box so it doesn't get merged next time
		if (mainstr == ''){
			lockmsg.innerHTML = 'Nothing to merge this Lock with';
			throw('invalid merge')
		}
		if (learnOn){
			var reply = confirm("The Lock in the Locks box will be combined with the Key in the main box, and the resulting Key will replace both. Cancel if this is not what you want.");
			if(reply===false) throw("merge canceled");
		};
		document.main.text.value = makeshared(mainstr,lockstr2);
		document.lock.text.value = document.main.text.value;
		lockmsg.innerHTML = 'Lock merged with Key in main box';
		throw ("it was a lock, merged with key")
	} else if (mainstr2.length == 87 && lockstr.split('\n').length == 1 && lockstr!=''){		//if it's a Lock in the main box and not multiline in the lock box
		if (learnOn){
			var reply = confirm("The Key in the Locks box will be combined with the Lock in the main box, and the resulting Key will replace both. Cancel if this is not what you want.");
			if(reply===false) throw("merge canceled");
		};
		document.main.text.value = makeshared(lockstr,mainstr2);
		document.lock.text.value = document.main.text.value;
		lockmsg.innerHTML = 'Key merged with Lock in main box';
		throw ("it was a key, merged with lock")
		
	} else if(lockstr.split('\n').length > 1){
		
	//now the real database merge, which implies multiline
	if (learnOn){
		var reply = confirm("The items in the box will be merged into the permanent directory, replacing existing items of the same name. This is irreversible. Cancel if this is not what you want.");
		if(reply==false) throw("lockDB merge canceled");
	}
	var newDB = JSON.parse('{"' + document.lock.text.value.trim().replace(/\n +/g,'\n').replace(/:\n/g,'":["').replace(/\n\n/g,'"],"').replace(/\n/g,'","') + '"]}');
		lockDB = sortObject(mergeObjects(lockDB,newDB));
		localStorage.lockDB = JSON.stringify(lockDB);
		lockNames = [''].concat(Object.keys(lockDB));
		lockmsg.innerHTML = 'Items merged into database';
	}
}

//makes encrypted backup of the whole DB, then if allowed clears lockDB object, then stores
function moveLockDB(){
	var lockmsg = document.getElementById("lockmsg");
	var key = readKey();
	
	//first encrypt lockDB, as displayed by showLockDB
	showLockDB();
	document.main.text.value = 'PL17db=~' + keyEncrypt(key,document.lock.text.value.trim()) + '=PL17db';
	lockmsg.innerHTML = '<span>Database in main screen</span>'
	
	//now check that the user really wants to delete the database
	var answer = confirm("The database has been exported to the main screen. If you go ahead, it will now be erased from this device. This cannot be undone.");
	if (answer == false) throw("lockDB erase canceled");
		lockDB = {};
		localStorage.lockDB = JSON.stringify(lockDB);
		lockNames = [''].concat(Object.keys(lockDB));
		lockmsg.innerHTML = '<span style="color:purple">Stored items erased</span>'
}

//merges two objects; doesn't sort the keys
function mergeObjects(obj1,obj2){
    var obj3 = {};
    for (var attrname in obj1) { obj3[attrname] = obj1[attrname]; }
    for (var attrname in obj2) { obj3[attrname] = obj2[attrname]; }
    return obj3;
}

//sorts object keys alphabetically
function sortObject(o) {
    var sorted = {},
    	key, a = [];
    for (key in o) {
    	if (o.hasOwnProperty(key)) {
    		a.push(key);
    	}
    }
    a.sort(insensitive);							//this depends on next function
    for (key = 0; key < a.length; key++) {
    	sorted[a[key]] = o[a[key]];
    }
    return sorted;
}

//to make sorting case-insensitive
function insensitive(s1, s2) {
  var s1lower = s1.toLowerCase();
  var s2lower = s2.toLowerCase();
  return s1lower > s2lower? 1 : (s1lower < s2lower? -1 : 0);
}

//finds first partial match of string str and returns index of array element
function searchStringInArrayDB (str, strArray) {
	var reg = new RegExp(str, "i");					//make it case-insensitive
    for (var j=0; j<strArray.length; j++) {
		if (strArray[j] != null){
    		if (strArray[j].match(reg)) return j;
		}
    }
    return -1;
}

//global variable used for key box expiration
var keytimer = new Date().getTime();

//add entropy as forms are manipulated, reset key boxes after 5 minutes
function ce() {
	sjcl.random.addEntropy(Math.floor((((new Date).getMilliseconds()) * 255) / 999), 2, "loadtime");
	if ((new Date().getTime()) - keytimer > 300000) {
		document.key.text.value = '';
	}
};

//now comes the code dealing with page formatting and such

//this is for showing and hiding text in key box and other password input boxes
function showsec(){
  var showPasswordCheckBox = document.getElementById("showKey");
  if(showPasswordCheckBox.checked){
        document.key.text.type="TEXT";
  }else{
      document.key.text.type="PASSWORD";
  }
};

function showdecoyIn(){
  var showPasswordCheckBox = document.getElementById("showdecIn");
  if(showPasswordCheckBox.checked){
        document.decoyIn.key.type="TEXT";
  }else{
      document.decoyIn.key.type="PASSWORD";
  }
};

function showdecoyOut(){
  var showPasswordCheckBox = document.getElementById("showdecOut");
  if(showPasswordCheckBox.checked){
        document.decoyOut.key.type="TEXT";
  }else{
      document.decoyOut.key.type="PASSWORD";
  }
};

//for selecting text in main and extra screens
function selectMain(){
	document.main.text.selectionStart=0;
	document.main.text.selectionEnd=document.main.text.value.length;
}
function selectExtra(){
	document.extra.text.selectionStart=0;
	document.extra.text.selectionEnd=document.extra.text.value.length;
}

//closes input divs
function closebox() {
	document.getElementById("shadow").style.display = "none";
	document.getElementById("decoyIn").style.display = "none";
	document.getElementById("decoyOut").style.display = "none";
	document.getElementById("partsIn").style.display = "none";
	document.getElementById("keyscr").style.display = "none"
}

//these are for switching between windows
function main2extra(){
	openClose("mainscr");
	openClose("extrascr");
	var main = document.main.text.value.trim();					//the code below is for passing text between screens, unless empty, or there are parts made by SSSS
	if((main != "") && !(main.slice(0,8).match(/p\d{3}/) && main.slice(0,2)=='PL') && !(main.match(/\n\nA/) && main.slice(0,1)=='A')){
		document.extra.text.value = document.main.text.value;
		showhash()
	} else if (document.main.text.value.trim() != "") {
		document.getElementById("extramsg").innerHTML = 'Parts in main box. Click Split/Jn to join them.'
	} else {
		showhash()
	}
}
function extra2main(){
	openClose("extrascr");
	openClose("mainscr");
	var main = document.main.text.value.trim();
	if((document.extra.text.value.trim() != "") && !(main.slice(0,8).match(/p\d{3}/) && main.slice(0,2)=='PL') && !(main.match(/\n\nA/) && main.slice(0,1)=='A')){
		document.main.text.value = document.extra.text.value
	}
}
function main2lock(){
	openClose("mainscr");
	openClose("lockscr")
}
function lock2main(){	
	if(document.lock.text.value.slice(0,1) == '~') {
		decryptItem();
	}
	openClose('lockscr');
	openClose('mainscr');
	if(document.lock.text.value != '') document.getElementById("mainmsg").innerHTML = 'Item ready';
	if(document.lock.text.value.length > 200){
		newcover(document.lock.text.value);					//this for loading cover text from lock screen
		document.getElementById("mainmsg").innerHTML = 'Cover text changed'
	}
	keytimer = new Date().getTime();
}
function extra2image(){
	openClose('extrascr');
	openClose('imagescr');
	if(document.getElementById('preview').src.slice(0,4)!='data'){document.getElementById('imagemsg').innerHTML='Click the button above to load an image'}
}
function any2key(){
	document.getElementById("keyscr").style.display = "block";
	document.getElementById("shadow").style.display = "block";	
}

function key2any(){
	keytimer = new Date().getTime();
	closebox();
	var mykey = document.key.text.value.trim();
	if(lockDB['myself'] == null && mykey != ''){			//if "myself" lockDB entry containing the Key's matching Lock is not present, add it
		var mylock = makepub(mykey);
		mylock = '~' + keyEncrypt(mykey,mylock);
	var newEntry = JSON.parse('{"myself":["' + mylock + '"]}');
		lockDB = mergeObjects(lockDB,newEntry);
		localStorage.lockDB = JSON.stringify(lockDB);
		lockNames = [''].concat(Object.keys(lockDB));
	}
}

//resizes text boxes so they fit within the window
function textrows(){
	if(isiPad || isAndroidTablet){												//first for iPad. Don't know how to detect other tablets
		if((angle==90)||(angle==-90)){
			document.main.text.rows=document.documentElement.clientHeight/rowheight-11					//landscape
		}else{document.main.text.rows=document.documentElement.clientHeight/rowheight*1.2-11}			//portrait
	}else{
		if((angle==90)||(angle==-90)){
			document.main.text.rows=document.documentElement.clientHeight/rowheight*0.9-11				//smartphone here and line below
		}else if(typeof window.orientation != 'undefined') {document.main.text.rows=document.documentElement.clientHeight/rowheight*1.25-11
		}else{document.main.text.rows=document.documentElement.clientHeight/rowheight*1.2-10}}				//non-mobile
	document.main.text.rows = document.main.text.rows*0.8;			//tweak factor for development
	if(document.extra!=null) document.extra.text.rows = document.main.text.rows;
	if(document.lock!=null) document.lock.text.rows = document.main.text.rows
	
	//fix for fat text in landscape mode
	if((angle==90)||(angle==-90)){
		document.getElementById('modes').innerHTML = '<span style="font-size:50%;color:red">' + document.getElementById('modes').innerHTML + '</span>'
	}
}

<!-- Text hide trick, by Sandeep Gangadharan 2005-->
if (document.getElementById) {
 document.writeln('<style type="text/css"><!--')
 document.writeln('.texter {display:none} @media print {.texter {display:block;}}')
 document.writeln('//--></style>') }

function openClose(theID) {
 if (document.getElementById(theID).style.display === "block") { document.getElementById(theID).style.display = "none" }
 else { document.getElementById(theID).style.display = "block" } };
// end of hide trick

//The main script in the head ends here.
</script>
		
</head>
  
<body link="#0000ff" vlink="#0000ff" alink="#0000ff" onload="ce();">
  
<div id="mainscr" class="texter" style="display: block;">
  <div align="center">
  	<form name="warning" action="#" onsubmit="return false;">
		<input type="text" name="warning" style="background-color: #FFB0B0; color: #000000;width: 60%; font-size: large; text-align: center" value="Javascript NOT working!" class="ctr" readonly />
	</form>
	<br />
	<span id="mainmsg"></span><br />
    <button onclick="ce();any2key();" onBlur="ce();" onFocus="ce();" value="myKey" style="font-size:medium;font-weight:bold;color:blue">myKey</button>
    <button onclick="main2lock();" onBlur="ce();" onFocus="ce();" value="Locks" style="font-size:medium;font-weight:bold;color:blue">Locks</button>
   
	<button onClick="selectMain();" onBlur="ce();" onFocus="ce();" value="Select" style="font-size:medium">Sel</button>
	<button onClick="document.main.text.value = '';document.getElementById('mainmsg').innerHTML = '';" onBlur="ce();" onFocus="ce();" value="Clear" style="font-size:medium">Clr</button>
    </div>
    <div align="center">
    	<form onSubmit="return false;" id="main" name="main">      
    		<textarea onKeyDown="ce();" onKeyUp="charsLeft();" onBlur="ce();" onFocus="ce();" style="background-color: rgb(255, 255, 240); color: #000000; width: 98%; font-size: medium" name="text" rows="13" placeholder="The text to be locked, unlocked, or signed goes here.   Usually, the first thing would be to click the myKey button above in order to enter your secret Key, or the Locks button in order to enter someone else's Lock or a shared Key."></textarea>
    	</form>
    </div>
	<div align="center">
    	<button onclick = "openClose('mainscr');openClose('mainhelp');" onBlur="ce();" onFocus="ce();" value="Help" style="font-size:medium;color: rgb(0, 150, 0)">Help</button>
    	<button onClick="Decrypt_text();" onBlur="ce();" onFocus="ce();" value="Lock/Unlock" name="decrypt" style="font-size:medium;font-weight:bold;color:blue">Lk/Un</button>
		<button onClick="Verifyhash();" onBlur="ce();" onFocus="ce();" value="Sign/Verify" style="font-size:medium">Sig/Ver</button>
    	<button onclick = "main2extra();" onBlur="ce();" onFocus="ce();" value="More" style="font-size:medium">&#133;</button><br /><br />
        Mode:<input type="radio" name="lockmodes" id="anonmode" onBlur="ce();" onFocus="ce();" checked/> Anon.
        <input type="radio" name="lockmodes" id="signedmode" onBlur="ce();" onFocus="ce();" /> Signed
        <input type="radio" name="lockmodes" id="pfsmode" onBlur="ce();" onFocus="ce();" /> PFS
        <br /><br />
    	<input type="checkbox" id="shortmode" onBlur="ce();" onFocus="ce();"/> Short
    	<input type="checkbox" id="notags" onBlur="ce();" onFocus="ce();"/> No tags
        <input type="checkbox" id="decoymode" onBlur="ce();" onFocus="ce();"/> Decoy
  </div> 
</div> 
        
<div id="extrascr" class="texter" style="display: none;" align="center">
	<div align="center">
       <button onclick = "extra2main();" onBlur="ce();" onFocus="ce();" style="float: left; font-size: medium;">&#x25C0; Back</button>
       <button onClick="selectExtra();" onBlur="ce();" onFocus="ce();" value="Select" style="font-size:medium">Select</button>
       <button onClick="document.extra.text.value='';document.getElementById('extramsg').innerHTML='';" onBlur="ce();" onFocus="ce();" value="Clear" style="float:right; font-size:medium;">Clear</button><br /><br />
    </div>   
    <div align="center">
		<span id="extramsg"></span><br />
		<button onClick="sendMail();" onBlur="ce();" onFocus="ce();" value="Mail" style="font-size:medium">Mail</button>
        <button onClick="sendSMS();" onBlur="ce();" onFocus="ce();" value="SMS" style="font-size:medium">SMS</button>
        <button onclick="secretshare();" onBlur="ce();" onFocus="ce();" value="Split/Join" style="font-size:medium">Splt/Jn</button>
        <button onClick="extra2image();" onBlur="ce();" onFocus="ce();" value="Images" style="font-size:medium">Img</button>	
		
	</div>
	<div align="center">
      	<form onSubmit="return false;" id="extra" name="extra">     
			<textarea onKeyDown="ce();" onKeyUp="showhash();" onBlur="ce();" onFocus="ce();" style="background-color: rgb(255, 255, 240); color: #000000; width: 98%; font-size: medium" name="text" rows="13" placeholder="The text to be locked, unlocked, or signed goes here.   From this screen, you can send it by email or SMS, or you can disguise it to look like other text or an image. File I/O is done from this screen also."></textarea>
		</form>
    </div>
    <div align="center">
        <button onclick = "openClose('extrascr');openClose('extrahelp');" onBlur="ce();" onFocus="ce();" value="Help" style="font-size:medium;color: rgb(0, 150, 0)">Help</button>
    	<button onClick="words();" onBlur="ce();" onFocus="ce();" value="Words" style="font-size:medium">Wrds</button>
		<button onClick="spaces();" onBlur="ce();" onFocus="ce();" value="Spaces" style="font-size:medium">Spcs</button>
    	<button onClick="newcover(document.extra.text.value);" onBlur="ce();" onFocus="ce();" value="Cover" style="font-size:medium">Covr</button>
    </div>
    <div align="center" id="fileIO">
    	<p>File In/Out (Chrome,Firefox,Safari)</p>
    	<input type="file" id="fileToLoad" onBlur="ce();" onFocus="ce();" style="font-size:medium"/>
        <input type="button" onclick="saveURLAsFile()" onBlur="ce();" onFocus="ce();" value="Save" style="font-size:medium"/>
    </div>
</div>
    
<div id='imagescr' class="texter" style="display: none;" align="center">
    <button onclick ="openClose('imagescr');openClose('extrascr');" onBlur="ce();" onFocus="ce();" value="< Back" style="font-size:medium">&#x25C0; Back</button>
    <button id="encode" onBlur="ce();" onFocus="ce();" value="Hide" style="font-size:medium">Hide</button>
    <button id="decode" onBlur="ce();" onFocus="ce();" value="Reveal" style="font-size:medium">Rev.</button><br /><br />
       
    <input type='file' id='file' onBlur="ce();" onFocus="ce();" style="font-size:medium"/><br /><br />
  
    <span id="imagemsg"></span><br />

    <img id="preview" src="" width="100%"/>

    <canvas id='canvas' style="display: none"></canvas>
    
</div> 

<div id="lockscr" class="texter" style="display: none;" align="center">
    <div align="center">
       <button onclick = "lock2main();" onBlur="ce();" onFocus="ce();" value="< Back" style="float: left;font-size:medium;">&#x25C0; Back</button>
       <button onClick="window.open('https://passlok.com/lockdir.php','_blank');" onBlur="ce();" onFocus="ce();" value="Directory" style="font-size:medium">Lock directory</button>
       <button onClick="document.lock.text.value='';document.lockname.text.value='';document.getElementById('lockmsg').innerHTML=''" onBlur="ce();" onFocus="ce();" value="Clear" style="float: right; font-size:medium;">Clear</button><br /><br />
    </div> 
	<form onSubmit="return false;" name="lockname">
    <div align="center">
    	<span id="lockmsg"></span><br />
    	<input type="text" onKeyDown="ce();" onKeyUp="if (event.keyCode == 13) {decryptItem()} else {return findLock()};" onBlur="ce();" onFocus="ce();" style="background-color: rgb(255, 255, 240); color: #000000; width: 92%; font-size: medium" name="text" placeholder="Name associated with the item below.   Enter the name first, then enter the item in the large box." /></div></form><br  /><br />
    <div align="center">
    	<button onClick="addLock();" onBlur="ce();" onFocus="ce();" value="Save" style="font-size:medium">Save</button>
		<button onClick="removeLock();" onBlur="ce();" onFocus="ce();" value="Del." style="font-size:medium">Del</button>
        <button onClick="resetPFS();" onBlur="ce();" onFocus="ce();" value="Reset" style="font-size:medium">Reset</button>
        <button onClick="addToList();" onBlur="ce();" onFocus="ce();" value="List" style="font-size:medium">List</button>
    </div>
    <form onSubmit="return false;" name="lock">
		<textarea onBlur="ce();" onFocus="ce();" onKeyDown="ce();" style="background-color: rgb(255, 255, 240); color: #000000; width: 98%; font-size: medium" name="text" rows="13" placeholder="Enter Locks and shared Keys here.   If the item has a name, first enter the name in the box above."></textarea></form>

	<div align="center">
        <button onclick = "openClose('lockscr');openClose('lockhelp');" onBlur="ce();" onFocus="ce();" value="Help" style="font-size:medium;color: rgb(0, 150, 0);">Help</button>
		<button onClick="showLockDB();" onBlur="ce();" onFocus="ce();" value="All" style="font-size:medium">All</button>
        <button onClick="mergeLockDB();" onBlur="ce();" onFocus="ce();" value="Merge" style="font-size:medium">Merge</button>
        <button onClick="moveLockDB();" onBlur="ce();" onFocus="ce();" value="Move" style="font-size:medium">Move</button>
    </div>
</div>      
        
<div id="shadow" class="black_overlay"></div>

<div id="keyscr" class="white_content" align="center">
  	<div align="center">
    	<button onclick = "checkBlacklist(document.key.text.value);key2any();" value="< Back" style="float:left;font-size:medium;">&#x25C0; Back</button>
        <button onClick="document.key.text.value = '';document.getElementById('keymsg').innerHTML = '';" onBlur="ce();" onFocus="ce();" value="Clear" style="float:right;font-size:medium">Clear</button>   	
    </div><br /><br />
    <div align="center">        
    	<form onsubmit="return false;" id="key" name="key">
      		<span id="keymsg"></span><br />
			<input type="password" autocomplete="off" id="pwd" onKeyUp="return keyStrength(document.key.text.value,true);keytimer = new Date().getTime();" style="background-color: rgb(255, 255, 240); color: #000000; width: 92%; font-size: medium" name="text" placeholder="Enter your secret Key here.  Then click Make Lock if you need to see your Lock." align="center"><br />
        </form>
    </div>
    <div align="center">
		<input type="checkbox" id="showKey" onClick="ce();showsec();" onBlur="ce();" onFocus="ce();" style="font-size:medium"> Show 
        <button onclick="fillkeys();" onBlur="ce();" onFocus="ce();" value="Make Lock" style="font-size:medium;font-weight:bold;color:blue">Make Lock</button>
	</div>
    <div align="left" style="width:98%">        
      	<p>This is your secret Key, which you must memorize and never write down anywhere. As you type your Key, a text above it will tell you the strength of the Key based on simple rules. Make sure to <strong>use $ymbol$, numb3rs, caPiTals, unusual words and mispelingss.</strong> Initial capitals and numbers at start and end are not helpful and will be ignored for the strength score.</p>
		<p>If your Key strength is worse than Medium, <strong>PassLok will be very slow.</strong></p>
        <p>To display the characters, check Show.</p>
        <p>To display the matching Lock in the main screen, click the <strong>Make Lock</strong> button. If this box is empty when the button is pressed, a random Key and its matching Lock will be generated instead.</p>
    </div>
</div>
       
<div id="decoyIn" class="white_content" align="center">
	<form onSubmit="return false;" name="decoyIn">
    	<p>Enter Decoy Password</p> 
		<span id="decoymsg"></span><br /> 
    	<input type="password" onKeyDown="ce();" onKeyUp="return keyStrength(document.decoyIn.key.value,true);" onBlur="ce();" onFocus="ce();" style="background-color: rgb(255, 255, 240); color: #000000; width: 98%; font-size: medium" name="key"/>
		<p>Enter Hidden Message</p>      
		<textarea onKeyDown="ce();" onBlur="ce();" onFocus="ce();" style="background-color: rgb(255, 255, 240); color: #000000; width: 98%; font-size: medium" name="text" rows="3"></textarea>
        <input type="checkbox" id="showdecIn" onClick="showdecoyIn();" onBlur="ce();" onFocus="ce();" style="font-size:medium"> Show
    	<button onClick="checkBlacklist(document.decoyIn.key.value);closebox();if(encrypting){Decrypt_text()}else{Verifyhash()};" onBlur="ce();" onFocus="ce();" value="OK" style="font-size:medium">OK</button>
		<button onClick="closebox();" onBlur="ce();" onFocus="ce();" value="Cancel" style="font-size:medium">Cancel</button>
	</form>   
</div>
       
<div id="decoyOut" class="white_content" align="center">
	<form onSubmit="return false;" name="decoyOut">
		<p>Enter Decoy Password</p> 
    	<input type="password" onKeyDown="ce();" onBlur="ce();" onFocus="ce();" style="background-color: rgb(255, 255, 240); color: #000000; width: 98%; font-size: medium" name="key"/>
        <input type="checkbox" id="showdecOut" onClick="showdecoyOut();" onBlur="ce();" onFocus="ce();" style="font-size:medium"> Show   
    	<button onClick="closebox();if(encrypting){Decrypt_text()}else{Verifyhash()};" onBlur="ce();" onFocus="ce();" value="OK" style="font-size:medium">OK</button>
		<button onClick="closebox();" onBlur="ce();" onFocus="ce();" value="Cancel" style="font-size:medium">Cancel</button>
    	<p>The Hidden message will appear in the main window</p>
    </form>   
</div>
    
<div id="partsIn" class="white_content" align="center">
	<form onSubmit="return false;" name="partsIn">
		<p>Enter the number of parts needed to retrieve the item (between 2 and 255)</p> 
    	<input type="text" onKeyDown="ce();" onBlur="ce();" onFocus="ce();" style="background-color: rgb(255, 255, 240); color: #000000; width: 30%; font-size: medium" name="text" rows="1"/><br />    
    	<button onClick="if(!isNaN(document.partsIn.text.value)){closebox();secretshare()};" onBlur="ce();" onFocus="ce();" value="OK" style="font-size:medium">OK</button>
		<button onClick="closebox();" onBlur="ce();" onFocus="ce();" value="Cancel" style="font-size:medium">Cancel</button>
	</form>
</div>

<script>
//this is the part of the javascript code that must be within the body

	sjcl.random.startCollectors();											//start SJCL's built-in entropy collectors

    //  Clear out "sorry, no JavaScript" message from text box.
    document.warning.warning.value = "PassLok Privacy";
    document.warning.warning.style.backgroundColor = "rgb(235, 255, 235)";

	var rowheight = document.warning.clientHeight*0.7,						//get title size in pixels, for number of rows calculation. global variables
		isiPad = (navigator.userAgent.match(/iPad/i) != null),
		isiPhone = (navigator.userAgent.match(/iPhone|iPod/i) != null),
		isAndroidTablet = (navigator.userAgent.match(/mobile/i) == null && navigator.userAgent.match(/Android/i) != null && !isiPad && !isiPhone),
		isAndroidPhone= (navigator.userAgent.match(/mobile/i) != null && navigator.userAgent.match(/Android/i) != null && !isiPad && !isiPhone),
		angle = window.orientation;
	if(isAndroidPhone || isAndroidTablet){rowheight = rowheight*1.1}		//Android rows are fatter
	textrows();
	window.addEventListener("resize", function() { textrows() }, false)	    //resize if the window changes		
	
//functions for reading a file into the box, and for saving it later
function saveURLAsFile()
{
	var URLToWriteSplit = document.extra.text.value.trim().split('\n');
	var fileNameToSaveAs = URLToWriteSplit[0].split(':')[1];
	if(URLToWriteSplit.length > 1){
		var content = URLToWriteSplit[1].trim()
	} else {
		var content = URLToWriteSplit[0].trim()
	};
	
	var downloadLink = document.createElement("a");
	if(content.slice(0,4).toLowerCase()=='http'){							//this is for showing a webpage, such as an authenticating video
		downloadLink.target = '_blank'
	} else if(content.slice(0,4).toLowerCase()=='data'){					//regular save of encoded file
		downloadLink.download = fileNameToSaveAs;
		downloadLink.innerHTML = "Download File";
	} else {																//to save contents as text file
		var textFileAsBlob = new Blob([document.extra.text.value.trim()], {type:'text/plain'});
		downloadLink.download = prompt("The box contents will be saved as a text file. Please enter a name for it.");
		downloadLink.innerHTML = "Download File";
		content = window.URL.createObjectURL(textFileAsBlob);	
	}
	
	if (window.webkitURL != null)
	{
		// Chrome allows the link to be clicked
		// without actually adding it to the DOM.
		downloadLink.href = content;
	}
	else
	{
		// Firefox requires the link to be added to the DOM
		// before it can be clicked.
		downloadLink.href = content;
		downloadLink.onclick = destroyClickedElement;
		downloadLink.style.display = "none";
		document.body.appendChild(downloadLink);
	}

	downloadLink.click();	
}

function destroyClickedElement(event)
{
	document.body.removeChild(event.target);
}

//this one is called by window.onload below
function loadFileAsURL()
{
	var fileToLoad = document.getElementById("fileToLoad").files[0];

	var fileReader = new FileReader();
	fileReader.onload = function(fileLoadedEvent) 
	{
		var fileName = fileToLoad.name;
		var URLFromFileLoaded = fileLoadedEvent.target.result;
		document.extra.text.value = "filename:" + fileName + "\n" + URLFromFileLoaded;
	};
	fileReader.readAsDataURL(fileToLoad, "UTF-8");
}

// initialize things
window.onload = function() {
	
	//this one for loading files into extra screen
	var fileinput = document.getElementById('fileToLoad');
    fileinput.addEventListener('change', loadFileAsURL, false);
	
	if(typeof window.orientation == 'undefined') document.getElementById('preview').style.width = "40%"		//smaller image on PCs
	
    // add action to the file input
    var input = document.getElementById('file');
    input.addEventListener('change', importImage);

    // add action to the encode button
    var encodeButton = document.getElementById('encode');
    encodeButton.addEventListener('click', encodeImage);

    // add action to the decode button
    var decodeButton = document.getElementById('decode');
    decodeButton.addEventListener('click', decodeImage);
};

//end of body script. Help pages follow
</script>

<div id="mainhelp" class="texter" style="display: none;">
 	<button onclick = "openClose('mainhelp');openClose('mainscr');" onBlur="ce();" onFocus="ce();" value="< Back" style="font-size:medium">&#x25C0; Back</button>
    <p>To get information on every button as you press it, check this box: <strong> Learn Mode <input type="checkbox" id="learnmode" onBlur="ce();" onFocus="ce();" style="font-size:medium"/></strong></p>    
	<p>For instructions on how to do things, click on each title below. Click again to hide.</p>
    <hr style="background-color: rgb(192, 192, 192); color: #000000;">
    
    <div onClick="openClose('a1')" style="cursor:hand; cursor:pointer">
	<h3>I don't know how to start. Please help</h3>
    </div>
    <div id="a1" class="texter">
    <p>Before you do aything else, you may want to watch this short video, which explains the essential concepts in a lighthearted way: <a href="https://www.youtube.com/watch?v=FZF3EiDt7Ws" target="_blank">https://www.youtube.com/watch?v=FZF3EiDt7Ws</a></p>
    <p>If you don't have time for the video, here's the two-paragraph version. PassLok locks messages and files, turning them into gibberish so only the intended recipients can return them to their original form and read them. It is based on digital Keys and Locks. A Lock is used to lock a message,  and then only the matching Key can unlock it so it becomes readable again. A Key is a piece of text that you choose and memorize; it is personal and should never be revealed to anyone. You make your Lock from your Key, and then you give it to people so they can lock messages for you to read.  It is impossible to get the Key from its matching Lock. Keys are to be kept secret, but Locks are made to be widely distributed. Locks look like gibberish but have tags at both ends of the form &quot;PL17lok&quot;.</p>
    <p>The first step is to come up with a secret Key that you can remember. You enter it in PassLok by clicking the <strong>myKey</strong> button. Then you make its matching Lock by clicking the <strong>Make Lock</strong> button on that screen. Then you click the <strong>Back</strong> button to go back to the main screen and see your Lock and copy it. You give this Lock to all the people you wish to write to you in secret. They will also send you their Locks, which you can store anywhere you want. To lock a message, the sender puts the plain message in the main box, then clicks <strong>Locks</strong> to get to the Locks screen, and puts the recipient's Lock in the big box there. Going back to the main screen, the message is locked when the sender clicks <strong>Lck/Un</strong> (Lock/Unlock). The recipient unlocks the locked message by first putting it in the main box, then clicks <strong>myKey</strong> and enters his/her secret Key in the small box that appears. Going back to the main screen, the message is unlocked when the recipient clicks <strong>Lck/Un</strong>.</p>
	<p>PassLok is very powerful, combining AES encryption with elliptic curves at the strongest levels defined by standards, and including several ways to hide the result from prying eyes. All processing occurs on your device with no server involved, so your privacy cannot be compromised by third parties. But great power means a lot of buttons.</p>
	<p>Fortunately, only four buttons are essential to get started. They are <span style="color:blue">highlighted in blue:</span></p>
    <p><span style="color:blue"><strong>myKey</strong></span> opens a dialog where you can enter your secret Key, which is needed for most advanced functions in PassLok. It is also needed to unlock messages locked with your personal Lock, which is not secret. To display this Lock, click the <strong>Make Lock</strong> button.</p>
    <p><span style="color:blue"><strong>Make Lock</strong></span> (visible after clicking myKey) creates the Lock matching the Key that has been entered in the Key dialog and writes it on the main screen, from where it can be copied, emailed, etc.</p>
	<p><span style="color:blue"><strong>Locks</strong></span> opens a screen where you can enter the Lock or shared Key that is needed to lock the contents of the main box.</p>
	<p><span style="color:blue"><strong>Lck/Un</strong></span> (abbreviated from Lock/Unlock) locks the plain message in the main box, or unlocks it if it was locked. The appropriate Key or Lock must have been entered previously by means of the <strong>myKey</strong> or <strong>Locks</strong> buttons.</p>
	
	<p>With these four buttons, you can get started locking and unlocking messages with very high security. Here's another video that shows this (made for version 1.6, though): <a href="https://www.youtube.com/watch?v=3wrhfzU4DFc" target="_blank">https://www.youtube.com/watch?v=3wrhfzU4DFc</a>    </p></div>
	<hr style="background-color: rgb(192, 192, 192); color: #000000;">

    <div onClick="openClose('a2')" style="cursor:hand; cursor:pointer">
<h3>Save PassLok to my device, so I don't have to download it again</h3>  
</div>
      <div id="a2" class="texter">
<p>PassLok is designed to save its code within the browser, so it only gets downloaded again if the code has changed. Once PassLok has reached your device from its source server, it works even if the device is offline. Just make a bookmark on your browser so you can access it quickly. Still, you can make it behave even more like an app, this way:</p>
<p>1. If you are using a computer, you can direct the Browser to save the code to a local file via the "Save as..." command from the browser menu. Then you can place a link or shortcut to that file on your desktop. Even better than the "Save as..." command is to direct the browser to display the source (Ctrl-U or cmd-ctrl-U does it, on most devices and browsers), and then save the page that appears with the "Save as..." command. This way you'll save the original code rather than the code after it has been interpreted by the browser.</p>
<p>2. From an iOS device, it is as easy as loading PassLok on Safari, and then selecting "Add to Home Screen" from the box and arrow icon at the bottom of the screen.</p>
<p>3. On Android, the same is typically achieved by first making a bookmark of the PassLok page, then tap-holding on the PassLok bookmark and selecting "Add to Home Screen." On some versions you can also tap-hold on the desktop screen and select "Add to Home Screen" followed by "Shortcut", "Bookmark", and selecting PassLok from the list. Newer versions of Android have still more direct ways to do this.</p>      
      </div>
 	<hr style="background-color: rgb(192, 192, 192); color: #000000;">
    
      <div onClick="openClose('a3')" style="cursor:hand; cursor:pointer">
<h3>Make a strong Key</h3>
</div>
	<div id="a3" class="texter">
<p>1. Click the <strong>myKey</strong> button, then start typing in the box. As you type, a text above the box will tell you
  how strong the Key is, based on simple rules. If you want to see what you
  are typing and don't mind people peering over your shoulder, check the
  Show checkbox.</p>
<p>2. The Key will be stronger if it contains <strong>caPiTals</strong> in unusual places,
  <strong>numb3rs</strong>, and <strong>$ymbol$</strong>. If you use common words, <strong>mispelll</strong> them to make harder a "dictionary attack." Avoid things that refer to yourself and your family, such
  as birthdays or nicknames, or anything else that might be easy to guess,
  like: asdfg, qwerty, password, PassLok, and the like. It is a good practice to <strong>append
  your email address</strong> at the end of the Key, to combat the "rainbow table" attack. Alternatively, you can use anything that is not a standard dictionary word instead of your email.</p>
<p>3. Bear in mind, however, that you should be able to <strong>remember
  your secret Key</strong> without having to write it down. PassLok will never
  ask you to change your Key, so this is your chance to make a truly strong Key
  that you will use for a long time.</p>
  <p>4. PassLok compensates for bad Keys by taking longer to do its computations. If PassLok is slow, this is likely because your Key strength is less than Medium.</p>
  <p>5. If your Key is found in its built-in database of 500 most common Keys, PassLok will refuse to accept it. Just choose another Key.</p>
  <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=xPRiuBd9Co0" target="_blank">https://www.youtube.com/watch?v=xPRiuBd9Co0</a></p></div>
  <hr style="background-color: rgb(192, 192, 192); color: #000000;">	
  
  <div onClick="openClose('a4')" style="cursor:hand; cursor:pointer">
<h3>Display the Lock that matches your secret Key</h3>
</div>
<div id="a4" class="texter">
<p>1. Write your secret Key in the box that is accessed with the <strong>myKey</strong> button. It is masked by default, so
  if you want to display it, check the Show checkbox.</p>
<p>2. Click the <strong>Make Lock</strong> button. The lock matching that Key will appear
  in the main box, ready to be emailed or sent by SMS. It is okay to strip the tags up to the "=" sign, or insert
  spaces, carriage returns, or special characters other than = + or / but
  not recommended. PassLok will do this automatically if the No tags checkbox is checked prior to locking. 
  The lock can be made available to anyone who wishes to
  secure messages to be read with the matching Key.</p>
<p>3. If the key box is empty when you click <strong>Make Lock</strong>, a 86-character random key is generated to fill the box, and its Lock appears on the main screen.</p>
  <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=xPRiuBd9Co0" target="_blank">https://www.youtube.com/watch?v=xPRiuBd9Co0</a></p></div>
  <hr style="background-color: rgb(192, 192, 192); color: #000000;">
      
  <div onClick="openClose('a5')" style="cursor:hand; cursor:pointer">
<h3>Lock a message with a Lock, to be unlocked with the matching
  Key, without signing it (anonymous mode)</h3>
</div>
  <div id="a5" class="texter">
 <p>1. Make sure the <strong>Anonymous</strong> mode radio button, located right below the main box, is selected.</p>
 <p>2. Fetch the recipient's Lock, and paste it into the large box that is accessed with the <strong>Locks</strong> button. He/she would have sent it accompanying an email, or within
   an SMS text message, or posted it publicly. You can tell it is a Lock because it comprises 87 random-looking characters, likely 
   with PL**lok tags at either end (** is the version number). You need this Lock before you can do anything else. It is okay if the tags up to the "=" signs
   are missing, or extra spaces, carriage returns, or special characters
   other than = + or / have been added. If you have previously stored it in your device's Locks directory, you can retrieve it by clicking the <strong>Locks</strong> button and then beginning to type the name associated with the Lock in the top box.</p>
 <p>3. To lock a message so it can be read by several people, place their respective Locks in the box, one per line. If a Lock was previously stored, you can write the name associated with that Lock, instead.</p>
<p>4. Write or paste your message in the main box. Click the <strong>Lck/Un</strong> button. The
  locked message will appear in the main box, replacing the original message. Copy it and paste it into your
  communications program or click (...), followed by Mail to open your default email. 
  It is okay to strip the tags up to the "=" sign, but not recommended. 
  PassLok will do this automatically if the No tags checkbox is checked prior to locking. It is
  also okay to split the locked message with spaces, line returns, and
  punctuation other than = + / or % This message can only be unlocked by
  someone who has the Key matching the Lock used to lock it.</p>
  <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=0eYxeplsSx0" target="_blank">https://www.youtube.com/watch?v=0eYxeplsSx0</a></p></div>
  <hr style="background-color: rgb(192, 192, 192); color: #000000;">	
  
  <div onClick="openClose('a6')" style="cursor:hand; cursor:pointer">
<h3>Unlock an anonymous locked message (tags
  are PL**msa)</h3>
  </div>
  <div id="a6" class="texter">
<p>1. It does not matter which of the radio buttons below the main box is selected, since the locking mode is determined automatically from the locked message itself.</p>
<p>2. Write your secret Key into the box that is accessed by clicking <strong>myKey</strong>. It is masked by default, so if you want to display it, check the Show checkbox.</p>
<p>3. Paste the locked message into the main box. It is okay if it is broken up by
  spaces, carriage returns, and special characters other than = + / or % or is
  missing its tags. Then click the <strong>Lck/Un</strong> button. The unlocked message
  will appear in the main box, replacing the locked message.</p>
  <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=0eYxeplsSx0" target="_blank">https://www.youtube.com/watch?v=0eYxeplsSx0</a></p></div>
  <hr style="background-color: rgb(192, 192, 192); color: #000000;">	

  <div onclick="openClose('a7')" style="cursor:hand; cursor:pointer">
<h3>Lock a message with a Lock, to be unlocked with the matching
          Key, and sign it with your secret Key (signed mode)</h3>
  </div>
  <div id="a7" class="texter">
        <p>1. Make sure the <strong>Signed</strong> mode radio button, located right below the main box, is selected.</p>
        <p>2. Write your secret Key into the box that is accessed by clicking <strong>myKey</strong>. It is masked by default, so if you want to display it, check the Show checkbox.</p>
        <p>3. Fetch the recipient's Lock, and paste it into the large box that is accessed with the <strong>Locks</strong> button. He/she would have sent it accompanying an email, or within
          an SMS text message, or posted it publicly. You can tell it is a Lock because it comprises 87 random-looking characters, likely 
          with PL**lok tags at either end (** is the version number). You need this Lock before you can do anything else. It is okay if the tags up to the "=" signs
          are missing, or extra spaces, carriage returns, or special characters
          other than = + or / have been added. If you have previously stored it in your device's Locks directory, you can retrieve it by clicking the <strong>Locks</strong> button and then beginning to type the name associated with the Lock in the top box.</p>
        <p>4. To lock a message so it can be read by several people, place their respective Locks in the box, one per line. If a Lock was previously stored, you can write the name associated with that Lock, instead.</p>
        <p>5. Write or paste your message in the main box. Click the <strong>Lck/Un</strong> button. The
          locked message will appear in the main box, replacing the original message. Copy it and paste it into your
          communications program or click (...), followed by Mail to open your default email. 
          It is okay to strip the tags up to the "=" sign, but not recommended. 
          PassLok will do this automatically if the No tags checkbox is checked prior to locking. It is
          also okay to split the locked message with spaces, line returns, and
          punctuation other than = + / or % This message can only be unlocked by
          someone having the Key matching the Lock used to lock it.</p>
        <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=F6Ov4MSk2XA" target="_blank">https://www.youtube.com/watch?v=F6Ov4MSk2XA</a></p>
  </div>
  <hr style="background-color: rgb(192, 192, 192); color: #000000;" />
  
  <div onclick="openClose('a8')" style="cursor:hand; cursor:pointer">
<h3>Unlock a message  signed with the sender's Key (tags are PL**mss)</h3>
    </div>
  <div id="a8" class="texter">
      <p>1. It does not matter which of the radio buttons below the main box is selected, since the locking mode is determined automatically from the locked message itself.</p>
      <p>2. Write your secret Key in the box that is accessed with the <strong>myKey</strong> button. It is masked by default, so
        if you want to display it, check the Show checkbox.</p>
      <p>3. Paste the sender's Lock in the large box of the Locks screen. If the Lock has been previously stored, you can retrieve it by typing the name associated with it in the small box at the top.      </p>
      <p>3. Paste the locked message in the main box. It is okay if it is broken up by
        spaces, carriage returns, and special characters other than = + / or % or is
        missing its tags. Then click the <strong>Lck/Un</strong> button. The unlocked message
        will appear in the main box, replacing the locked message.</p>
      <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=F6Ov4MSk2XA" target="_blank">https://www.youtube.com/watch?v=F6Ov4MSk2XA</a></p>
</div>
      <hr style="background-color: rgb(192, 192, 192); color: #000000;" />

  <div onclick="openClose('a9')" style="cursor:hand; cursor:pointer">
<h3>Lock a message so that nobody can read it after the exchange is over (PFS mode)</h3>
  </div>
  <div id="a9" class="texter">
        <p>1. Make sure the PFS mode radio button, located right below the main box, is selected.</p>
        <p>2. Write your secret Key into the box that is accessed by clicking <strong>myKey</strong>. It is masked by default, so if you want to display it, check the Show checkbox.</p>
        <p>3. This mode requires the recipient's Lock or shared Key to be previously stored in the device's permanent directory. Follow the instructions from the Locks <strong>Help</strong> button to do this. Once the item is stored, you can retrieve it by beginning to type its name in the top box of the Locks screen. If you are restarting a PFS conversation that was interrupted, you must first clear the old PFS data for that recipient by clicking the <strong>Reset</strong> button after the recipient's name is displayed.</p>
        <p>4. To lock a message so it can be read by several people, place their respective Locks in the box, one per line. If a Lock was previously stored, you can write the name associated with that Lock, instead.</p>
        <p>5. Write or paste your message in the main box. Click the <strong>Lck/Un</strong> button. The
          locked message will appear in the main box, replacing the original message. Copy it and paste it into your
          communications program or click (...), followed by Mail to open your default email. 
          It is okay to strip the tags up to the "=" sign, but not recommended. 
          PassLok will do this automatically if the No tags checkbox is checked prior to locking. It is
          also okay to split the locked message with spaces, line returns, and
          punctuation other than = + or / This message can only be unlocked by
          someone having the Key matching the Lock used to lock it, or the appropriate shared Key, if this is what was used.</p>
        <p>6. If Short mode is used, locking cannot be repeated without corrupting the PFS data stored in the device, which will make it impossible for the recipient to unlock the message (unless it is re-locked as a regular length message). Make sure your plain message is what you want before clicking Lck/Un. This restriction does not apply to regular length messages, but you will get a warning alerting you that you are skipping a turn.</p>
        <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=oVJPJJuUCgQ" target="_blank">https://www.youtube.com/watch?v=oVJPJJuUCgQ</a></p>
  </div>
  <hr style="background-color: rgb(192, 192, 192); color: #000000;" />
  
  <div onclick="openClose('a10')" style="cursor:hand; cursor:pointer">  
<h3>Unlock a message  that was locked in PFS mode (tags are PL**msp)</h3>
    </div>
  <div id="a10" class="texter">
      <p>1. It does not matter which of the radio buttons below the main box is selected, since the locking mode is determined automatically from the locked message itself.</p>
      <p>2. Write your secret Key in the box that is accessed with the <strong>myKey</strong> button. It is masked by default, so
        if you want to display it, check the Show checkbox.</p>
      <p>3. This mode requires the recipient's Lock or shared Key to be previously stored in the device's permanent directory. Retrieve the item by typing the name associated with it in the small box at the top. The name must be displayed in full on the message above the box for PFS mode to work.</p>
      <p>4. Paste the locked message in the main box. It is okay if it is broken up by
        spaces, carriage returns, and special characters other than = + or / or is
        missing its tags. Then click the <strong>Lck/Un</strong> button. The unlocked message
        will appear in the main box, replacing the locked message.</p>
      <p>5. If this was a Short mode message, it can only be unlocked once. Attempting to unlock it again will corrupt the PFS data stored in the device, which is needed to keep the conversation going.  This restriction does not apply to regular length messages, but you will get a warning alerting you that a turn was skipped.</p>
      <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=oVJPJJuUCgQ" target="_blank">https://www.youtube.com/watch?v=oVJPJJuUCgQ</a></p>
  </div>
      <hr style="background-color: rgb(192, 192, 192); color: #000000;" />
      
  <div onClick="openClose('a11')" style="cursor:hand; cursor:pointer">
<h3>Lock a message with a shared Key, to be unlocked with the same Key</h3>  
</div>
      <div id="a11" class="texter">
<p>1. It does not matter which of the radio buttons below the main box is selected, since they do not apply to this mode.</p>
<p>2. Write or paste the shared Key in the large box that is accessed with the <strong>Locks</strong> button. If the Key was previously stored, you can search for it by typing in the top box the name associated with the Key. When you type "Enter", the stored Key is decrypted for you to see.  For a stored Key to function, your secret Key must have been entered by clicking the <strong>Locks</strong> button, followed by <strong>myKey</strong>.</p>
<p>3. To lock a message so it can be read by several people, place their respective shared Keys in the box, one per line. If a Key was previously stored, you can write the name associated with that Key, instead.</p>
<p>4. Write or paste the message in the main box. Click the <strong>Lck/Un</strong> button. The
  locked message will appear in the main box, replacing the original text. Copy it and paste it into your
  communications program or click (...), and then Mail to open your default email program. 
  It is okay to strip the tags up to the "=" sign, but not recommended; 
  PassLok will do this automatically if the No tags checkbox is checked prior to locking. It is
  also okay to split the locked message with spaces, line returns, and
  punctuation other than = + / or % This message can only be unlocked by
  someone having the same shared Key.</p>
<p>5. The tags will depend on the type of locking selected for using Locks. There is no special tag to indicate that a shared Key was used instead.</p>
  <p>All of this is explained in this video tutorial:<a href="https://www.youtube.com/watch?v=zFbsTwdHRYQ" target="_blank">https://www.youtube.com/watch?v=zFbsTwdHRYQ</a></p></div>
  <hr style="background-color: rgb(192, 192, 192); color: #000000;">	
  
  <div onClick="openClose('a12')" style="cursor:hand; cursor:pointer">
 <h3>Unlock a message locked with a shared Key</h3>
</div>
      <div id="a12" class="texter">
<p>1. It does not matter which of the radio buttons below the main box is selected, since the locking mode is determined automatically from the locked message itself.</p>
<p>2. Write or paste the shared Key in the large box that is accessed with the <strong>Locks</strong> button. If the Key was previously stored, you can search for it by typing in the top box the name associated with the Key. When you type "Enter", the stored Key is decrypted for you to see. For a stored Key to function, your secret Key must have been entered by clicking the <strong>myKey</strong> button.</p>
<p>3. Paste the locked message in the main box. It is okay if it is broken up by
  spaces, carriage returns, and special characters other than = + / or % or is
  missing its tags. Then click the <strong>Lck/Un</strong> button. The unlocked message
  will appear in the main box, replacing the locked message.</p>
  <p>All of this is explained in this video tutorial:<a href="https://www.youtube.com/watch?v=zFbsTwdHRYQ" target="_blank">https://www.youtube.com/watch?v=zFbsTwdHRYQ</a></p></div>
  <hr style="background-color: rgb(192, 192, 192); color: #000000;">	
   
    <div onclick="openClose('a13')" style="cursor:hand; cursor:pointer">     
    <h3>Make a short locked message suitable for SMS</h3>
</div>
<div id="a13" class="texter">
<p>1. Check the <strong>Short</strong> checkbox below the main box. Also make sure the appropriate locking mode is selected with the radio buttons. The radio buttons don't matter if the message is being locked with a shared Key.</p>
<p>2. Write or paste your message into the main box. Message length is limited to 58
  ASCII characters when locking with a shared Key or in signed mode, 38 in anonymous mode, 37 in PFS mode. Non-ASCII characters use 6 spaces each, so avoid them if
  you can. Any text beyond the limit will be lost. A message above the main box will tell you how much space is left, depending on the locking mode selected. Click the <strong>Lck/Un</strong> button.</p>
<p>3. The locked message will appear in the main box, replacing the original message. Copy it and paste it into your communications program. The locked
  message, which has no tags, will fit within one SMS message (160
  characters). </p>
<p>4. On a mobile device, the locked message will be selected and ready to be copied into the clipboard. <strong>You need to copy it</strong> manually before clicking the SMS button, which will open your SMS app.</p>
<p>5. Short mode is not available for multiple recipients.</p>
  <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=Ly9ESisRKE8" target="_blank">https://www.youtube.com/watch?v=Ly9ESisRKE8</a></p></div>
  <hr style="background-color: rgb(192, 192, 192); color: #000000;">	
  
  <div onClick="openClose('a14')" style="cursor:hand; cursor:pointer">
<h3>Unlock a short locked message (no tags)</h3>
  </div>
  <div id="a14" class="texter">
<p>1. It does not matter which of the radio buttons below the main box is selected, or whether the Short checkbox is checked, since the locking mode is determined automatically from the locked message itself.</p>
<p>2. Paste the locked message into the main box. It is okay if it is broken up by
  spaces, carriage returns, and special characters. As with regular-length messages, either a shared Key must be entered in the <strong>Locks</strong> box, or the secret Key in its own box, prior to unlocking. 
  Then click the <strong>Lck/Un</strong> button.</p>
<p>3. The unlocked message will appear in the main box, replacing the locked message.</p>
  <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=Ly9ESisRKE8" target="_blank">https://www.youtube.com/watch?v=Ly9ESisRKE8</a></p></div>
  <hr style="background-color: rgb(192, 192, 192); color: #000000;">	 
  
  <div onClick="openClose('a15')" style="cursor:hand; cursor:pointer">
<h3>Sign a text with your secret Key</h3>
</div>
<div id="a15" class="texter">
<p>1. Write your secret Key in the box that is accessed with the <strong>myKey</strong> button. It is masked by default, so if you want to display it, check the Show checkbox.</p>
<p>2. Write or paste the text to be signed in the main box. Click the <strong>Sig/Ver</strong>
  button (abbreviated from Sign/Verify). A signature matching the text and your Key will be appended at the end of the text in the main box. Copy
  it and use it as appropriate. If you click (...) followed by Mail the text with its signature
  will be placed into an email using the default program.
  It is okay to strip the tags up to the "="
  sign, but not recommended. PassLok will do this automatically if the No tags checkbox is checked prior to locking. 
  It is also okay to split the signature with spaces,
  and punctuation other than line returns or = + or /. </p>
  <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=YiiwcOmbI2U" target="_blank">https://www.youtube.com/watch?v=YiiwcOmbI2U</a></p></div>
  <hr style="background-color: rgb(192, 192, 192); color: #000000;">  
  
  <div onClick="openClose('a16')" style="cursor:hand; cursor:pointer">
<h3>Verify a signature attached to a text (signature tags are PL**sig) </h3>
</div>
<div id="a16" class="texter">
<p>1. Paste the Lock of the person who added the signature into the large box that is accessed with the <strong>Locks</strong> button. It is okay
  if the tags up to the "=" signs are missing, or extra spaces, carriage
  returns, or special characters other than = + or / have been added. If you have previously stored it in your device's Locks directory, you can retrieve it by  beginning to type the name associated with the Lock in the top box.</p>
<p>2. Write or paste the text with its signature appended on a separate line at the end, in the main box. It is okay if 
  the signature is broken up by spaces and special characters other than = + or / or is missing
  its tags up to the "=", but it should not be broken by carriage returns.
  Then click the <strong>Sig/Ver</strong> button. A message above the main box will say whether
  or not the signature for that text has been verified.</p>
  <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=YiiwcOmbI2U" target="_blank">https://www.youtube.com/watch?v=YiiwcOmbI2U</a></p></div>
    <hr style="background-color: rgb(192, 192, 192); color: #000000;">
  
  <div onClick="openClose('a17')" style="cursor:hand; cursor:pointer">
<h3>Lock a second, undetectable message in addition to the main message
  (Decoy mode)</h3>
  </div>
  <div id="a17" class="texter">
<p>1. Check the <strong>Decoy</strong> mode checkbox below the main box.</p>
<p>2. Follow the above instructions for any kind of locking, using
  a shared Key or the recipient's Lock, short or regular length, including PFS mode. This also works when adding a signature. If Decoy mode is checked, a popup will ask for a Decoy Password to lock the hidden message, and the hidden message itself.</p>
<p>3. Write or paste into the the corresponding boxes the Password and the hidden message. The length of the hidden message is limited to
  152 ASCII characters in key-locked and signed modes, 87 characters in
  anonymous and PFS modes, 37 characters in Short message mode (key-locked or signed only), 40 characters in signatures. Non-ASCII characters
  use 6 spaces each, so avoid them if you can. Any text beyond the limit will be lost. Then click <strong>OK</strong>. To view the Password before you use it, check the Show checkbox.</p>
<p>4. After clicking <strong>OK</strong>, the locked
  message containing both the main text and the hidden text will appear in
  the main box, replacing the original text. If it is a signature, it will be appended to the text. Copy it and paste it into your
  communications program. As with regular locked messages, it is okay to
  strip the tags up to the "=" sign, but not recommended. It is also okay to
  split the locked message with spaces, line returns, and punctuation other
  than = + / or %</p>
  <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=WaXQGYP0Sec" target="_blank">https://www.youtube.com/watch?v=WaXQGYP0Sec</a></p></div>
  <hr style="background-color: rgb(192, 192, 192); color: #000000;">	
  
  <div onClick="openClose('a18')" style="cursor:hand; cursor:pointer">
<h3>Reveal the hidden text contained within a message locked in Decoy
  mode</h3>
  </div>
  <div id="a18" class="texter">
<p>1. Check the <strong>Decoy</strong> mode checkbox below the main box.</p>
<p>2. Follow the instructions for any of the unlocking modes, using a
  personal or shared Key, or for verifying a signature. If Decoy mode is
  checked, a popup will ask for a Decoy Password.</p>
<p>3. Write or paste into the popup box the special Password for the hidden
  message and click <strong>OK</strong>. To view the Password before you use it, check the Show checkbox. The hidden message, if it exists,
  will appear above the main box. In the case of signatures, the hidden message appears in the place normally used by the verification message, so if you still wish to verify the signature, you need to uncheck Decoy Mode and click Sig/Ver again so the verification message is displayed.</p>
  <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=WaXQGYP0Sec" target="_blank">https://www.youtube.com/watch?v=WaXQGYP0Sec</a></p></div>
  <hr style="background-color: rgb(192, 192, 192); color: #000000;">
  
	<div onClick="openClose('a19')" style="cursor:hand; cursor:pointer">  
  <h3>I have an item that was locked/signed with a previous version of PassLok, and the current version cannot handle it</h3>
 </div>
  <div id="a19" class="texter">
    <p>We do not recommend using old versions for new work. Newer versions have enhanced security and are more user-friendly. But sometimes you may need to handle an item that is incompatible with the current version. The button below opens a page containing links to archived versions of PassLok, as well as authentication IDs for each one (no videos for most of them, though).</p>
  <button onclick="window.open('mirrors.html','_blank');" onBlur="ce();" onFocus="ce();" value="Show PassLok's ID" style="font-size:medium">PassLok archive</button>
  </div>
   <hr style="background-color: rgb(192, 192, 192); color: #000000;">
   
     <div onClick="openClose('a20')" style="cursor:hand; cursor:pointer">  
  <h3>I want to know PassLok in depth. Is there more information?</h3>
 </div>
  <div id="a20" class="texter">
    <p>You can start by looking at the help pages that open from the Locks screen (about Locks and Keys) and the extra functions screen (about disguising the output, files, and other neat tricks other than locking/unlocking). If this is not enough for you, here are a couple more sources you may want to check out:</p>
    <p>The PassLok <a href="passlok_manual.pdf" target="_blank">manual in PDF form.</a></p>
    <p>The PassLok informational website at <a href="http://passlok.weebly.com" target="_blank">http://passlok.weebly.com</a>. It contains a number of videos and more PDF documents.</p>
  </div>
   <hr style="background-color: rgb(192, 192, 192); color: #000000;">
     
    <div onClick="openClose('a21')" style="cursor:hand; cursor:pointer">
<h3>Privacy Statement</h3>
</div>
<div id="a21" class="texter">
<p>PassLok provides excellent security, since it is a self-contained piece of code that does not rely on servers for its functionality. Therefore:</p>
<p><strong>1. We'll never give your secret Key to anyone.</strong> We cannot do anything concerning your secret Key because we just don't have it. PassLok is designed so your secret Key never leaves the device.</p>
<p><strong>2. We'll never give you or anyone else a conterfeit Lock made from any Key</strong>. We just don't run key servers. PassLok has functions to help you to authenticate Locks, but this is still your responsibility.</p>
<p><strong>3. We'll never weaken the cryptography methods contained within PassLok at the request of a third party, private or public.</strong> This also means no backdoors will ever be added. We'd rather shut down the project than be forced to do this, which would betray the very essence of PassLok. If we learn that counterfeit copies are circulating (whether placed by hackers or government agencies), we'll make the fact known to users.</p>
<p>Since the html version of PassLok is a piece of human-readable writing, we consider it an expression of free speech protected by the laws of many countries. Putting into circulation tampered versions of it violates free speech and copyright protection laws.</p>
<p>On the other hand:</p>
<p>The biggest vulnerability of PassLok is how easy it is to view, <strong>and consequently modify</strong> the html code. As mentioned above, we will never weaken the underlying cryptography, but others might. Even though we are taking pains to ensure that PassLok is delivered to you in the most secure way compatible with our budget, <strong>you should still make sure that you have obtained the genuine code.</strong></p>
<p>The method described in the other help screen, to verify the integrity of PassLok in html form, is less than perfect but it works in most situations. Once you are sure that your copy of PassLok is pristine, you can save it and run it as many times as you want from its storage location without having to connect to the page server again.</p>
<p>PassLok contains strong cryptographic methods, which may be illegal to use in some countries. Please check the local laws before using PassLok.</p>
</div>
<hr style="background-color: rgb(192, 192, 192); color: #000000;">

	<address>
	PassLok v1.7.03 &#169; F. Ruiz 2014
	</address>
    <ul>
	<li>
	engine: SJCL by Stark, Hamburg, and Boneh 2012
	</li>
    <li>
    Lock server by W. Huang 2014
    </li>
    <li>
    text hide trick by S. Gangadharan 2005
    </li>
	<li>
    password strength meter by D. Karr 2007
    </li>
	<li>
    Shamir secret sharing by A. Stetsyuk 2013
    </li>
	<li>
    image hiding: PixelJihad by Zach Oakes 2012
    </li>
    <li>
    file In/Out based on an article from the This Could Be Better blog. 2012</li>
    <li>sjcl-scrypt key stretching implementation by joe-invincible 2013</li>
    </ul>
    <address>This document may be used, modified or redistributed under GNU GPL license, version 3.0 or higher.</address>
    <hr style="background-color: rgb(192, 192, 192); color: #000000;"> 
    
  <button onclick = "openClose('mainhelp');openClose('mainscr');" onBlur="ce();" onFocus="ce();" value="< Back" style="font-size:medium">&#x25C0; Back</button>
</div>

<div id="lockhelp" class="texter" style="display: none;">
	<button onclick = "openClose('lockhelp');openClose('lockscr');" onBlur="ce();" onFocus="ce();" value="< Back" style="font-size:medium">&#x25C0; Back</button>
     <hr style="background-color: rgb(192, 192, 192); color: #000000;">

  <div onClick="openClose('b1')" style="cursor:hand; cursor:pointer">  
<h3>Add an item (shared Key, Lock, etc.) to PassLok's permanent storage</h3>
  </div>
    <div id="b1" class="texter">
      <p>1. You must have entered your secret Key for any items to be stored. You enter this Key by means of the <strong>myKey</strong> button on the main screen.</p>
      <p>2. Write a name for the item in the little box on top. If the name is already taken, something will appear in the large box below it; if you use that name, the stored item will be replaced rather than added.</p>
      <p>3. Write or paste the item in the large box. It can be anything: somebody's Lock, a shared Key, a cover text, a list (don't write your secret Key here; its proper place is the dialog that opens with the myKey button). Then click the <strong>Save</strong> button.</p>
      <p>4. If you write nothing in the large box before clicking the <strong>Save</strong> button, PassLok will generate a 86-character base64 string, which will be stored under the name supplied in the small box. This way you can use PassLok to make secure passwords for websites, etc.</p>
      <p>5. A message confirms that the item has been added, and the item itself appears in the box, encrypted with your secret Key.</p>
      <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=FDNRK4CdW2o" target="_blank">https://www.youtube.com/watch?v=FDNRK4CdW2o</a></p>
    </div>
    <hr style="background-color: rgb(192, 192, 192); color: #000000;">
   
 <div onclick="openClose('b2')" style="cursor:hand; cursor:pointer">
<h3>Retrieve an item from permanent storage</h3>
  </div>
      <div id="b2" class="texter">
       <p>1. You must have entered your secret Key for any stored items to be retrieved. You enter this Key by means of the <strong>myKey</strong> button on the main screen.</p>
       <p>2. Start writing the name of the item in the small box. As you type, the line above the box displays existing items matching what you have typed so far, and the encrypted item appears in the large box. You can stop typing once you see the item you're looking for. Search is case-insensitive, so if the item does not appear, that probably means that the name is wrong.</p>
       <p>3. PassLok can use the item in encrypted form, but if you want to see the original, you can type "Enter" after the correct name is displayed, and the item will be decrypted. The item is also decrypted when you click the <strong>Back</strong> button. If the item is a cover text, it loads automatically as new cover text.</p>
       <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=FDNRK4CdW2o" target="_blank">https://www.youtube.com/watch?v=FDNRK4CdW2o</a></p>
       </div>
     <hr style="background-color: rgb(192, 192, 192); color: #000000;" />
       
<div onclick="openClose('b3')" style="cursor:hand; cursor:pointer">
 <h3>Delete a stored item</h3>
 </div>
  <div id="b3" class="texter">
       <p>1. Start writing the name of the item in the small box. As you type, the line above the box displays existing items matching what you have typed so far, and the encrypted item appears in the large box. You can stop typing once you see the item you're looking for. Search is case-insensitive, so if the item does not appear, that probably means that the name is wrong.</p>
       <p>2. Click the <strong>Del</strong> button. A message confirms that the item has been deleted from permanent storage</p>
       <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=_rR_ZQZ932c" target="_blank">https://www.youtube.com/watch?v=_rR_ZQZ932c</a></p>
       </div>
  <hr style="background-color: rgb(192, 192, 192); color: #000000;" />
        
 <div onclick="openClose('b4')" style="cursor:hand; cursor:pointer">
 <h3>Reset the hidden information pertaining to an item (PFS, etc.)</h3>
 </div>
  <div id="b4" class="texter">
          <p>1. Start writing the name of the item in the small box. As you type, the line above the box displays existing items matching what you have typed so far, and the encrypted item appears in the large box. You can stop typing once you see the item you're looking for. Search is case-insensitive, so if the item does not appear, that probably means that the name is wrong.</p>
          <p>2. Click the <strong>Reset</strong> button. A message confirms that the PFS data for the item has been deleted. You must reset the data pertaining to the other party whenever a PFS conversation has gone out of sync so the PFS process can be restarted.</p>
          <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=_rR_ZQZ932c" target="_blank">https://www.youtube.com/watch?v=_rR_ZQZ932c</a></p>
  </div>
  <hr style="background-color: rgb(192, 192, 192); color: #000000;" />
  
<div onclick="openClose('b5')" style="cursor:hand; cursor:pointer">
      <h3>Find a Lock in PassLok's general directory</h3>
  </div>
  <div id="b5" class="texter">
        <p>Sometimes you may need somebody's Lock and not have it stored anywhere. This is where PassLok's general directory comes in. When you click the <strong>Lock directory</strong> button, a new screen opens up where you can search for a Lock, watch the authenticating video belonging to a Lock, or upload your own Lock. The Locks in this directory are indexed by email address.</p>
        <p>The Lock directory has its own set of help pages, but let us mention here some important things:</p>
        <p>a. The Lock directory is a separate webpage from PassLok, which is indicated by a different color scheme. Therefore, you will need to copy and paste material between it and PassLok.</p>
        <p>b. PassLok makes no guarantee as to the authenticity of the Locks contained in its directory. Email confirmation is required to load or update Locks, but this is not very secure. Since users are encouraged to add authenticating videos and the directory screen has a button especially designed to play them, you should watch the video attached to a Lock before you use it for anything sensitive.</p>
        <p>c. The PassLok directory is meant as a convenience, not as a replacement for your local database. The directory is not available when you are offline (the local database is). You cannot upload anything but Locks to the directory.</p>
        <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=1UQw7MaK3T8" target="_blank">https://www.youtube.com/watch?v=1UQw7MaK3T8</a></p>      
  </div>
  <hr style="background-color: rgb(192, 192, 192); color: #000000;" />
       
 <div onclick="openClose('b6')" style="cursor:hand; cursor:pointer">
      <h3>Display the entire stored database</h3>
  </div>
  <div id="b6" class="texter">
        <p>1. Click the <strong>All</strong> button below the big box. The complete stored database, including PFS and hidden data, is displayed in the box so you can find items and copy them easily.</p>
        <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=V_DwcEyaeIQ" target="_blank">https://www.youtube.com/watch?v=V_DwcEyaeIQ</a></p>
        </div>
  <hr style="background-color: rgb(192, 192, 192); color: #000000;" />
           
  <div onclick="openClose('b7')" style="cursor:hand; cursor:pointer">
  <h3>Move the entire stored database</h3>
       </div>
 <div id="b7" class="texter">
      <p>1. Click the <strong>Move</strong> button below the big box. The entire database is first locked with the secret Key and placed in the main box. Then a prompt asks you to confirm deleting it from the device. If you click <strong>OK,</strong> the entire stored database is deleted. There is no going back. If you click <strong>Cancel</strong>, the locked backup remains in the main box. This is useful whenever you stop using a device or just want to transfer it to another device, or if the database becomes corrupted.</p>
      <p>2. To retrieve a backed-up database (has PL**db tags), place it in the main box and click <strong>Lck/Un</strong>. If the secret Key has been entered, the database will be unlocked and placed in the Locks screen. Then you can add it to the device's current database by clicking <strong>Merge</strong>.</p>
  <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=V_DwcEyaeIQ" target="_blank">https://www.youtube.com/watch?v=V_DwcEyaeIQ</a></p>
  </div>
 <hr style="background-color: rgb(192, 192, 192); color: #000000;" />

 <div onclick="openClose('b8')" style="cursor:hand; cursor:pointer">
       <h3>Merge additional data into the stored database</h3>
  </div>
  <div id="b8" class="texter">
       <p>1. Paste the additional data into the big box. The format is the following: name, followed by a colon (:), new line, item data; then two new lines before the next name, and so forth. If a name also has hidden data and PFS data, those follow the item data, occupying consecutive lines.</p>
       <p>2. Click the <strong>Merge</strong> button. The new data is merged into the stored database. Items are added in encrypted form but are notchecked as they are added, so it is possible that different items may need different Keys to be decrypted.</p>
       <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=V_DwcEyaeIQ" target="_blank">https://www.youtube.com/watch?v=V_DwcEyaeIQ</a></p>
  </div>
  <hr style="background-color: rgb(192, 192, 192); color: #000000;" />
                     
 <div onclick="openClose('b9')" style="cursor:hand; cursor:pointer">
     <h3>Make a List of items</h3>
 </div>
  <div id="b9" class="texter">
      <p>1. You can always make a List of Locks and shared Keys, in order to lock a message for multiple recipients, by writing the Locks or shared Keys in separate lines of the Locks box. PassLok will remember it during the session if you click the <strong>List</strong> button. Adding one or several items is as easy as putting them in the box and clicking<strong> List</strong> again. If you click <strong>List</strong> with the box empty, the current List will be displayed.The current List is deleted by pressing the <strong>Reset</strong> button while the List is displayed.</p>
      <p>1. If you want to store a List permanently, you must write a name for it in the small box, then write the items or re-display them by clicking the<strong> List</strong> button, and then click <strong>Save</strong>. You must have entered your secret Key before the List can be saved. The process for entering this Key is described above.</p>
      <p>2.You can also make a List of items already stored in the database, which can be itself stored. In this case, write the name of the item rather than the item itself. if you don't recall the exact name of an item, start typing it in the little box, and click <strong>List</strong> when the correct item appears; the item name will be added to the current List.</p>
      <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=sO-g9x2RAV8" target="_blank">https://www.youtube.com/watch?v=sO-g9x2RAV8</a></p>
      </div>              
     <hr style="background-color: rgb(192, 192, 192); color: #000000;">
     
  <div onclick="openClose('b10')" style="cursor:hand; cursor:pointer">
  <h3>Make a random Key and its Lock</h3>
  </div>
 <div id="b10" class="texter">
      <p>Sometimes you want to make a high-security random Key, which will be split into several parts for safekeeping, as described in another help screen, or stored in encrypted form, rather than memorized (because you are never going to write it down unencrypted, right?). PassLok provides two ways to make this 86-character random Key:</p>
      <p>a. Click <strong>myKey</strong>, and then, with the key box empty, click <strong>Make Lock</strong>. The box fills with the random Key, which you can then reveal for copying by checking the Show checkbox, and places its matching Lock in the main box.</p>
      <p>b. Click <strong>Locks</strong>, and write a name in the small name box. If the name is not in the database, the large box will end up empty. Then, with the large box empty, click <strong>Save</strong>. An 86-character random Key is made, which is immediately encrypted with the secret Key, if that has been previously entered. From then on this random Key, suitable as a shared Key or high-security password for a login, can be recalled and used by typing its name into the small box.</p>
      <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=9gRE1xPr_nE" target="_blank">https://www.youtube.com/watch?v=9gRE1xPr_nE</a></p>
  </div>
 <hr style="background-color: rgb(192, 192, 192); color: #000000;" />
 
   <div onclick="openClose('b11')" style="cursor:hand; cursor:pointer">
  <h3>Combine a Key and a Lock</h3>
  </div>
 <div id="b11" class="texter">
      <p>This operation, which goes by the technical name of "Diffie-Hellman key exchange" is at the core of many PassLok functions. Should you ever want to compute the result manually, here is how to do it:</p>
      <p>1. Write or paste the Key or the Lock in the main box.</p>
      <p>2. Click <strong>Locks</strong>, and then write or paste the other item in the large box. If the item is in PassLok's permanent storage, you can bring it out by starting to type its name in the small box.</p>
      <p>3. Click the <strong>Merge</strong> button below the large box. The Key and the Lock will merge and the 86-character result is placed in both boxes. If both items or neither of them is a valid Lock, the merging process fails and a message is displayed to inform the user.</p>
      <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=L0UC61Z2KAA" target="_blank">https://www.youtube.com/watch?v=L0UC61Z2KAA</a></p>
  </div>
 <hr style="background-color: rgb(192, 192, 192); color: #000000;" />
 
   <div onclick="openClose('b12')" style="cursor:hand; cursor:pointer">
  <h3>Make a video to authenticate your Lock</h3>
  </div>
 <div id="b12" class="texter">
      <p>It is highly recommended that you make a video whenever you change your secret Key, so that others can verify that the matching Lock really belongs you. PassLok does not have video functions, but here are a few short instructions on how to do this using a popular online video resource:</p>
      <p>1. When you make your Lock, click the <strong>(...)</strong> button on PassLok so the Lock&rsquo;s ID is displayed above the window. Copy this ID.</p>
      <p>2. Go to a device with a camera and make a video of yourself reading this ID. For better security, have some music playing in the background as you read the ID. For good measure, you may want to show to the camera a piece of paper where you've written the ID.  The video should be about one minute long. Then post the video on a public online service.</p>
      <p>3. When you post your Lock so that people can use it to lock messages for you, post also the address of the video on the line immediately below the Lock, to facilitate the verifying process in step 4.</p>
      <p>4. People wishing to authenticate your Lock can generate the ID as in step 1 (which usually won't be affected by having the video address on the line below), and then they can  click the <strong>Show</strong> button, which will open the accompanying video if the address is written below the Lock itself. Then they will be able to compare it with the ID they see you reading in the video. If they know your face and your voice, they will be assured that the Lock is authentic.</p>
      <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=bODBEB6Oo2I" target="_blank">https://www.youtube.com/watch?v=bODBEB6Oo2I</a></p>
 </div>
 <hr style="background-color: rgb(192, 192, 192); color: #000000;" />
 
   <div onclick="openClose('b13')" style="cursor:hand; cursor:pointer">
  <h3>Authenticate a Lock without using videos</h3>
  </div>
 <div id="b13" class="texter">
      <p>The easy way: get the ID of the Lock by placing it in the main box and clicking <strong>(...)</strong>. The ID will be displayed at the top. Then you can call the Lock's owner and ask him/her to read the same ID over the phone. But let's say you cannot establish a live conversation. If you are communicating exclusively by email, you can send a person whom you know and who knows you the following message, or something like it:</p>
      <p><br />
        <em>Dear So-and-So:</em><br />
        <em>I just obtained your PassLok Lock from (cite source), but I still wonder if it is authentic since I am unable to view the authenticating video. Therefore, I ask you to help me authenticate it through the interlock protocol. Here's what I want you to do:</em></p>
      <ol>
        <li><em>Write me a message asking me to take a picture or video of myself doing something of your choice. Lock it with my Lock, which is at the bottom of this message, but don't send it back to me just yet. Instead, save it and display the locked message's ID, and send me that.</em></li>
        <li><em>When I receive your ID, I will also write a message asking you to do something in a picture or short video, which I'll lock with your Lock. But I'll send you the ID first. When you get it, go ahead and send me the locked message containing your instructions.</em></li>
        <li><em>When I get that, I'll check that the ID matches and then I'll follow your instructions. I'll send you the picture or video right away, unlocked, along with my locked request. Expect to receive it within half an hour of your message.</em></li>
        <li><em>When you get it, please make sure it matches the ID I sent you earlier, and that what I sent conforms to your instructions. If everything is okay, go ahead and follow my instructions and send me the result as soon as possible, unlocked as well, within half an hour if you can. Then I'll know that your Lock is authentic.</em></li>
    </ol>
      <p><em>Many thanks. Sicerely, This-and-That</em></p>
    <p><br />
      Alternatively, you can ask the other person to split the locked message in two, and send you first one half, then the other half (PassLok has a built-in function to split messages securely, explained in another help screen).  The pictures or videos (or recordings) don't need to be locked. Only the instructions for making them need to be locked and transmitted with a two-step process. There is an article in PassLok.com on what makes this protocol work for authenticating Locks.</p>
  </div>
 <hr style="background-color: rgb(192, 192, 192); color: #000000;" />
  
  <button onclick = "openClose('lockhelp');openClose('lockscr');" onBlur="ce();" onFocus="ce();" value="< Back" style="font-size:medium">&#x25C0; Back</button>
</div>

<div id="extrahelp" class="texter" style="display: none;">
	<button onclick = "openClose('extrahelp');openClose('extrascr');" onBlur="ce();" onFocus="ce();" value="< Back" style="font-size:medium">&#x25C0; Back</button>
     <hr style="background-color: rgb(192, 192, 192); color: #000000;">
     
  <div onClick="openClose('c1')" style="cursor:hand; cursor:pointer">
<h3>Send a PassLok item (Lock, message, etc.) by email</h3>
  </div>
  <div id="c1" class="texter">  
<p>1. Check that the item is in the main box.</p>
<p>2. Click the <strong>(...)</strong> button in order to reveal the button dealing with email, which is above the text box.</p>
<p>3. Click the <strong>Mail</strong> button. If so configured in the device, a window appears containing the item and some explanatory text. You only need to supply the recipient's email address and a subject line before clicking the Send button. If you do not want any explanatory text, check the No tags checkbox in the main screen before clicking (...).</p>
<p>4. This only works for sending messages, not for receiving them. If you receive a PassLok-locked message, you must copy it into the clipboard and then paste it into the main box of PassLok, so it can be unlocked. Be also aware that webmail services, such as Gmail, limit the length of messages that can be composed this way. If you get an error from the mail host, you can always copy the box and paste it into a normal mail compose screen.</p>
<p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=2zxCkA4rDN8" target="_blank">https://www.youtube.com/watch?v=2zxCkA4rDN8</a></p>
</div>
  <hr style="background-color: rgb(192, 192, 192); color: #000000;">
  
  <div onClick="openClose('c2')" style="cursor:hand; cursor:pointer">
<h3>Send a PassLok item by Text messaging (mobile only)</h3>
  </div>
  <div id="c2" class="texter">  
<p>1. Check that the item to be sent is in the main box.</p>
<p>2. Click the <strong>(...)</strong> button in order to reveal the button dealing with text messaging, which is labeled SMS.</p>
<p>3. Click the <strong>Sel</strong> button so the text can be selected.</p>
<p>4. Then click the Copy label as it appears on screen. The item is copied to clipboard.</p>
<p>5. Now you can click the <strong>SMS</strong> button. A window appears with the default texting app.</p>
<p>6. Touch the input box and then paste the clipboard. Send the message in the usual way.</p>
<p>7. To unlock a locked message received by texting, you must copy it to clipboard, and then paste it in the main box of PassLok.</p>
<p>If you use Short Mode to lock a message, steps 2 and 3 are automatic.</p>
<p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=2zxCkA4rDN8" target="_blank">https://www.youtube.com/watch?v=2zxCkA4rDN8</a></p>
</div>
<hr style="background-color: rgb(192, 192, 192); color: #000000;" />

<div onclick="openClose('c3')" style="cursor:hand; cursor:pointer">
  <h3>Split an item into several random-looking parts</h3>
</div>
<div id="c3" class="texter">
  <p>1. Make sure the main box is empty, and then click the <strong>(...)</strong> button.</p>
  <p>2. The item should remain in the box as the buttons around it change. Then click the <strong>Split/Join</strong> button.</p>
  <p>3. A popup asks for the number of parts required to retrieve the original. Write the number, which must be between 2 and 255, and click <strong>OK</strong>. The parts appear in the main box and a message confirms it. If you need more parts (the number required won't change), click <strong>Split/Join</strong> again for each additional part. Copy the parts one by one and send/store them as needed. It is okay to strip the tags up to the "=" sign, but not recommended. PassLok will do this automatically if the No tags checkbox is checked prior to locking. It is also okay to split the parts with spaces and punctuation other than = + / or line returns.</p>
  <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=3-6CNa6iNKc" target="_blank">https://www.youtube.com/watch?v=3-6CNa6iNKc</a></p>
</div>
<hr style="background-color: rgb(192, 192, 192); color: #000000;" />

<div onclick="openClose('c4')" style="cursor:hand; cursor:pointer">
  <h3>Join parts to retrieve the original item (tags are PL**p***)</h3>
</div>
<div id="c4" class="texter">
  <p>1. Paste a sufficient number of parts on separate lines of the main box. Make sure that each part is unique. You need as many parts as the number entered when the Key was split, which is written at the end of each PL**p tag. Having more parts than the minimum is OK, so long as they belong to the same set and are not corrupt. They don't need to be placed in any particular order.</p>
  <p>2. Click the <strong>(...)</strong> button, and then the  <strong>Split/Join</strong> button. If all goes well, the reconstructed item appears in the box, otherwise nothing happens. Likely problems include: insufficient number of parts, incomplete or corrupt parts, parts belonging to different sets.</p>
  <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=3-6CNa6iNKc" target="_blank">https://www.youtube.com/watch?v=3-6CNa6iNKc</a></p>
  </div>
  <hr style="background-color: rgb(192, 192, 192); color: #000000;">
     
  <div onClick="openClose('c5')" style="cursor:hand; cursor:pointer">
<h3>Convert a PassLok item (Lock, message, etc.) into fake text</h3>
  </div>
  <div id="c5" class="texter">  
<p>1. Check that the item to be converted into fake text is in the main box. Then click the <strong>(...)</strong> button.</p>
<p>2. If you wish to make fake text that is not English, you will have to change the cover text using the process described in the next item.</p>
<p>3. The <strong>Words</strong> button replaces each character of the text with a word from the cover text; the recipient of the message thus encoded must have the same cover text. The <strong>Spaces</strong> button encodes the text into the spaces of the cover text; the recipient does not need to have the original cover text, but it takes seven times more words than the other mode. When you click either button, the contents of the box are converted into fake text using the current cover, replacing the previous contents.</p>
<p>4. You can now email the fake text, which to an email scanner will be nearly indistinguishable from real text. You can change the punctuation and merge or split lines without changing the encoded material. If you used Spaces encoding, you should be careful not to add or delete any spaces within the encoded text, but it is OK to add more text to complete the last sentence, which may contain additional spaces.</p>
  <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=KwAETd2pgy4" target="_blank">https://www.youtube.com/watch?v=KwAETd2pgy4</a></p></div>
  <hr style="background-color: rgb(192, 192, 192); color: #000000;">
  
  <div onClick="openClose('c6')" style="cursor:hand; cursor:pointer">
<h3>Retrieve the original PassLok item from fake text</h3>
  </div>
  <div id="c6" class="texter">
<p>1. Check that the fake text is in the main box. Then click the <strong>(...)</strong> button.</p>
<p>2. If the fake text was encoded with the Words method, you will first have to load the cover text used to do the encoding, using the process described in the next item.</p>
<p>3. Now click either the <strong>Words</strong> button or the <strong>Spaces</strong> button, it doesn't matter which. If successful, the fake text in the box is converted back into the original item and displayed in the box, replacing the fake text.</p>
  <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=KwAETd2pgy4" target="_blank">https://www.youtube.com/watch?v=KwAETd2pgy4</a></p></div>
  <hr style="background-color: rgb(192, 192, 192); color: #000000;">
 
  <div onClick="openClose('c7')" style="cursor:hand; cursor:pointer">
<h3>Display or change the cover text used for fake text</h3>
  </div>
  <div id="c7" class="texter">
<p>To display the current cover text (which is the default cover text after reloading PassLok), click the <strong>(...)</strong> button, and then the <strong>Cover </strong>button with the box empty.</p>
<p>To change the cover text (this is necessary to make fake text in a language that is not English):</p>
<p>1. Copy a sufficiently long text (must have at least 70 different words) and paste it into the box.</p>
<p>2. Click the <strong>(...)</strong> button, and then the <strong>Cover</strong> button.</p>
<p>3. If the change is successful, the box goes blank. If the change is unsuccessful, a message above the box will say why. Typically, failure to change the cover text is due to not having a sufficient number of different words. Use a longer text and try again.</p>
<p>4. The recipient of your messages turned into fake text must have the same cover text in order to retrieve a text encoded with the<strong> Words</strong> method. One way to ensure this when using a non-English language is to display the default cover text, copy it into a translation utility such as Google Translate, and then use the translation as the new cover text.</p>
<p>5. Since the cover text is a (weak) sort of password for a Words-encoded item, it may be good to put special cover texts in permanent storage. To do this, go to the <strong>Locks</strong> screen , write a new name in the small box, then paste the cover text in the large box, and click Save. The cover text can be retrieved like any other stored item, and it will be automatically loaded if displayed on the Locks screen.</p>
  <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=sv8epS3qBH8" target="_blank">https://www.youtube.com/watch?v=sv8epS3qBH8</a></p></div>
  <hr style="background-color: rgb(192, 192, 192); color: #000000;">
    
  <div onClick="openClose('c8')" style="cursor:hand; cursor:pointer">  
  <h3>Load a file (image, on mobile devices) to be locked, signed, or split</h3>
  </div>
  <div id="c8" class="texter">
  <p>1. Click the <strong>(...)</strong> button, and then the button at the bottom of the screen. Different browsers put different labels on it, such as <strong>"Browse"</strong>, <strong>"Choose File"</strong>, and so forth.</p>
  <p>2. A dialog will appear so you can navigate to the file. Mobile devices, unless they are jailbroken or rooted, restrict the selection to images stored on the device or acquired with the built-in camera. Be aware that pictures taken by the camera are usually too large for PassLok to handle. If all goes well, the file or image loads into the box as a (long) piece of gibberish text, with some identifying information at the top.</p>
  <p>3. Now you can lock it, sign it, or split it like a regular piece of text. The process to retrieve the original file is explained in the item below.</p>
  <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=v6jnKzzlwS0" target="_blank">https://www.youtube.com/watch?v=v6jnKzzlwS0</a></p>
  </div>
    <hr style="background-color: rgb(192, 192, 192); color: #000000;">
  
  <div onClick="openClose('c9')" style="cursor:hand; cursor:pointer">  
  <h3>Retrieve a file (image, on mobile devices) from encoded text</h3>
  </div>
    <div id="c9" class="texter">
  <p>1. Make sure the encoded file, which presumably has been obtained by unlocking or merging parts, is in the main box. Click the <strong>(...)</strong> button.</p>
  <p>2. Click the <strong>Show</strong> button at the bottom of the screen. What happens next depends on the browser. Chrome and Firefox will save the file, using the original name if not already taken by another file, into the default location for downloads. Safari does the same, but gives it a generic name that you will have to edit later. Internet Explorer doesn't do anything. Mobile browsers normally open another tab displaying the file contents (if the file type is recognized), from where one can send it to another app.</p>
  <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=v6jnKzzlwS0" target="_blank">https://www.youtube.com/watch?v=v6jnKzzlwS0</a></p>
  </div>
    <hr style="background-color: rgb(192, 192, 192); color: #000000;">

 <div onClick="openClose('c10')" style="cursor:hand; cursor:pointer">  
  <h3>Hide a PassLok item inside an image</h3>
 </div>
  <div id="c10" class="texter">
 <p>1. Make sure the item to be hidden is in the main box, and it remains there after clicking the <strong>(...)</strong> button . Then click the <strong>Images</strong> button below the box.</p>
<p>2. A new screen appears to load the image where the text is to be hidden. To do so, click the <strong>"Choose File"</strong> or <strong>"Browse"</strong> button (browsers vary on the name). A dialog will appear, where you can choose the imag. Bear in mind that images taken with a mobile camera are usually too large for PassLok to be able to use them for hiding items, because of the processing required.</p>
    <p>3. When you see the image, click the <strong>Hide</strong> button. Processing will start, and a message will say when it is completed. At this point, you can right-click (or tap-hold, on mobile devices) and another dialog will offer to save the image. This image now contains the item from the main box, even though it looks the same as before.</p>
    <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=lRIYi6IDNzY" target="_blank">https://www.youtube.com/watch?v=lRIYi6IDNzY</a></p>
 </div>
    <hr style="background-color: rgb(192, 192, 192); color: #000000;">
   
 <div onClick="openClose('c11')" style="cursor:hand; cursor:pointer">  
  <h3>Retrieve the PassLok item hidden inside an image</h3>
 </div>
  <div id="c11" class="texter">
      <p>1. Navigate to the image hiding screen by clicking <strong>(...)</strong>, and then <strong>Images</strong>. </p>
      <p>2. Click <strong>Choose File</strong> or <strong>Browse</strong> (browsers vary on this) and select the image containing the hidden item.</p>
      <p>3. When the image displays on the screen, click the <strong>Reveal</strong> button. Processing begins, and a message appears when it concludes, saying that the hidden item has been retrieved. If you click <strong>Back</strong> at this point, you will see the item in the big box. If the image contained nothing, a message will tell you.</p>
      <p>4. Current mobile browsers destroy hidden information as they load images. Therefore, the <strong>Reveal</strong> button is disabled on mobile browsers. They can Hide items in images perfectly well, however.</p>
      <p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=lRIYi6IDNzY" target="_blank">https://www.youtube.com/watch?v=lRIYi6IDNzY</a></p>
 </div>
   <hr style="background-color: rgb(192, 192, 192); color: #000000;">
     
  <div onClick="openClose('c12')" style="cursor:hand; cursor:pointer">
<h3>Verify PassLok's integrity</h3>
</div>
<div id="c12" class="texter">
<p>To check the integrity of an html version of PassLok:</p>
<p>1. Load PassLok from one of the authorized sources listed by the button below, or from storage (local or cloud) if previously saved as html as described in step 3b.</p>
<p>2. Direct your browser to "view source". Each
  browser does this differently, but most non-mobile browsers have this capability. Typically, you load the source on a separate tab by typing CTRL-u (Windows) or option-cmd-u (OSX). On
  the page displaying the source, select all (CTRL-a or cmd-a), then copy to clipboard (CTRL-c or cmd-c). Alternatively, you can get the source from PassLok's GitHub repository at: <a href="https://github.com/fruiz500/passlok" target="_blank">https://github.com/fruiz500/passlok</a>. <strong>DO NOT save the code using the "save" command from the browser menu</strong>, since this command modifies the source code before saving it. A copy of PassLok saved this way will still run, but its SHA256 will be different. If your operating system is Windows, do not use the built-in Notepad program, since it cannot save text with the appropriate encoding. Be sure there are no extra spaces at top and bottom, since this would affect the result.</p>
<p>3. Now you have to take the SHA256 of the code on the clipboard using a program different from PassLok. You have several options:</p>
<blockquote>
  <p>a. Use an online utility, where you paste the text on a box and click a button. You must make sure that pasting did not add extra space at the top of the file, which would affect the result. The one at Xorbin (http://www.xorbin.com/tools/sha256-hash-calculator) has worked quite well in our tests.</p>
  <p>b. Save the clipboard to a text file, and then use a local program or utility to take the SHA256 of the file (built into the OS in Linux and OSX, not so in Windows). In order to save to file, you will need to start a new file in a good text editor and paste the clipboard there. Then obtain the SHA256 of this file using the local program.</p>
  <p>c. PassLok does have the ability to save anything contained in the box of the extra functions screen to a text file by clicking the <strong>Save</strong> button, as well as to take the SHA256 of the box contents (displayed on the line above), but be aware of the danger that these functions might have been tampered with.</p>
</blockquote>
<p>4. Click the button below and look up the SHA256 for this version of PassLok. If this value and the one obtained in step 3 are the
  same, the program has not been tampered with. Now, a hacker who could tamper with the source code at the server could also change the ID so it matches the tampered code. To make sure that the value is authentic you should watch the one-minute video where the author or PassLok, Francisco Ruiz, reads that string aloud. A link to the video is on the page that opens with the button below.</p>
<p>All of this is explained in this video tutorial: <a href="https://www.youtube.com/watch?v=1QSRvme3pVQ" target="_blank">https://www.youtube.com/watch?v=1QSRvme3pVQ</a></p>
	<button onclick="window.open('mirrors.html','_blank');" onBlur="ce();" onFocus="ce();" value="Show PassLok's ID" style="font-size:medium">Show PassLok's ID</button>
</div>
  <hr style="background-color: rgb(192, 192, 192); color: #000000;">

  <button onclick = "openClose('extrahelp');openClose('extrascr');" onBlur="ce();" onFocus="ce();" value="< Back" style="font-size:medium">&#x25C0; Back</button>
</div>
</body></html>