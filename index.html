<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>PassLok privacy</title>
    <style type="text/css">
	    body {
		font-family: Sans-Serif;
		width: 100%;
		margin-left: 1%;
		margin-right: 1%;
		background-color: #FFFFFF;
		color: #000000;
		overflow-x: hidden;
	    }
		label {
		display: inline-block;
		margin-left: 1%;
		margin-right: 1%;
		vertical-align:middle;
		}
	</style>
       
    <meta name="Keywords" content="passlok, URSA, browser, encryption, decryption, symmetric, public key, signature, AES, ECDH, Diffie, Hellman, elliptic curve, advanced, javascript, PGP, OTR">
    <meta name="Description" content="PassLok privacy">
    <meta name="author" content="F. Ruiz">
    <meta name="robots" content="index">
    <meta name="viewport" content="width=device-width, minimum-scale=1, maximum-scale=1, user-scalable=no">
	<link rel="apple-touch-icon" href="passlok-touch-icon.png">

<script>
        /* 
		@source: https://passlok.site44.com/index.html
		   
        @licstart  The following is the entire license notice for the 
        JavaScript code in this page.

        Copyright (C) 2013  Francisco Ruiz

        The JavaScript code in this page is free software: you can
        redistribute it and/or modify it under the terms of the GNU
        General Public License (GNU GPL) as published by the Free Software
        Foundation, either version 3 of the License, or (at your option)
        any later version.  The code is distributed WITHOUT ANY WARRANTY;
        without even the implied warranty of MERCHANTABILITY or FITNESS
        FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

        As additional permission under GNU GPL version 3 section 7, you
        may distribute non-source (e.g., minimized or compacted) forms of
        that code without the copy of the GNU GPL normally required by
        section 4, provided you include this license notice and a URL
        through which recipients can access the Corresponding Source.   


        @licend  The above is the entire license notice
        for the JavaScript code in this page.
        */
        </script>
        
        <script type="text/javascript">
    if (window.location.protocol == "http:") {				//force SSL/TLS

        var restOfUrl = window.location.href.substr(5);
        window.location = "https:" + restOfUrl;
    }
</script>
		
   <script>
/**   QRCODE.js  by David Shim begins */
var QRCode;

(function () {
		//---------------------------------------------------------------------
		// QRCode for JavaScript
		//
		// Copyright (c) 2009 Kazuhiko Arase
		//
		// URL: http://www.d-project.com/
		//
		// Licensed under the MIT license:
		//   http://www.opensource.org/licenses/mit-license.php
		//
		// The word "QR Code" is registered trademark of 
		// DENSO WAVE INCORPORATED
		//   http://www.denso-wave.com/qrcode/faqpatent-e.html
		//
		//---------------------------------------------------------------------
		function QR8bitByte(data) {
			this.mode = QRMode.MODE_8BIT_BYTE;
			this.data = data;
		}
		QR8bitByte.prototype = {
			getLength: function (buffer) {
				return this.data.length;
			},
			write: function (buffer) {
				for (var i = 0; i < this.data.length; i++) {
					buffer.put(this.data.charCodeAt(i), 8);
				}
			}
		};

		function QRCodeModel(typeNumber, errorCorrectLevel) {
			this.typeNumber = typeNumber;
			this.errorCorrectLevel = errorCorrectLevel;
			this.modules = null;
			this.moduleCount = 0;
			this.dataCache = null;
			this.dataList = [];
		}
		QRCodeModel.prototype = {
			addData: function (data) {
				var newData = new QR8bitByte(data);
				this.dataList.push(newData);
				this.dataCache = null;
			},
			isDark: function (row, col) {
				if (row < 0 || this.moduleCount <= row || col < 0 || this.moduleCount <= col) {
					throw new Error(row + "," + col);
				}
				return this.modules[row][col];
			},
			getModuleCount: function () {
				return this.moduleCount;
			},
			make: function () {
				this.makeImpl(false, this.getBestMaskPattern());
			},
			makeImpl: function (test, maskPattern) {
				this.moduleCount = this.typeNumber * 4 + 17;
				this.modules = new Array(this.moduleCount);
				for (var row = 0; row < this.moduleCount; row++) {
					this.modules[row] = new Array(this.moduleCount);
					for (var col = 0; col < this.moduleCount; col++) {
						this.modules[row][col] = null;
					}
				}
				this.setupPositionProbePattern(0, 0);
				this.setupPositionProbePattern(this.moduleCount - 7, 0);
				this.setupPositionProbePattern(0, this.moduleCount - 7);
				this.setupPositionAdjustPattern();
				this.setupTimingPattern();
				this.setupTypeInfo(test, maskPattern);
				if (this.typeNumber >= 7) {
					this.setupTypeNumber(test);
				}
				if (this.dataCache == null) {
					this.dataCache = QRCodeModel.createData(this.typeNumber, this.errorCorrectLevel, this.dataList);
				}
				this.mapData(this.dataCache, maskPattern);
			},
			setupPositionProbePattern: function (row, col) {
				for (var r = -1; r <= 7; r++) {
					if (row + r <= -1 || this.moduleCount <= row + r) continue;
					for (var c = -1; c <= 7; c++) {
						if (col + c <= -1 || this.moduleCount <= col + c) continue;
						if ((0 <= r && r <= 6 && (c == 0 || c == 6)) || (0 <= c && c <= 6 && (r == 0 || r == 6)) || (2 <= r && r <= 4 && 2 <= c && c <= 4)) {
							this.modules[row + r][col + c] = true;
						} else {
							this.modules[row + r][col + c] = false;
						}
					}
				}
			},
			getBestMaskPattern: function () {
				var minLostPoint = 0;
				var pattern = 0;
				for (var i = 0; i < 8; i++) {
					this.makeImpl(true, i);
					var lostPoint = QRUtil.getLostPoint(this);
					if (i == 0 || minLostPoint > lostPoint) {
						minLostPoint = lostPoint;
						pattern = i;
					}
				}
				return pattern;
			},
			createMovieClip: function (target_mc, instance_name, depth) {
				var qr_mc = target_mc.createEmptyMovieClip(instance_name, depth);
				var cs = 1;
				this.make();
				for (var row = 0; row < this.modules.length; row++) {
					var y = row * cs;
					for (var col = 0; col < this.modules[row].length; col++) {
						var x = col * cs;
						var dark = this.modules[row][col];
						if (dark) {
							qr_mc.beginFill(0, 100);
							qr_mc.moveTo(x, y);
							qr_mc.lineTo(x + cs, y);
							qr_mc.lineTo(x + cs, y + cs);
							qr_mc.lineTo(x, y + cs);
							qr_mc.endFill();
						}
					}
				}
				return qr_mc;
			},
			setupTimingPattern: function () {
				for (var r = 8; r < this.moduleCount - 8; r++) {
					if (this.modules[r][6] != null) {
						continue;
					}
					this.modules[r][6] = (r % 2 == 0);
				}
				for (var c = 8; c < this.moduleCount - 8; c++) {
					if (this.modules[6][c] != null) {
						continue;
					}
					this.modules[6][c] = (c % 2 == 0);
				}
			},
			setupPositionAdjustPattern: function () {
				var pos = QRUtil.getPatternPosition(this.typeNumber);
				for (var i = 0; i < pos.length; i++) {
					for (var j = 0; j < pos.length; j++) {
						var row = pos[i];
						var col = pos[j];
						if (this.modules[row][col] != null) {
							continue;
						}
						for (var r = -2; r <= 2; r++) {
							for (var c = -2; c <= 2; c++) {
								if (r == -2 || r == 2 || c == -2 || c == 2 || (r == 0 && c == 0)) {
									this.modules[row + r][col + c] = true;
								} else {
									this.modules[row + r][col + c] = false;
								}
							}
						}
					}
				}
			},
			setupTypeNumber: function (test) {
				var bits = QRUtil.getBCHTypeNumber(this.typeNumber);
				for (var i = 0; i < 18; i++) {
					var mod = (!test && ((bits >> i) & 1) == 1);
					this.modules[Math.floor(i / 3)][i % 3 + this.moduleCount - 8 - 3] = mod;
				}
				for (var i = 0; i < 18; i++) {
					var mod = (!test && ((bits >> i) & 1) == 1);
					this.modules[i % 3 + this.moduleCount - 8 - 3][Math.floor(i / 3)] = mod;
				}
			},
			setupTypeInfo: function (test, maskPattern) {
				var data = (this.errorCorrectLevel << 3) | maskPattern;
				var bits = QRUtil.getBCHTypeInfo(data);
				for (var i = 0; i < 15; i++) {
					var mod = (!test && ((bits >> i) & 1) == 1);
					if (i < 6) {
						this.modules[i][8] = mod;
					} else if (i < 8) {
						this.modules[i + 1][8] = mod;
					} else {
						this.modules[this.moduleCount - 15 + i][8] = mod;
					}
				}
				for (var i = 0; i < 15; i++) {
					var mod = (!test && ((bits >> i) & 1) == 1);
					if (i < 8) {
						this.modules[8][this.moduleCount - i - 1] = mod;
					} else if (i < 9) {
						this.modules[8][15 - i - 1 + 1] = mod;
					} else {
						this.modules[8][15 - i - 1] = mod;
					}
				}
				this.modules[this.moduleCount - 8][8] = (!test);
			},
			mapData: function (data, maskPattern) {
				var inc = -1;
				var row = this.moduleCount - 1;
				var bitIndex = 7;
				var byteIndex = 0;
				for (var col = this.moduleCount - 1; col > 0; col -= 2) {
					if (col == 6) col--;
					while (true) {
						for (var c = 0; c < 2; c++) {
							if (this.modules[row][col - c] == null) {
								var dark = false;
								if (byteIndex < data.length) {
									dark = (((data[byteIndex] >>> bitIndex) & 1) == 1);
								}
								var mask = QRUtil.getMask(maskPattern, row, col - c);
								if (mask) {
									dark = !dark;
								}
								this.modules[row][col - c] = dark;
								bitIndex--;
								if (bitIndex == -1) {
									byteIndex++;
									bitIndex = 7;
								}
							}
						}
						row += inc;
						if (row < 0 || this.moduleCount <= row) {
							row -= inc;
							inc = -inc;
							break;
						}
					}
				}
			}
		};
		QRCodeModel.PAD0 = 0xEC;
		QRCodeModel.PAD1 = 0x11;
		QRCodeModel.createData = function (typeNumber, errorCorrectLevel, dataList) {
			var rsBlocks = QRRSBlock.getRSBlocks(typeNumber, errorCorrectLevel);
			var buffer = new QRBitBuffer();
			for (var i = 0; i < dataList.length; i++) {
				var data = dataList[i];
				buffer.put(data.mode, 4);
				buffer.put(data.getLength(), QRUtil.getLengthInBits(data.mode, typeNumber));
				data.write(buffer);
			}
			var totalDataCount = 0;
			for (var i = 0; i < rsBlocks.length; i++) {
				totalDataCount += rsBlocks[i].dataCount;
			}
			if (buffer.getLengthInBits() > totalDataCount * 8) {
				throw new Error("code length overflow. (" + buffer.getLengthInBits() + ">" + totalDataCount * 8 + ")");
			}
			if (buffer.getLengthInBits() + 4 <= totalDataCount * 8) {
				buffer.put(0, 4);
			}
			while (buffer.getLengthInBits() % 8 != 0) {
				buffer.putBit(false);
			}
			while (true) {
				if (buffer.getLengthInBits() >= totalDataCount * 8) {
					break;
				}
				buffer.put(QRCodeModel.PAD0, 8);
				if (buffer.getLengthInBits() >= totalDataCount * 8) {
					break;
				}
				buffer.put(QRCodeModel.PAD1, 8);
			}
			return QRCodeModel.createBytes(buffer, rsBlocks);
		};
		QRCodeModel.createBytes = function (buffer, rsBlocks) {
			var offset = 0;
			var maxDcCount = 0;
			var maxEcCount = 0;
			var dcdata = new Array(rsBlocks.length);
			var ecdata = new Array(rsBlocks.length);
			for (var r = 0; r < rsBlocks.length; r++) {
				var dcCount = rsBlocks[r].dataCount;
				var ecCount = rsBlocks[r].totalCount - dcCount;
				maxDcCount = Math.max(maxDcCount, dcCount);
				maxEcCount = Math.max(maxEcCount, ecCount);
				dcdata[r] = new Array(dcCount);
				for (var i = 0; i < dcdata[r].length; i++) {
					dcdata[r][i] = 0xff & buffer.buffer[i + offset];
				}
				offset += dcCount;
				var rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount);
				var rawPoly = new QRPolynomial(dcdata[r], rsPoly.getLength() - 1);
				var modPoly = rawPoly.mod(rsPoly);
				ecdata[r] = new Array(rsPoly.getLength() - 1);
				for (var i = 0; i < ecdata[r].length; i++) {
					var modIndex = i + modPoly.getLength() - ecdata[r].length;
					ecdata[r][i] = (modIndex >= 0) ? modPoly.get(modIndex) : 0;
				}
			}
			var totalCodeCount = 0;
			for (var i = 0; i < rsBlocks.length; i++) {
				totalCodeCount += rsBlocks[i].totalCount;
			}
			var data = new Array(totalCodeCount);
			var index = 0;
			for (var i = 0; i < maxDcCount; i++) {
				for (var r = 0; r < rsBlocks.length; r++) {
					if (i < dcdata[r].length) {
						data[index++] = dcdata[r][i];
					}
				}
			}
			for (var i = 0; i < maxEcCount; i++) {
				for (var r = 0; r < rsBlocks.length; r++) {
					if (i < ecdata[r].length) {
						data[index++] = ecdata[r][i];
					}
				}
			}
			return data;
		};
		var QRMode = {
			MODE_NUMBER: 1 << 0,
			MODE_ALPHA_NUM: 1 << 1,
			MODE_8BIT_BYTE: 1 << 2,
			MODE_KANJI: 1 << 3
		};
		var QRErrorCorrectLevel = {
			L: 1,
			M: 0,
			Q: 3,
			H: 2
		};
		var QRMaskPattern = {
			PATTERN000: 0,
			PATTERN001: 1,
			PATTERN010: 2,
			PATTERN011: 3,
			PATTERN100: 4,
			PATTERN101: 5,
			PATTERN110: 6,
			PATTERN111: 7
		};
		var QRUtil = {
			PATTERN_POSITION_TABLE: [
				[],
				[6, 18],
				[6, 22],
				[6, 26],
				[6, 30],
				[6, 34],
				[6, 22, 38],
				[6, 24, 42],
				[6, 26, 46],
				[6, 28, 50],
				[6, 30, 54],
				[6, 32, 58],
				[6, 34, 62],
				[6, 26, 46, 66],
				[6, 26, 48, 70],
				[6, 26, 50, 74],
				[6, 30, 54, 78],
				[6, 30, 56, 82],
				[6, 30, 58, 86],
				[6, 34, 62, 90],
				[6, 28, 50, 72, 94],
				[6, 26, 50, 74, 98],
				[6, 30, 54, 78, 102],
				[6, 28, 54, 80, 106],
				[6, 32, 58, 84, 110],
				[6, 30, 58, 86, 114],
				[6, 34, 62, 90, 118],
				[6, 26, 50, 74, 98, 122],
				[6, 30, 54, 78, 102, 126],
				[6, 26, 52, 78, 104, 130],
				[6, 30, 56, 82, 108, 134],
				[6, 34, 60, 86, 112, 138],
				[6, 30, 58, 86, 114, 142],
				[6, 34, 62, 90, 118, 146],
				[6, 30, 54, 78, 102, 126, 150],
				[6, 24, 50, 76, 102, 128, 154],
				[6, 28, 54, 80, 106, 132, 158],
				[6, 32, 58, 84, 110, 136, 162],
				[6, 26, 54, 82, 110, 138, 166],
				[6, 30, 58, 86, 114, 142, 170]
			],
			G15: (1 << 10) | (1 << 8) | (1 << 5) | (1 << 4) | (1 << 2) | (1 << 1) | (1 << 0),
			G18: (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0),
			G15_MASK: (1 << 14) | (1 << 12) | (1 << 10) | (1 << 4) | (1 << 1),
			getBCHTypeInfo: function (data) {
				var d = data << 10;
				while (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15) >= 0) {
					d ^= (QRUtil.G15 << (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15)));
				}
				return ((data << 10) | d) ^ QRUtil.G15_MASK;
			},
			getBCHTypeNumber: function (data) {
				var d = data << 12;
				while (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G18) >= 0) {
					d ^= (QRUtil.G18 << (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G18)));
				}
				return (data << 12) | d;
			},
			getBCHDigit: function (data) {
				var digit = 0;
				while (data != 0) {
					digit++;
					data >>>= 1;
				}
				return digit;
			},
			getPatternPosition: function (typeNumber) {
				return QRUtil.PATTERN_POSITION_TABLE[typeNumber - 1];
			},
			getMask: function (maskPattern, i, j) {
				switch (maskPattern) {
				case QRMaskPattern.PATTERN000:
					return (i + j) % 2 == 0;
				case QRMaskPattern.PATTERN001:
					return i % 2 == 0;
				case QRMaskPattern.PATTERN010:
					return j % 3 == 0;
				case QRMaskPattern.PATTERN011:
					return (i + j) % 3 == 0;
				case QRMaskPattern.PATTERN100:
					return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 == 0;
				case QRMaskPattern.PATTERN101:
					return (i * j) % 2 + (i * j) % 3 == 0;
				case QRMaskPattern.PATTERN110:
					return ((i * j) % 2 + (i * j) % 3) % 2 == 0;
				case QRMaskPattern.PATTERN111:
					return ((i * j) % 3 + (i + j) % 2) % 2 == 0;
				default:
					throw new Error("bad maskPattern:" + maskPattern);
				}
			},
			getErrorCorrectPolynomial: function (errorCorrectLength) {
				var a = new QRPolynomial([1], 0);
				for (var i = 0; i < errorCorrectLength; i++) {
					a = a.multiply(new QRPolynomial([1, QRMath.gexp(i)], 0));
				}
				return a;
			},
			getLengthInBits: function (mode, type) {
				if (1 <= type && type < 10) {
					switch (mode) {
					case QRMode.MODE_NUMBER:
						return 10;
					case QRMode.MODE_ALPHA_NUM:
						return 9;
					case QRMode.MODE_8BIT_BYTE:
						return 8;
					case QRMode.MODE_KANJI:
						return 8;
					default:
						throw new Error("mode:" + mode);
					}
				} else if (type < 27) {
					switch (mode) {
					case QRMode.MODE_NUMBER:
						return 12;
					case QRMode.MODE_ALPHA_NUM:
						return 11;
					case QRMode.MODE_8BIT_BYTE:
						return 16;
					case QRMode.MODE_KANJI:
						return 10;
					default:
						throw new Error("mode:" + mode);
					}
				} else if (type < 41) {
					switch (mode) {
					case QRMode.MODE_NUMBER:
						return 14;
					case QRMode.MODE_ALPHA_NUM:
						return 13;
					case QRMode.MODE_8BIT_BYTE:
						return 16;
					case QRMode.MODE_KANJI:
						return 12;
					default:
						throw new Error("mode:" + mode);
					}
				} else {
					throw new Error("type:" + type);
				}
			},
			getLostPoint: function (qrCode) {
				var moduleCount = qrCode.getModuleCount();
				var lostPoint = 0;
				for (var row = 0; row < moduleCount; row++) {
					for (var col = 0; col < moduleCount; col++) {
						var sameCount = 0;
						var dark = qrCode.isDark(row, col);
						for (var r = -1; r <= 1; r++) {
							if (row + r < 0 || moduleCount <= row + r) {
								continue;
							}
							for (var c = -1; c <= 1; c++) {
								if (col + c < 0 || moduleCount <= col + c) {
									continue;
								}
								if (r == 0 && c == 0) {
									continue;
								}
								if (dark == qrCode.isDark(row + r, col + c)) {
									sameCount++;
								}
							}
						}
						if (sameCount > 5) {
							lostPoint += (3 + sameCount - 5);
						}
					}
				}
				for (var row = 0; row < moduleCount - 1; row++) {
					for (var col = 0; col < moduleCount - 1; col++) {
						var count = 0;
						if (qrCode.isDark(row, col)) count++;
						if (qrCode.isDark(row + 1, col)) count++;
						if (qrCode.isDark(row, col + 1)) count++;
						if (qrCode.isDark(row + 1, col + 1)) count++;
						if (count == 0 || count == 4) {
							lostPoint += 3;
						}
					}
				}
				for (var row = 0; row < moduleCount; row++) {
					for (var col = 0; col < moduleCount - 6; col++) {
						if (qrCode.isDark(row, col) && !qrCode.isDark(row, col + 1) && qrCode.isDark(row, col + 2) && qrCode.isDark(row, col + 3) && qrCode.isDark(row, col + 4) && !qrCode.isDark(row, col + 5) && qrCode.isDark(row, col + 6)) {
							lostPoint += 40;
						}
					}
				}
				for (var col = 0; col < moduleCount; col++) {
					for (var row = 0; row < moduleCount - 6; row++) {
						if (qrCode.isDark(row, col) && !qrCode.isDark(row + 1, col) && qrCode.isDark(row + 2, col) && qrCode.isDark(row + 3, col) && qrCode.isDark(row + 4, col) && !qrCode.isDark(row + 5, col) && qrCode.isDark(row + 6, col)) {
							lostPoint += 40;
						}
					}
				}
				var darkCount = 0;
				for (var col = 0; col < moduleCount; col++) {
					for (var row = 0; row < moduleCount; row++) {
						if (qrCode.isDark(row, col)) {
							darkCount++;
						}
					}
				}
				var ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;
				lostPoint += ratio * 10;
				return lostPoint;
			}
		};
		var QRMath = {
			glog: function (n) {
				if (n < 1) {
					throw new Error("glog(" + n + ")");
				}
				return QRMath.LOG_TABLE[n];
			},
			gexp: function (n) {
				while (n < 0) {
					n += 255;
				}
				while (n >= 256) {
					n -= 255;
				}
				return QRMath.EXP_TABLE[n];
			},
			EXP_TABLE: new Array(256),
			LOG_TABLE: new Array(256)
		};
		for (var i = 0; i < 8; i++) {
			QRMath.EXP_TABLE[i] = 1 << i;
		}
		for (var i = 8; i < 256; i++) {
			QRMath.EXP_TABLE[i] = QRMath.EXP_TABLE[i - 4] ^ QRMath.EXP_TABLE[i - 5] ^ QRMath.EXP_TABLE[i - 6] ^ QRMath.EXP_TABLE[i - 8];
		}
		for (var i = 0; i < 255; i++) {
			QRMath.LOG_TABLE[QRMath.EXP_TABLE[i]] = i;
		}

		function QRPolynomial(num, shift) {
			if (num.length == undefined) {
				throw new Error(num.length + "/" + shift);
			}
			var offset = 0;
			while (offset < num.length && num[offset] == 0) {
				offset++;
			}
			this.num = new Array(num.length - offset + shift);
			for (var i = 0; i < num.length - offset; i++) {
				this.num[i] = num[i + offset];
			}
		}
		QRPolynomial.prototype = {
			get: function (index) {
				return this.num[index];
			},
			getLength: function () {
				return this.num.length;
			},
			multiply: function (e) {
				var num = new Array(this.getLength() + e.getLength() - 1);
				for (var i = 0; i < this.getLength(); i++) {
					for (var j = 0; j < e.getLength(); j++) {
						num[i + j] ^= QRMath.gexp(QRMath.glog(this.get(i)) + QRMath.glog(e.get(j)));
					}
				}
				return new QRPolynomial(num, 0);
			},
			mod: function (e) {
				if (this.getLength() - e.getLength() < 0) {
					return this;
				}
				var ratio = QRMath.glog(this.get(0)) - QRMath.glog(e.get(0));
				var num = new Array(this.getLength());
				for (var i = 0; i < this.getLength(); i++) {
					num[i] = this.get(i);
				}
				for (var i = 0; i < e.getLength(); i++) {
					num[i] ^= QRMath.gexp(QRMath.glog(e.get(i)) + ratio);
				}
				return new QRPolynomial(num, 0).mod(e);
			}
		};

		function QRRSBlock(totalCount, dataCount) {
			this.totalCount = totalCount;
			this.dataCount = dataCount;
		}
		QRRSBlock.RS_BLOCK_TABLE = [
			[1, 26, 19],
			[1, 26, 16],
			[1, 26, 13],
			[1, 26, 9],
			[1, 44, 34],
			[1, 44, 28],
			[1, 44, 22],
			[1, 44, 16],
			[1, 70, 55],
			[1, 70, 44],
			[2, 35, 17],
			[2, 35, 13],
			[1, 100, 80],
			[2, 50, 32],
			[2, 50, 24],
			[4, 25, 9],
			[1, 134, 108],
			[2, 67, 43],
			[2, 33, 15, 2, 34, 16],
			[2, 33, 11, 2, 34, 12],
			[2, 86, 68],
			[4, 43, 27],
			[4, 43, 19],
			[4, 43, 15],
			[2, 98, 78],
			[4, 49, 31],
			[2, 32, 14, 4, 33, 15],
			[4, 39, 13, 1, 40, 14],
			[2, 121, 97],
			[2, 60, 38, 2, 61, 39],
			[4, 40, 18, 2, 41, 19],
			[4, 40, 14, 2, 41, 15],
			[2, 146, 116],
			[3, 58, 36, 2, 59, 37],
			[4, 36, 16, 4, 37, 17],
			[4, 36, 12, 4, 37, 13],
			[2, 86, 68, 2, 87, 69],
			[4, 69, 43, 1, 70, 44],
			[6, 43, 19, 2, 44, 20],
			[6, 43, 15, 2, 44, 16],
			[4, 101, 81],
			[1, 80, 50, 4, 81, 51],
			[4, 50, 22, 4, 51, 23],
			[3, 36, 12, 8, 37, 13],
			[2, 116, 92, 2, 117, 93],
			[6, 58, 36, 2, 59, 37],
			[4, 46, 20, 6, 47, 21],
			[7, 42, 14, 4, 43, 15],
			[4, 133, 107],
			[8, 59, 37, 1, 60, 38],
			[8, 44, 20, 4, 45, 21],
			[12, 33, 11, 4, 34, 12],
			[3, 145, 115, 1, 146, 116],
			[4, 64, 40, 5, 65, 41],
			[11, 36, 16, 5, 37, 17],
			[11, 36, 12, 5, 37, 13],
			[5, 109, 87, 1, 110, 88],
			[5, 65, 41, 5, 66, 42],
			[5, 54, 24, 7, 55, 25],
			[11, 36, 12],
			[5, 122, 98, 1, 123, 99],
			[7, 73, 45, 3, 74, 46],
			[15, 43, 19, 2, 44, 20],
			[3, 45, 15, 13, 46, 16],
			[1, 135, 107, 5, 136, 108],
			[10, 74, 46, 1, 75, 47],
			[1, 50, 22, 15, 51, 23],
			[2, 42, 14, 17, 43, 15],
			[5, 150, 120, 1, 151, 121],
			[9, 69, 43, 4, 70, 44],
			[17, 50, 22, 1, 51, 23],
			[2, 42, 14, 19, 43, 15],
			[3, 141, 113, 4, 142, 114],
			[3, 70, 44, 11, 71, 45],
			[17, 47, 21, 4, 48, 22],
			[9, 39, 13, 16, 40, 14],
			[3, 135, 107, 5, 136, 108],
			[3, 67, 41, 13, 68, 42],
			[15, 54, 24, 5, 55, 25],
			[15, 43, 15, 10, 44, 16],
			[4, 144, 116, 4, 145, 117],
			[17, 68, 42],
			[17, 50, 22, 6, 51, 23],
			[19, 46, 16, 6, 47, 17],
			[2, 139, 111, 7, 140, 112],
			[17, 74, 46],
			[7, 54, 24, 16, 55, 25],
			[34, 37, 13],
			[4, 151, 121, 5, 152, 122],
			[4, 75, 47, 14, 76, 48],
			[11, 54, 24, 14, 55, 25],
			[16, 45, 15, 14, 46, 16],
			[6, 147, 117, 4, 148, 118],
			[6, 73, 45, 14, 74, 46],
			[11, 54, 24, 16, 55, 25],
			[30, 46, 16, 2, 47, 17],
			[8, 132, 106, 4, 133, 107],
			[8, 75, 47, 13, 76, 48],
			[7, 54, 24, 22, 55, 25],
			[22, 45, 15, 13, 46, 16],
			[10, 142, 114, 2, 143, 115],
			[19, 74, 46, 4, 75, 47],
			[28, 50, 22, 6, 51, 23],
			[33, 46, 16, 4, 47, 17],
			[8, 152, 122, 4, 153, 123],
			[22, 73, 45, 3, 74, 46],
			[8, 53, 23, 26, 54, 24],
			[12, 45, 15, 28, 46, 16],
			[3, 147, 117, 10, 148, 118],
			[3, 73, 45, 23, 74, 46],
			[4, 54, 24, 31, 55, 25],
			[11, 45, 15, 31, 46, 16],
			[7, 146, 116, 7, 147, 117],
			[21, 73, 45, 7, 74, 46],
			[1, 53, 23, 37, 54, 24],
			[19, 45, 15, 26, 46, 16],
			[5, 145, 115, 10, 146, 116],
			[19, 75, 47, 10, 76, 48],
			[15, 54, 24, 25, 55, 25],
			[23, 45, 15, 25, 46, 16],
			[13, 145, 115, 3, 146, 116],
			[2, 74, 46, 29, 75, 47],
			[42, 54, 24, 1, 55, 25],
			[23, 45, 15, 28, 46, 16],
			[17, 145, 115],
			[10, 74, 46, 23, 75, 47],
			[10, 54, 24, 35, 55, 25],
			[19, 45, 15, 35, 46, 16],
			[17, 145, 115, 1, 146, 116],
			[14, 74, 46, 21, 75, 47],
			[29, 54, 24, 19, 55, 25],
			[11, 45, 15, 46, 46, 16],
			[13, 145, 115, 6, 146, 116],
			[14, 74, 46, 23, 75, 47],
			[44, 54, 24, 7, 55, 25],
			[59, 46, 16, 1, 47, 17],
			[12, 151, 121, 7, 152, 122],
			[12, 75, 47, 26, 76, 48],
			[39, 54, 24, 14, 55, 25],
			[22, 45, 15, 41, 46, 16],
			[6, 151, 121, 14, 152, 122],
			[6, 75, 47, 34, 76, 48],
			[46, 54, 24, 10, 55, 25],
			[2, 45, 15, 64, 46, 16],
			[17, 152, 122, 4, 153, 123],
			[29, 74, 46, 14, 75, 47],
			[49, 54, 24, 10, 55, 25],
			[24, 45, 15, 46, 46, 16],
			[4, 152, 122, 18, 153, 123],
			[13, 74, 46, 32, 75, 47],
			[48, 54, 24, 14, 55, 25],
			[42, 45, 15, 32, 46, 16],
			[20, 147, 117, 4, 148, 118],
			[40, 75, 47, 7, 76, 48],
			[43, 54, 24, 22, 55, 25],
			[10, 45, 15, 67, 46, 16],
			[19, 148, 118, 6, 149, 119],
			[18, 75, 47, 31, 76, 48],
			[34, 54, 24, 34, 55, 25],
			[20, 45, 15, 61, 46, 16]
		];
		QRRSBlock.getRSBlocks = function (typeNumber, errorCorrectLevel) {
			var rsBlock = QRRSBlock.getRsBlockTable(typeNumber, errorCorrectLevel);
			if (rsBlock == undefined) {
				throw new Error("bad rs block @ typeNumber:" + typeNumber + "/errorCorrectLevel:" + errorCorrectLevel);
			}
			var length = rsBlock.length / 3;
			var list = [];
			for (var i = 0; i < length; i++) {
				var count = rsBlock[i * 3 + 0];
				var totalCount = rsBlock[i * 3 + 1];
				var dataCount = rsBlock[i * 3 + 2];
				for (var j = 0; j < count; j++) {
					list.push(new QRRSBlock(totalCount, dataCount));
				}
			}
			return list;
		};
		QRRSBlock.getRsBlockTable = function (typeNumber, errorCorrectLevel) {
			switch (errorCorrectLevel) {
			case QRErrorCorrectLevel.L:
				return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];
			case QRErrorCorrectLevel.M:
				return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];
			case QRErrorCorrectLevel.Q:
				return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];
			case QRErrorCorrectLevel.H:
				return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];
			default:
				return undefined;
			}
		};

		function QRBitBuffer() {
			this.buffer = [];
			this.length = 0;
		}
		QRBitBuffer.prototype = {
			get: function (index) {
				var bufIndex = Math.floor(index / 8);
				return ((this.buffer[bufIndex] >>> (7 - index % 8)) & 1) == 1;
			},
			put: function (num, length) {
				for (var i = 0; i < length; i++) {
					this.putBit(((num >>> (length - i - 1)) & 1) == 1);
				}
			},
			getLengthInBits: function () {
				return this.length;
			},
			putBit: function (bit) {
				var bufIndex = Math.floor(this.length / 8);
				if (this.buffer.length <= bufIndex) {
					this.buffer.push(0);
				}
				if (bit) {
					this.buffer[bufIndex] |= (0x80 >>> (this.length % 8));
				}
				this.length++;
			}
		};
		var QRCodeLimitLength = [
			[17, 14, 11, 7],
			[32, 26, 20, 14],
			[53, 42, 32, 24],
			[78, 62, 46, 34],
			[106, 84, 60, 44],
			[134, 106, 74, 58],
			[154, 122, 86, 64],
			[192, 152, 108, 84],
			[230, 180, 130, 98],
			[271, 213, 151, 119],
			[321, 251, 177, 137],
			[367, 287, 203, 155],
			[425, 331, 241, 177],
			[458, 362, 258, 194],
			[520, 412, 292, 220],
			[586, 450, 322, 250],
			[644, 504, 364, 280],
			[718, 560, 394, 310],
			[792, 624, 442, 338],
			[858, 666, 482, 382],
			[929, 711, 509, 403],
			[1003, 779, 565, 439],
			[1091, 857, 611, 461],
			[1171, 911, 661, 511],
			[1273, 997, 715, 535],
			[1367, 1059, 751, 593],
			[1465, 1125, 805, 625],
			[1528, 1190, 868, 658],
			[1628, 1264, 908, 698],
			[1732, 1370, 982, 742],
			[1840, 1452, 1030, 790],
			[1952, 1538, 1112, 842],
			[2068, 1628, 1168, 898],
			[2188, 1722, 1228, 958],
			[2303, 1809, 1283, 983],
			[2431, 1911, 1351, 1051],
			[2563, 1989, 1423, 1093],
			[2699, 2099, 1499, 1139],
			[2809, 2213, 1579, 1219],
			[2953, 2331, 1663, 1273]
		];
	
	function _isSupportCanvas() {
		return typeof CanvasRenderingContext2D != "undefined";
	}
	
	// android 2.x doesn't support Data-URI spec
	function _getAndroid() {
		var android = false;
		var sAgent = navigator.userAgent;
		
		if (/android/i.test(sAgent)) { // android
			android = true;
			aMat = sAgent.toString().match(/android ([0-9]\.[0-9])/i);
			
			if (aMat && aMat[1]) {
				android = parseFloat(aMat[1]);
			}
		}
		
		return android;
	}
	
	// Drawing in DOM by using Table tag
	var Drawing = !_isSupportCanvas() ? (function () {
		var _el = null;
		var _htOption = null;
		
		var Drawing = function (el, htOption) {
			_el = el;
			_htOption = htOption;
		};
			
		/**
		 * Draw the QRCode
		 * 
		 * @param {QRCode} oQRCode
		 */
		Drawing.prototype.draw = function (oQRCode) {
			var nCount = oQRCode.getModuleCount();
			var nWidth = Math.floor(_htOption.width / nCount);
			var nHeight = Math.floor(_htOption.height / nCount);
			var aHTML = ['<table style="border:0;border-collapse:collapse;">'];
			
			for (var row = 0; row < nCount; row++) {
				aHTML.push('<tr>');
				
				for (var col = 0; col < nCount; col++) {
					aHTML.push('<td style="border:0;border-collapse:collapse;padding:0;margin:0;width:' + nWidth + 'px;height:' + nHeight + 'px;background-color:' + (oQRCode.isDark(row, col) ? _htOption.colorDark : _htOption.colorLight) + ';"></td>');
				}
				
				aHTML.push('</tr>');
			}
			
			aHTML.push('</table>');
			_el.innerHTML = aHTML.join('');
			
			// Fix the margin values as real size.
			var elTable = _el.childNodes[0];
			var nLeftMarginTable = (_htOption.width - elTable.offsetWidth) / 2;
			var nTopMarginTable = (_htOption.height - elTable.offsetHeight) / 2;
			
			if (nLeftMarginTable > 0 && nTopMarginTable > 0) {
				elTable.style.margin = nTopMarginTable + "px " + nLeftMarginTable + "px";	
			}
		};
		
		/**
		 * Clear the QRCode
		 */
		Drawing.prototype.clear = function () {
			_el.innerHTML = '';
		};
		
		return Drawing;
	})() : (function () { // Drawing in Canvas
		var _el = null;
		var _elCanvas = null;
		var _elImage = null;
		var _fFail = null;
		var _fSuccess = null;
		var _htOption = null;
		var _bSupportDataURI = null;
		var _oContext = null;
		var _bIsPainted = false;
		var _android = _getAndroid();
		
		function _onMakeImage() {
			_elImage.src = _elCanvas.toDataURL("image/png");
			_elImage.style.display = "block";
			_elCanvas.style.display = "none";			
		}
		
		// Android 2.1 bug workaround
		// http://code.google.com/p/android/issues/detail?id=5141
		if (_android && _android <= 2.1) {
	    	var factor = 1 / window.devicePixelRatio;
	        var drawImage = CanvasRenderingContext2D.prototype.drawImage; 
	    	CanvasRenderingContext2D.prototype.drawImage = function (image, sx, sy, sw, sh, dx, dy, dw, dh) {
	    		if (("nodeName" in image) && /img/i.test(image.nodeName)) {
		        	for (var i = arguments.length - 1; i >= 1; i--) {
		            	arguments[i] = arguments[i] * factor;
		        	}
	    		} else if (typeof dw == "undefined") {
	    			arguments[1] *= factor;
	    			arguments[2] *= factor;
	    			arguments[3] *= factor;
	    			arguments[4] *= factor;
	    		}
	    		
	        	drawImage.apply(this, arguments); 
	    	};
		}
		
		/**
		 * Check whether the user's browser supports Data URI or not
		 * 
		 * @private
		 * @param {Function} fSuccess Occurs if it supports Data URI
		 * @param {Function} fFail Occurs if it doesn't support Data URI
		 */
		function _safeSetDataURI(fSuccess, fFail) {
			_fFail = fFail;
			_fSuccess = fSuccess;
	
			// Check it just once
			if (_bSupportDataURI === null) {
				var el = document.createElement("img");
				var fOnError = function () {
					_bSupportDataURI = false;
					
					if (_fFail) {
						_fFail();	
					}					
				};
				var fOnSuccess = function () {
					_bSupportDataURI = true;
					
					if (_fSuccess) {
						_fSuccess();
					}
				};
				
				el.onabort = fOnError;
				el.onerror = fOnError;
				el.onload = fOnSuccess;
				el.src = "data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg=="; // the Image contains 1px data.
				return;
			} else if (_bSupportDataURI === true && _fSuccess) {
				_fSuccess();
			} else if (_bSupportDataURI === false && _fFail) {
				_fFail();
			}
		};
		
		/**
		 * Drawing QRCode by using canvas
		 * 
		 * @constructor
		 * @param {HTMLElement} el
		 * @param {Object} htOption QRCode Options 
		 */
		var Drawing = function (el, htOption) {
			_htOption = htOption;
			_elCanvas = document.createElement("canvas");
			_elCanvas.width = htOption.width;
			_elCanvas.height = htOption.height;
			el.appendChild(_elCanvas);
			_el = el;
			_oContext = _elCanvas.getContext("2d");
			_bIsPainted = false;
			_elImage = document.createElement("img");
			_elImage.style.display = "none";
			_el.appendChild(_elImage);
			_bSupportDataURI = null;
		};
			
		/**
		 * Draw the QRCode
		 * 
		 * @param {QRCode} oQRCode 
		 */
		Drawing.prototype.draw = function (oQRCode) {
			_elImage.style.display = "none";
			var nCount = oQRCode.getModuleCount();
			var nWidth = _htOption.width / nCount;
			var nHeight = _htOption.height / nCount;
			var nRoundedWidth = Math.round(nWidth);
			var nRoundedHeight = Math.round(nHeight);
			this.clear();
			
			for (var row = 0; row < nCount; row++) {
				for (var col = 0; col < nCount; col++) {
					var bIsDark = oQRCode.isDark(row, col);
					var nLeft = col * nWidth;
					var nTop = row * nHeight;
					_oContext.strokeStyle = bIsDark ? _htOption.colorDark : _htOption.colorLight;
					_oContext.lineWidth = 1;
					_oContext.fillStyle = bIsDark ? _htOption.colorDark : _htOption.colorLight;					
					_oContext.fillRect(nLeft, nTop, nWidth, nHeight);
					
					//resistant anti-aliasing
					_oContext.strokeRect(
						Math.floor(nLeft) + 0.5,
						Math.floor(nTop) + 0.5,
						nRoundedWidth,
						nRoundedHeight
					);
					
					_oContext.strokeRect(
						Math.ceil(nLeft) - 0.5,
						Math.ceil(nTop) - 0.5,
						nRoundedWidth,
						nRoundedHeight
					);
				}
			}
			
			_bIsPainted = true;
		};
			
		/**
		 * Make the image from Canvas if the browser supports Data URI.
		 */
		Drawing.prototype.makeImage = function () {
			if (_bIsPainted) {
				_safeSetDataURI(_onMakeImage);
			}
		};
			
		/**
		 * Return whether the QRCode is painted or not
		 * 
		 * @return {Boolean}
		 */
		Drawing.prototype.isPainted = function () {
			return _bIsPainted;
		};
		
		/**
		 * Clear the QRCode
		 */
		Drawing.prototype.clear = function () {
			_oContext.clearRect(0, 0, _elCanvas.width, _elCanvas.height);
			_bIsPainted = false;
		};
		
		/**
		 * @private
		 * @param {Number} nNumber
		 */
		Drawing.prototype.round = function (nNumber) {
			if (!nNumber) {
				return nNumber;
			}
			
			return Math.floor(nNumber * 1000) / 1000;
		};
		
		return Drawing;
	})();
	
	/**
	 * Get the type by string length
	 * 
	 * @private
	 * @param {String} sText
	 * @param {Number} nCorrectLevel
	 * @return {Number} type
	 */
	function _getTypeNumber(sText, nCorrectLevel) {			
		var nType = 1;
		
		for (var i = 0, len = QRCodeLimitLength.length; i <= len; i++) {
			var nLimit = 0;
			
			switch (nCorrectLevel) {
				case QRErrorCorrectLevel.L :
					nLimit = QRCodeLimitLength[i][0];
					break;
				case QRErrorCorrectLevel.M :
					nLimit = QRCodeLimitLength[i][1];
					break;
				case QRErrorCorrectLevel.Q :
					nLimit = QRCodeLimitLength[i][2];
					break;
				case QRErrorCorrectLevel.H :
					nLimit = QRCodeLimitLength[i][3];
					break;
			}
			
			if (sText.length <= nLimit) {
				break;
			} else {
				nType++;
			}
		}
		
		if (nType > QRCodeLimitLength.length) {
			throw new Error("Too long data");
		}
		
		return nType;
	}
	
	/**
	 * @class QRCode
	 * @constructor
	 * @example 
	 * new QRCode(document.getElementById("test"), "http://jindo.dev.naver.com/collie");
	 *
	 * @example
	 * var oQRCode = new QRCode("test", {
	 *    text : "http://naver.com",
	 *    width : 128,
	 *    height : 128
	 * });
	 * 
	 * oQRCode.clear(); // Clear the QRCode.
	 * oQRCode.makeCode("http://map.naver.com"); // Re-create the QRCode.
	 *
	 * @param {HTMLElement|String} el target element or 'id' attribute of element.
	 * @param {Object|String} vOption
	 * @param {String} vOption.text QRCode link data
	 * @param {Number} [vOption.width=256]
	 * @param {Number} [vOption.height=256]
	 * @param {String} [vOption.colorDark="#000000"]
	 * @param {String} [vOption.colorLight="#ffffff"]
	 * @param {QRCode.CorrectLevel} [vOption.correctLevel=QRCode.CorrectLevel.H] [L|M|Q|H] 
	 */
	QRCode = function (el, vOption) {
		this._htOption = {
			width : 256, 
			height : 256,
			typeNumber : 4,
			colorDark : "#000000",
			colorLight : "#ffffff",
			correctLevel : QRErrorCorrectLevel.H
		};
		
		if (typeof vOption === 'string') {
			vOption	= {
				text : vOption
			};
		}
		
		// Overwrites options
		if (vOption) {
			for (var i in vOption) {
				this._htOption[i] = vOption[i];
			}
		}
		
		if (typeof el == "string") {
			el = document.getElementById(el);
		}
		
		this._android = _getAndroid();
		this._el = el;
		this._oQRCode = null;
		this._oDrawing = new Drawing(this._el, this._htOption);
		
		if (this._htOption.text) {
			this.makeCode(this._htOption.text);	
		}
	};
	
	/**
	 * Make the QRCode
	 * 
	 * @param {String} sText link data
	 */
	QRCode.prototype.makeCode = function (sText) {
		this._oQRCode = new QRCodeModel(_getTypeNumber(sText, this._htOption.correctLevel), this._htOption.correctLevel);
		this._oQRCode.addData(sText);
		this._oQRCode.make();
		this._el.title = sText;
		this._oDrawing.draw(this._oQRCode);			
		this.makeImage();
	};
	
	/**
	 * Make the Image from Canvas element
	 * - It occurs automatically
	 * - Android below 3 doesn't support Data-URI spec.
	 * 
	 * @private
	 */
	QRCode.prototype.makeImage = function () {
		if (typeof this._oDrawing.makeImage == "function" && (!this._android || this._android >= 3)) {
			this._oDrawing.makeImage();
		}
	};
	
	/**
	 * Clear the QRCode
	 */
	QRCode.prototype.clear = function () {
		this._oDrawing.clear();
	};
	
	/**
	 * @name QRCode.CorrectLevel
	 */
	QRCode.CorrectLevel = QRErrorCorrectLevel;
})();

//end of qrcode.js
  
//SJCL.js begins

"use strict";
var sjcl = {
    cipher: {},
    hash: {},
    keyexchange: {},
    mode: {},
    misc: {},
    codec: {},
    exception: {
	corrupt: function (a) {
	    this.toString = function () {
		return "CORRUPT: " + this.message
	    };
	    this.message = a
	},
	invalid: function (a) {
	    this.toString = function () {
		return "INVALID: " + this.message
	    };
	    this.message = a
	},
	bug: function (a) {
	    this.toString = function () {
		return "BUG: " + this.message
	    };
	    this.message = a
	},
	notReady: function (a) {
	    this.toString = function () {
		return "NOT READY: " + this.message
	    };
	    this.message = a
	}
    }
};
if (typeof module != "undefined" && module.exports) module.exports = sjcl;
sjcl.cipher.aes = function (a) {
    this.h[0][0][0] || this.z();
    var b, c, d, e, f = this.h[0][4],
	g = this.h[1];
    b = a.length;
    var h = 1;
    if (b !== 4 && b !== 6 && b !== 8) throw new sjcl.exception.invalid("invalid aes key size");
    this.a = [d = a.slice(0), e = []];
    for (a = b; a < 4 * b + 28; a++) {
	c = d[a - 1];
	if (a % b === 0 || b === 8 && a % b === 4) {
	    c = f[c >>> 24] << 24 ^ f[c >> 16 & 255] << 16 ^ f[c >> 8 & 255] << 8 ^ f[c & 255];
	    if (a % b === 0) {
		c = c << 8 ^ c >>> 24 ^ h << 24;
		h = h << 1 ^ (h >> 7) * 283
	    }
	}
	d[a] = d[a - b] ^ c
    }
    for (b = 0; a; b++, a--) {
	c = d[b & 3 ? a : a - 4];
	e[b] = a <= 4 || b < 4 ? c : g[0][f[c >>> 24]] ^ g[1][f[c >> 16 & 255]] ^ g[2][f[c >> 8 & 255]] ^ g[3][f[c & 255]]
    }
};
sjcl.cipher.aes.prototype = {
    encrypt: function (a) {
	return this.I(a, 0)
    },
    decrypt: function (a) {
	return this.I(a, 1)
    },
    h: [
	[
	    [],
	    [],
	    [],
	    [],
	    []
	],
	[
	    [],
	    [],
	    [],
	    [],
	    []
	]
    ],
    z: function () {
	var a = this.h[0],
	    b = this.h[1],
	    c = a[4],
	    d = b[4],
	    e, f, g, h = [],
	    i = [],
	    k, j, l, m;
	for (e = 0; e < 0x100; e++) i[(h[e] = e << 1 ^ (e >> 7) * 283) ^ e] = e;
	for (f = g = 0; !c[f]; f ^= k || 1, g = i[g] || 1) {
	    l = g ^ g << 1 ^ g << 2 ^ g << 3 ^ g << 4;
	    l = l >> 8 ^ l & 255 ^ 99;
	    c[f] = l;
	    d[l] = f;
	    j = h[e = h[k = h[f]]];
	    m = j * 0x1010101 ^ e * 0x10001 ^ k * 0x101 ^ f * 0x1010100;
	    j = h[l] * 0x101 ^ l * 0x1010100;
	    for (e = 0; e < 4; e++) {
		a[e][f] = j = j << 24 ^ j >>> 8;
		b[e][l] = m = m << 24 ^ m >>> 8
	    }
	}
	for (e = 0; e < 5; e++) {
	    a[e] = a[e].slice(0);
	    b[e] = b[e].slice(0)
	}
    },
    I: function (a, b) {
	if (a.length !== 4) throw new sjcl.exception.invalid("invalid aes block size");
	var c = this.a[b],
	    d = a[0] ^ c[0],
	    e = a[b ? 3 : 1] ^ c[1],
	    f = a[2] ^ c[2];
	a = a[b ? 1 : 3] ^ c[3];
	var g, h, i, k = c.length / 4 - 2,
	    j, l = 4,
	    m = [0, 0, 0, 0];
	g = this.h[b];
	var n = g[0],
	    o = g[1],
	    p = g[2],
	    q = g[3],
	    r = g[4];
	for (j = 0; j < k; j++) {
	    g = n[d >>> 24] ^ o[e >> 16 & 255] ^ p[f >> 8 & 255] ^ q[a & 255] ^ c[l];
	    h = n[e >>> 24] ^ o[f >> 16 & 255] ^ p[a >> 8 & 255] ^ q[d & 255] ^ c[l + 1];
	    i = n[f >>> 24] ^ o[a >> 16 & 255] ^ p[d >> 8 & 255] ^ q[e & 255] ^ c[l + 2];
	    a = n[a >>> 24] ^ o[d >> 16 & 255] ^ p[e >> 8 & 255] ^ q[f & 255] ^ c[l + 3];
	    l += 4;
	    d = g;
	    e = h;
	    f = i
	}
	for (j = 0; j < 4; j++) {
	    m[b ? 3 & -j : j] = r[d >>> 24] << 24 ^ r[e >> 16 & 255] << 16 ^ r[f >> 8 & 255] << 8 ^ r[a & 255] ^ c[l++];
	    g = d;
	    d = e;
	    e = f;
	    f = a;
	    a = g
	}
	return m
    }
};
sjcl.bitArray = {
    bitSlice: function (a, b, c) {
	a = sjcl.bitArray.P(a.slice(b / 32), 32 - (b & 31)).slice(1);
	return c === undefined ? a : sjcl.bitArray.clamp(a, c - b)
    },
    extract: function (a, b, c) {
	var d = Math.floor(-b - c & 31);
	return ((b + c - 1 ^ b) & -32 ? a[b / 32 | 0] << 32 - d ^ a[b / 32 + 1 | 0] >>> d : a[b / 32 | 0] >>> d) & (1 << c) - 1
    },
    concat: function (a, b) {
	if (a.length === 0 || b.length === 0) return a.concat(b);
	var c = a[a.length - 1],
	    d = sjcl.bitArray.getPartial(c);
	return d === 32 ? a.concat(b) : sjcl.bitArray.P(b, d, c | 0, a.slice(0, a.length - 1))
    },
    bitLength: function (a) {
	var b = a.length;
	if (b === 0) return 0;
	return (b - 1) * 32 + sjcl.bitArray.getPartial(a[b - 1])
    },
    clamp: function (a, b) {
	if (a.length * 32 < b) return a;
	a = a.slice(0, Math.ceil(b / 32));
	var c = a.length;
	b &= 31;
	if (c > 0 && b) a[c - 1] = sjcl.bitArray.partial(b, a[c - 1] & 2147483648 >> b - 1, 1);
	return a
    },
    partial: function (a, b, c) {
	if (a === 32) return b;
	return (c ? b | 0 : b << 32 - a) + a * 0x10000000000
    },
    getPartial: function (a) {
	return Math.round(a / 0x10000000000) || 32
    },
    equal: function (a, b) {
	if (sjcl.bitArray.bitLength(a) !== sjcl.bitArray.bitLength(b)) return false;
	var c = 0,
	    d;
	for (d = 0; d < a.length; d++) c |= a[d] ^ b[d];
	return c === 0
    },
    P: function (a, b, c, d) {
	var e;
	e = 0;
	if (d === undefined) d = [];
	for (; b >= 32; b -= 32) {
	    d.push(c);
	    c = 0
	}
	if (b === 0) return d.concat(a);
	for (e = 0; e < a.length; e++) {
	    d.push(c | a[e] >>> b);
	    c = a[e] << 32 - b
	}
	e = a.length ? a[a.length - 1] : 0;
	a = sjcl.bitArray.getPartial(e);
	d.push(sjcl.bitArray.partial(b + a & 31, b + a > 32 ? c : d.pop(), 1));
	return d
    },
    k: function (a, b) {
	return [a[0] ^ b[0], a[1] ^ b[1], a[2] ^ b[2], a[3] ^ b[3]]
    }
};
sjcl.codec.utf8String = {
    fromBits: function (a) {
	var b = "",
	    c = sjcl.bitArray.bitLength(a),
	    d, e;
	for (d = 0; d < c / 8; d++) {
	    if ((d & 3) === 0) e = a[d / 4];
	    b += String.fromCharCode(e >>> 24);
	    e <<= 8
	}
	return decodeURIComponent(escape(b))
    },
    toBits: function (a) {
	a = unescape(encodeURIComponent(a));
	var b = [],
	    c, d = 0;
	for (c = 0; c < a.length; c++) {
	    d = d << 8 | a.charCodeAt(c);
	    if ((c & 3) === 3) {
		b.push(d);
		d = 0
	    }
	}
	c & 3 && b.push(sjcl.bitArray.partial(8 * (c & 3), d));
	return b
    }
};
sjcl.codec.hex = {
    fromBits: function (a) {
	var b = "",
	    c;
	for (c = 0; c < a.length; c++) b += ((a[c] | 0) + 0xf00000000000).toString(16).substr(4);
	return b.substr(0, sjcl.bitArray.bitLength(a) / 4)
    },
    toBits: function (a) {
	var b, c = [],
	    d;
	a = a.replace(/\s|0x/g, "");
	d = a.length;
	a += "00000000";
	for (b = 0; b < a.length; b += 8) c.push(parseInt(a.substr(b, 8), 16) ^ 0);
	return sjcl.bitArray.clamp(c, d * 4)
    }
};
sjcl.codec.base64 = {
    F: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    fromBits: function (a, b, c) {
	var d = "",
	    e = 0,
	    f = sjcl.codec.base64.F,
	    g = 0,
	    h = sjcl.bitArray.bitLength(a);
	if (c) f = f.substr(0, 62) + "-_";
	for (c = 0; d.length * 6 < h;) {
	    d += f.charAt((g ^ a[c] >>> e) >>> 26);
	    if (e < 6) {
		g = a[c] << 6 - e;
		e += 26;
		c++
	    } else {
		g <<= 6;
		e -= 6
	    }
	}
	for (; d.length & 3 && !b;) d += "=";
	return d
    },
    toBits: function (a, b) {
	a = a.replace(/\s|=/g, "");
	var c = [],
	    d = 0,
	    e = sjcl.codec.base64.F,
	    f = 0,
	    g;
	if (b) e = e.substr(0, 62) + "-_";
	for (b = 0; b < a.length; b++) {
	    g = e.indexOf(a.charAt(b));
	    if (g < 0) throw new sjcl.exception.invalid("this isn't base64!");
	    if (d > 26) {
		d -= 26;
		c.push(f ^ g >>> d);
		f = g << 32 - d
	    } else {
		d += 6;
		f ^= g << 32 - d
	    }
	}
	d & 56 && c.push(sjcl.bitArray.partial(d & 56, f, 1));
	return c
    }
};
sjcl.codec.base64url = {
    fromBits: function (a) {
	return sjcl.codec.base64.fromBits(a, 1, 1)
    },
    toBits: function (a) {
	return sjcl.codec.base64.toBits(a, 1)
    }
};
sjcl.hash.sha256 = function (a) {
    this.a[0] || this.z();
    if (a) {
	this.n = a.n.slice(0);
	this.i = a.i.slice(0);
	this.e = a.e
    } else this.reset()
};
sjcl.hash.sha256.hash = function (a) {
    return (new sjcl.hash.sha256).update(a).finalize()
};
sjcl.hash.sha256.prototype = {
    blockSize: 512,
    reset: function () {
	this.n = this.N.slice(0);
	this.i = [];
	this.e = 0;
	return this
    },
    update: function (a) {
	if (typeof a === "string") a = sjcl.codec.utf8String.toBits(a);
	var b, c = this.i = sjcl.bitArray.concat(this.i, a);
	b = this.e;
	a = this.e = b + sjcl.bitArray.bitLength(a);
	for (b = 512 + b & -512; b <= a; b += 512) this.D(c.splice(0, 16));
	return this
    },
    finalize: function () {
	var a, b = this.i,
	    c = this.n;
	b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1, 1)]);
	for (a = b.length + 2; a & 15; a++) b.push(0);
	b.push(Math.floor(this.e / 4294967296));
	for (b.push(this.e | 0); b.length;) this.D(b.splice(0, 16));
	this.reset();
	return c
    },
    N: [],
    a: [],
    z: function () {
	function a(e) {
	    return (e - Math.floor(e)) * 0x100000000 | 0
	}
	var b = 0,
	    c = 2,
	    d;
	a: for (; b < 64; c++) {
	    for (d = 2; d * d <= c; d++) if (c % d === 0) continue a;
	    if (b < 8) this.N[b] = a(Math.pow(c, 0.5));
	    this.a[b] = a(Math.pow(c, 1 / 3));
	    b++
	}
    },
    D: function (a) {
	var b, c, d = a.slice(0),
	    e = this.n,
	    f = this.a,
	    g = e[0],
	    h = e[1],
	    i = e[2],
	    k = e[3],
	    j = e[4],
	    l = e[5],
	    m = e[6],
	    n = e[7];
	for (a = 0; a < 64; a++) {
	    if (a < 16) b = d[a];
	    else {
		b = d[a + 1 & 15];
		c = d[a + 14 & 15];
		b = d[a & 15] = (b >>> 7 ^ b >>> 18 ^ b >>> 3 ^ b << 25 ^ b << 14) + (c >>> 17 ^ c >>> 19 ^ c >>> 10 ^ c << 15 ^ c << 13) + d[a & 15] + d[a + 9 & 15] | 0
	    }
	    b = b + n + (j >>> 6 ^ j >>> 11 ^ j >>> 25 ^ j << 26 ^ j << 21 ^ j << 7) + (m ^ j & (l ^ m)) + f[a];
	    n = m;
	    m = l;
	    l = j;
	    j = k + b | 0;
	    k = i;
	    i = h;
	    h = g;
	    g = b + (h & i ^ k & (h ^ i)) + (h >>> 2 ^ h >>> 13 ^ h >>> 22 ^ h << 30 ^ h << 19 ^ h << 10) | 0
	}
	e[0] = e[0] + g | 0;
	e[1] = e[1] + h | 0;
	e[2] = e[2] + i | 0;
	e[3] = e[3] + k | 0;
	e[4] = e[4] + j | 0;
	e[5] = e[5] + l | 0;
	e[6] = e[6] + m | 0;
	e[7] = e[7] + n | 0
    }
};
sjcl.mode.ccm = {
    name: "ccm",
    encrypt: function (a, b, c, d, e) {
	var f, g = b.slice(0),
	    h = sjcl.bitArray,
	    i = h.bitLength(c) / 8,
	    k = h.bitLength(g) / 8;
	e = e || 64;
	d = d || [];
	if (i < 7) throw new sjcl.exception.invalid("ccm: iv must be at least 7 bytes");
	for (f = 2; f < 4 && k >>> 8 * f; f++);
	if (f < 15 - i) f = 15 - i;
	c = h.clamp(c, 8 * (15 - f));
	b = sjcl.mode.ccm.H(a, b, c, d, e, f);
	g = sjcl.mode.ccm.J(a, g, c, b, e, f);
	return h.concat(g.data, g.tag)
    },
    decrypt: function (a, b, c, d, e) {
	e = e || 64;
	d = d || [];
	var f = sjcl.bitArray,
	    g = f.bitLength(c) / 8,
	    h = f.bitLength(b),
	    i = f.clamp(b, h - e),
	    k = f.bitSlice(b,
	    h - e);
	h = (h - e) / 8;
	if (g < 7) throw new sjcl.exception.invalid("ccm: iv must be at least 7 bytes");
	for (b = 2; b < 4 && h >>> 8 * b; b++);
	if (b < 15 - g) b = 15 - g;
	c = f.clamp(c, 8 * (15 - b));
	i = sjcl.mode.ccm.J(a, i, c, k, e, b);
	a = sjcl.mode.ccm.H(a, i.data, c, d, e, b);
	if (!f.equal(i.tag, a)){									//modified to add alert in PassLok
	alert("Unlocking has failed");								//
	throw new sjcl.exception.corrupt("ccm: tag doesn't match")	//
	};															//
	return i.data
    },
    H: function (a, b, c, d, e, f) {
	var g = [],
	    h = sjcl.bitArray,
	    i = h.k;
	e /= 8;
	if (e % 2 || e < 4 || e > 16) throw new sjcl.exception.invalid("ccm: invalid tag length");
	if (d.length > 0xffffffff || b.length > 0xffffffff) throw new sjcl.exception.bug("ccm: can't deal with 4GiB or more data");
	f = [h.partial(8, (d.length ? 64 : 0) | e - 2 << 2 | f - 1)];
	f = h.concat(f, c);
	f[3] |= h.bitLength(b) / 8;
	f = a.encrypt(f);
	if (d.length) {
	    c = h.bitLength(d) / 8;
	    if (c <= 65279) g = [h.partial(16, c)];
	    else if (c <= 0xffffffff) g = h.concat([h.partial(16, 65534)], [c]);
	    g = h.concat(g, d);
	    for (d = 0; d < g.length; d += 4) f = a.encrypt(i(f, g.slice(d, d + 4).concat([0, 0, 0])))
	}
	for (d = 0; d < b.length; d += 4) f = a.encrypt(i(f, b.slice(d, d + 4).concat([0, 0, 0])));
	return h.clamp(f, e * 8)
    },
    J: function (a, b, c, d, e, f) {
	var g, h = sjcl.bitArray;
	g = h.k;
	var i = b.length,
	    k = h.bitLength(b);
	c = h.concat([h.partial(8,
	f - 1)], c).concat([0, 0, 0]).slice(0, 4);
	d = h.bitSlice(g(d, a.encrypt(c)), 0, e);
	if (!i) return {
	    tag: d,
	    data: []
	};
	for (g = 0; g < i; g += 4) {
	    c[3]++;
	    e = a.encrypt(c);
	    b[g] ^= e[0];
	    b[g + 1] ^= e[1];
	    b[g + 2] ^= e[2];
	    b[g + 3] ^= e[3]
	}
	return {
	    tag: d,
	    data: h.clamp(b, k)
	}
    }
};
sjcl.mode.ocb2 = {
    name: "ocb2",
    encrypt: function (a, b, c, d, e, f) {
	if (sjcl.bitArray.bitLength(c) !== 128) throw new sjcl.exception.invalid("ocb iv must be 128 bits");
	var g, h = sjcl.mode.ocb2.B,
	    i = sjcl.bitArray,
	    k = i.k,
	    j = [0, 0, 0, 0];
	c = h(a.encrypt(c));
	var l, m = [];
	d = d || [];
	e = e || 64;
	for (g = 0; g + 4 < b.length; g += 4) {
	    l = b.slice(g, g + 4);
	    j = k(j, l);
	    m = m.concat(k(c, a.encrypt(k(c, l))));
	    c = h(c)
	}
	l = b.slice(g);
	b = i.bitLength(l);
	g = a.encrypt(k(c, [0, 0, 0, b]));
	l = i.clamp(k(l.concat([0, 0, 0]), g), b);
	j = k(j, k(l.concat([0, 0, 0]), g));
	j = a.encrypt(k(j, k(c, h(c))));
	if (d.length) j = k(j, f ? d : sjcl.mode.ocb2.pmac(a, d));
	return m.concat(i.concat(l, i.clamp(j, e)))
    },
    decrypt: function (a, b, c, d, e, f) {
	if (sjcl.bitArray.bitLength(c) !== 128) throw new sjcl.exception.invalid("ocb iv must be 128 bits");
	e = e || 64;
	var g = sjcl.mode.ocb2.B,
	    h = sjcl.bitArray,
	    i = h.k,
	    k = [0, 0, 0, 0],
	    j = g(a.encrypt(c)),
	    l, m, n = sjcl.bitArray.bitLength(b) - e,
	    o = [];
	d = d || [];
	for (c = 0; c + 4 < n / 32; c += 4) {
	    l = i(j, a.decrypt(i(j, b.slice(c, c + 4))));
	    k = i(k, l);
	    o = o.concat(l);
	    j = g(j)
	}
	m = n - c * 32;
	l = a.encrypt(i(j, [0, 0, 0, m]));
	l = i(l, h.clamp(b.slice(c),
	m).concat([0, 0, 0]));
	k = i(k, l);
	k = a.encrypt(i(k, i(j, g(j))));
	if (d.length) k = i(k, f ? d : sjcl.mode.ocb2.pmac(a, d));
	if (!h.equal(h.clamp(k, e), h.bitSlice(b, n))) throw new sjcl.exception.corrupt("ocb: tag doesn't match");
	return o.concat(h.clamp(l, m))
    },
    pmac: function (a, b) {
	var c, d = sjcl.mode.ocb2.B,
	    e = sjcl.bitArray,
	    f = e.k,
	    g = [0, 0, 0, 0],
	    h = a.encrypt([0, 0, 0, 0]);
	h = f(h, d(d(h)));
	for (c = 0; c + 4 < b.length; c += 4) {
	    h = d(h);
	    g = f(g, a.encrypt(f(h, b.slice(c, c + 4))))
	}
	b = b.slice(c);
	if (e.bitLength(b) < 128) {
	    h = f(h, d(h));
	    b = e.concat(b, [2147483648 | 0, 0,
	    0, 0])
	}
	g = f(g, b);
	return a.encrypt(f(d(f(h, d(h))), g))
    },
    B: function (a) {
	return [a[0] << 1 ^ a[1] >>> 31, a[1] << 1 ^ a[2] >>> 31, a[2] << 1 ^ a[3] >>> 31, a[3] << 1 ^ (a[0] >>> 31) * 135]
    }
};
sjcl.misc.hmac = function (a, b) {
    this.M = b = b || sjcl.hash.sha256;
    var c = [
	[],
	[]
    ],
	d = b.prototype.blockSize / 32;
    this.l = [new b, new b];
    if (a.length > d) a = b.hash(a);
    for (b = 0; b < d; b++) {
	c[0][b] = a[b] ^ 909522486;
	c[1][b] = a[b] ^ 1549556828
    }
    this.l[0].update(c[0]);
    this.l[1].update(c[1])
};
sjcl.misc.hmac.prototype.encrypt = sjcl.misc.hmac.prototype.mac = function (a, b) {
    a = (new this.M(this.l[0])).update(a, b).finalize();
    return (new this.M(this.l[1])).update(a).finalize()
};
sjcl.misc.pbkdf2 = function (a, b, c, d, e) {
    c = c || 1E3;
    if (d < 0 || c < 0) throw sjcl.exception.invalid("invalid params to pbkdf2");
    if (typeof a === "string") a = sjcl.codec.utf8String.toBits(a);
    e = e || sjcl.misc.hmac;
    a = new e(a);
    var f, g, h, i, k = [],
	j = sjcl.bitArray;
    for (i = 1; 32 * k.length < (d || 1); i++) {
	e = f = a.encrypt(j.concat(b, [i]));
	for (g = 1; g < c; g++) {
	    f = a.encrypt(f);
	    for (h = 0; h < f.length; h++) e[h] ^= f[h]
	}
	k = k.concat(e)
    }
    if (d) k = j.clamp(k, d);
    return k
};
sjcl.random = {
    randomWords: function (a, b) {
	var c = [];
	b = this.isReady(b);
	var d;
	if (b === 0) throw new sjcl.exception.notReady("generator isn't seeded");
	else b & 2 && this.U(!(b & 1));
	for (b = 0; b < a; b += 4) {
	    (b + 1) % 0x10000 === 0 && this.L();
	    d = this.w();
	    c.push(d[0], d[1], d[2], d[3])
	}
	this.L();
	return c.slice(0, a)
    },
    setDefaultParanoia: function (a) {
	this.t = a
    },
    addEntropy: function (a, b, c) {
	c = c || "user";
	var d, e, f = (new Date).valueOf(),
	    g = this.q[c],
	    h = this.isReady(),
	    i = 0;
	d = this.G[c];
	if (d === undefined) d = this.G[c] = this.R++;
	if (g === undefined) g = this.q[c] = 0;
	this.q[c] = (this.q[c] + 1) % this.b.length;
	switch (typeof a) {
	    case "number":
		if (b === undefined) b = 1;
		this.b[g].update([d, this.u++, 1, b, f, 1, a | 0]);
		break;
	    case "object":
		c = Object.prototype.toString.call(a);
		if (c === "[object Uint32Array]") {
		    e = [];
		    for (c = 0; c < a.length; c++) e.push(a[c]);
		    a = e
		} else {
		    if (c !== "[object Array]") i = 1;
		    for (c = 0; c < a.length && !i; c++) if (typeof a[c] != "number") i = 1
		}
		if (!i) {
		    if (b === undefined) for (c = b = 0; c < a.length; c++) for (e = a[c]; e > 0;) {
			b++;
			e >>>= 1
		    }
		    this.b[g].update([d, this.u++, 2, b, f, a.length].concat(a))
		}
		break;
	    case "string":
		if (b === undefined) b = a.length;
		this.b[g].update([d, this.u++, 3, b, f, a.length]);
		this.b[g].update(a);
		break;
	    default:
		i = 1
	}
	if (i) throw new sjcl.exception.bug("random: addEntropy only supports number, array of numbers or string");
	this.j[g] += b;
	this.f += b;
	if (h === 0) {
	    this.isReady() !== 0 && this.K("seeded", Math.max(this.g, this.f));
	    this.K("progress", this.getProgress())
	}
    },
    isReady: function (a) {
	a = this.C[a !== undefined ? a : this.t];
	return this.g && this.g >= a ? this.j[0] > 80 && (new Date).valueOf() > this.O ? 3 : 1 : this.f >= a ? 2 : 0
    },
    getProgress: function (a) {
	a = this.C[a ? a : this.t];
	return this.g >= a ? 1 : this.f > a ? 1 : this.f / a
    },
    startCollectors: function () {
	if (!this.m) {
	    if (window.addEventListener) {
		window.addEventListener("load", this.o, false);
		window.addEventListener("mousemove", this.p, false)
	    } else if (document.attachEvent) {
		document.attachEvent("onload", this.o);
		document.attachEvent("onmousemove", this.p)
	    } else throw new sjcl.exception.bug("can't attach event");
	    this.m = true
	}
    },
    stopCollectors: function () {
	if (this.m) {
	    if (window.removeEventListener) {
		window.removeEventListener("load",
		this.o, false);
		window.removeEventListener("mousemove", this.p, false)
	    } else if (window.detachEvent) {
		window.detachEvent("onload", this.o);
		window.detachEvent("onmousemove", this.p)
	    }
	    this.m = false
	}
    },
    addEventListener: function (a, b) {
	this.r[a][this.Q++] = b
    },
    removeEventListener: function (a, b) {
	var c;
	a = this.r[a];
	var d = [];
	for (c in a) a.hasOwnProperty(c) && a[c] === b && d.push(c);
	for (b = 0; b < d.length; b++) {
	    c = d[b];
	    delete a[c]
	}
    },
    b: [new sjcl.hash.sha256],
    j: [0],
    A: 0,
    q: {},
    u: 0,
    G: {},
    R: 0,
    g: 0,
    f: 0,
    O: 0,
    a: [0, 0, 0, 0, 0, 0, 0, 0],
    d: [0, 0, 0, 0],
    s: undefined,
    t: 6,
    m: false,
    r: {
	progress: {},
	seeded: {}
    },
    Q: 0,
    C: [0, 48, 64, 96, 128, 192, 0x100, 384, 512, 768, 1024],
    w: function () {
	for (var a = 0; a < 4; a++) {
	    this.d[a] = this.d[a] + 1 | 0;
	    if (this.d[a]) break
	}
	return this.s.encrypt(this.d)
    },
    L: function () {
	this.a = this.w().concat(this.w());
	this.s = new sjcl.cipher.aes(this.a)
    },
    T: function (a) {
	this.a = sjcl.hash.sha256.hash(this.a.concat(a));
	this.s = new sjcl.cipher.aes(this.a);
	for (a = 0; a < 4; a++) {
	    this.d[a] = this.d[a] + 1 | 0;
	    if (this.d[a]) break
	}
    },
    U: function (a) {
	var b = [],
	    c = 0,
	    d;
	this.O = b[0] = (new Date).valueOf() + 3E4;
	for (d = 0; d < 16; d++) b.push(Math.random() * 0x100000000 | 0);
	for (d = 0; d < this.b.length; d++) {
	    b = b.concat(this.b[d].finalize());
	    c += this.j[d];
	    this.j[d] = 0;
	    if (!a && this.A & 1 << d) break
	}
	if (this.A >= 1 << this.b.length) {
	    this.b.push(new sjcl.hash.sha256);
	    this.j.push(0)
	}
	this.f -= c;
	if (c > this.g) this.g = c;
	this.A++;
	this.T(b)
    },
    p: function (a) {
	sjcl.random.addEntropy([a.x || a.clientX || a.offsetX || 0, a.y || a.clientY || a.offsetY || 0], 2, "mouse")
    },
    o: function () {
	sjcl.random.addEntropy((new Date).valueOf(), 2, "loadtime")
    },
    K: function (a, b) {
	var c;
	a = sjcl.random.r[a];
	var d = [];
	for (c in a) a.hasOwnProperty(c) && d.push(a[c]);
	for (c = 0; c < d.length; c++) d[c](b)
    }
};
try {
    var s = new Uint32Array(32);
    crypto.getRandomValues(s);
    sjcl.random.addEntropy(s, 1024, "crypto['getRandomValues']")
} catch (t) {}
sjcl.json = {
    defaults: {
	v: 1,
	iter: 1E3,
	ks: 128,
	ts: 64,
	mode: "ccm",
	adata: "",
	cipher: "aes"
    },
    encrypt: function (a, b, c, d) {
	c = c || {};
	d = d || {};
	var e = sjcl.json,
	    f = e.c({
		iv: sjcl.random.randomWords(4, 0)
	    }, e.defaults),
	    g;
	e.c(f, c);
	c = f.adata;
	if (typeof f.salt === "string") f.salt = sjcl.codec.base64.toBits(f.salt);
	if (typeof f.iv === "string") f.iv = sjcl.codec.base64.toBits(f.iv);
	if (!sjcl.mode[f.mode] || !sjcl.cipher[f.cipher] || typeof a === "string" && f.iter <= 100 || f.ts !== 64 && f.ts !== 96 && f.ts !== 128 || f.ks !== 128 && f.ks !== 192 && f.ks !== 0x100 || f.iv.length < 2 || f.iv.length > 4) throw new sjcl.exception.invalid("json encrypt: invalid parameters");
	if (typeof a === "string") {
	    g = sjcl.misc.cachedPbkdf2(a, f);
	    a = g.key.slice(0, f.ks / 32);
	    f.salt = g.salt
	}
	if (typeof b === "string") b = sjcl.codec.utf8String.toBits(b);
	if (typeof c === "string") c = sjcl.codec.utf8String.toBits(c);
	g = new sjcl.cipher[f.cipher](a);
	e.c(d, f);
	d.key = a;
	f.ct = sjcl.mode[f.mode].encrypt(g, b, f.iv, c, f.ts);
	return e.encode(f)
    },
    decrypt: function (a, b, c, d) {
	c = c || {};
	d = d || {};
	var e = sjcl.json;
	b = e.c(e.c(e.c({}, e.defaults), e.decode(b)),
	c, true);
	var f;
	c = b.adata;
	if (typeof b.salt === "string") b.salt = sjcl.codec.base64.toBits(b.salt);
	if (typeof b.iv === "string") b.iv = sjcl.codec.base64.toBits(b.iv);
	if (!sjcl.mode[b.mode] || !sjcl.cipher[b.cipher] || typeof a === "string" && b.iter <= 100 || b.ts !== 64 && b.ts !== 96 && b.ts !== 128 || b.ks !== 128 && b.ks !== 192 && b.ks !== 0x100 || !b.iv || b.iv.length < 2 || b.iv.length > 4) throw new sjcl.exception.invalid("json decrypt: invalid parameters");
	if (typeof a === "string") {
	    f = sjcl.misc.cachedPbkdf2(a, b);
	    a = f.key.slice(0, b.ks / 32);
	    b.salt = f.salt
	}
	if (typeof c === "string") c = sjcl.codec.utf8String.toBits(c);
	f = new sjcl.cipher[b.cipher](a);
	c = sjcl.mode[b.mode].decrypt(f, b.ct, b.iv, c, b.ts);
	e.c(d, b);
	d.key = a;
	return sjcl.codec.utf8String.fromBits(c)
    },
    encode: function (a) {
	var b, c = "{",
	    d = "";
	for (b in a) if (a.hasOwnProperty(b)) {
	    if (!b.match(/^[a-z0-9]+$/i)) throw new sjcl.exception.invalid("json encode: invalid property name");
	    c += d + '"' + b + '":';
	    d = ",";
	    switch (typeof a[b]) {
		case "number":
		case "boolean":
		    c += a[b];
		    break;
		case "string":
		    c += '"' + escape(a[b]) + '"';
		    break;
		case "object":
		    c += '"' + sjcl.codec.base64.fromBits(a[b], 1) + '"';
		    break;
		default:
		    throw new sjcl.exception.bug("json encode: unsupported type");
	    }
	}
	return c + "}"
    },
    decode: function (a) {
	a = a.replace(/\s/g, "");
	if (!a.match(/^\{.*\}$/)) throw new sjcl.exception.invalid("json decode: this isn't json!");
	a = a.replace(/^\{|\}$/g, "").split(/,/);
	var b = {}, c, d;
	for (c = 0; c < a.length; c++) {
	    if (!(d = a[c].match(/^(?:(["']?)([a-z][a-z0-9]*)\1):(?:(\d+)|"([a-z0-9+\/%*_.@=\-]*)")$/i))) throw new sjcl.exception.invalid("json decode: this isn't json!");
	    b[d[2]] = d[3] ? parseInt(d[3], 10) : d[2].match(/^(ct|salt|iv)$/) ? sjcl.codec.base64.toBits(d[4]) : unescape(d[4])
	}
	return b
    },
    c: function (a, b, c) {
	if (a === undefined) a = {};
	if (b === undefined) return a;
	var d;
	for (d in b) if (b.hasOwnProperty(d)) {
	    if (c && a[d] !== undefined && a[d] !== b[d]) throw new sjcl.exception.invalid("required parameter overridden");
	    a[d] = b[d]
	}
	return a
    },
    W: function (a, b) {
	var c = {}, d;
	for (d in a) if (a.hasOwnProperty(d) && a[d] !== b[d]) c[d] = a[d];
	return c
    },
    V: function (a, b) {
	var c = {}, d;
	for (d = 0; d < b.length; d++) if (a[b[d]] !== undefined) c[b[d]] = a[b[d]];
	return c
    }
};
sjcl.encrypt = sjcl.json.encrypt;
sjcl.decrypt = sjcl.json.decrypt;
sjcl.misc.S = {};
sjcl.misc.cachedPbkdf2 = function (a, b) {
    var c = sjcl.misc.S,
	d;
    b = b || {};
    d = b.iter || 1E3;
    c = c[a] = c[a] || {};
    d = c[d] = c[d] || {
	firstSalt: b.salt && b.salt.length ? b.salt.slice(0) : sjcl.random.randomWords(2, 0)
    };
    c = b.salt === undefined ? d.firstSalt : b.salt;
    d[c] = d[c] || sjcl.misc.pbkdf2(a, c, b.iter);
    return {
	key: d[c].slice(0),
	salt: c.slice(0)
    }
};

//SHA512.js begins (also from SJCL)
/** @fileOverview Javascript SHA-512 implementation.
 *
 * This implementation was written for CryptoJS by Jeff Mott and adapted for
 * SJCL by Stefan Thomas.
 *
 * CryptoJS (c) 2009-2012 by Jeff Mott. All rights reserved.
 * Released with New BSD License
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 * @author Jeff Mott
 * @author Stefan Thomas
 */

/**
 * Context for a SHA-512 operation in progress.
 * @constructor
 * @class Secure Hash Algorithm, 512 bits.
 */
sjcl.hash.sha512 = function (hash) {
  if (!this._key[0]) { this._precompute(); }
  if (hash) {
    this._h = hash._h.slice(0);
    this._buffer = hash._buffer.slice(0);
    this._length = hash._length;
  } else {
    this.reset();
  }
};

/**
 * Hash a string or an array of words.
 * @static
 * @param {bitArray|String} data the data to hash.
 * @return {bitArray} The hash value, an array of 16 big-endian words.
 */
sjcl.hash.sha512.hash = function (data) {
  return (new sjcl.hash.sha512()).update(data).finalize();
};

sjcl.hash.sha512.prototype = {
  /**
   * The hash's block size, in bits.
   * @constant
   */
  blockSize: 1024,
   
  /**
   * Reset the hash state.
   * @return this
   */
  reset:function () {
    this._h = this._init.slice(0);
    this._buffer = [];
    this._length = 0;
    return this;
  },
  
  /**
   * Input several words to the hash.
   * @param {bitArray|String} data the data to hash.
   * @return this
   */
  update: function (data) {
    if (typeof data === "string") {
      data = sjcl.codec.utf8String.toBits(data);
    }
    var i, b = this._buffer = sjcl.bitArray.concat(this._buffer, data),
        ol = this._length,
        nl = this._length = ol + sjcl.bitArray.bitLength(data);
    for (i = 1024+ol & -1024; i <= nl; i+= 1024) {
      this._block(b.splice(0,32));
    }
    return this;
  },
  
  /**
   * Complete hashing and output the hash value.
   * @return {bitArray} The hash value, an array of 16 big-endian words.
   */
  finalize:function () {
    var i, b = this._buffer, h = this._h;

    // Round out and push the buffer
    b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1,1)]);

    // Round out the buffer to a multiple of 32 words, less the 4 length words.
    for (i = b.length + 4; i & 31; i++) {
      b.push(0);
    }

    // append the length
    b.push(0);
    b.push(0);
    b.push(Math.floor(this._length / 0x100000000));
    b.push(this._length | 0);

    while (b.length) {
      this._block(b.splice(0,32));
    }

    this.reset();
    return h;
  },

  /**
   * The SHA-512 initialization vector, to be precomputed.
   * @private
   */
  _init:[],

  /**
   * Least significant 24 bits of SHA512 initialization values.
   *
   * Javascript only has 53 bits of precision, so we compute the 40 most
   * significant bits and add the remaining 24 bits as constants.
   *
   * @private
   */
  _initr: [ 0xbcc908, 0xcaa73b, 0x94f82b, 0x1d36f1, 0xe682d1, 0x3e6c1f, 0x41bd6b, 0x7e2179 ],

  /*
  _init:
  [0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,
   0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179],
  */

  /**
   * The SHA-512 hash key, to be precomputed.
   * @private
   */
  _key:[],

  /**
   * Least significant 24 bits of SHA512 key values.
   * @private
   */
  _keyr:
  [0x28ae22, 0xef65cd, 0x4d3b2f, 0x89dbbc, 0x48b538, 0x05d019, 0x194f9b, 0x6d8118,
   0x030242, 0x706fbe, 0xe4b28c, 0xffb4e2, 0x7b896f, 0x1696b1, 0xc71235, 0x692694,
   0xf14ad2, 0x4f25e3, 0x8cd5b5, 0xac9c65, 0x2b0275, 0xa6e483, 0x41fbd4, 0x1153b5,
   0x66dfab, 0xb43210, 0xfb213f, 0xef0ee4, 0xa88fc2, 0x0aa725, 0x03826f, 0x0e6e70,
   0xd22ffc, 0x26c926, 0xc42aed, 0x95b3df, 0xaf63de, 0x77b2a8, 0xedaee6, 0x82353b,
   0xf10364, 0x423001, 0xf89791, 0x54be30, 0xef5218, 0x65a910, 0x71202a, 0xbbd1b8,
   0xd2d0c8, 0x41ab53, 0x8eeb99, 0x9b48a8, 0xc95a63, 0x418acb, 0x63e373, 0xb2b8a3,
   0xefb2fc, 0x172f60, 0xf0ab72, 0x6439ec, 0x631e28, 0x82bde9, 0xc67915, 0x72532b,
   0x26619c, 0xc0c207, 0xe0eb1e, 0x6ed178, 0x176fba, 0xc898a6, 0xf90dae, 0x1c471b,
   0x047d84, 0xc72493, 0xc9bebc, 0x100d4c, 0x3e42b6, 0x657e2a, 0xd6faec, 0x475817],

  /*
  _key:
  [0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd, 0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
   0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019, 0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
   0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe, 0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
   0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1, 0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
   0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3, 0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
   0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483, 0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
   0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210, 0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
   0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725, 0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
   0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926, 0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
   0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8, 0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
   0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001, 0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
   0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910, 0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
   0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53, 0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
   0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb, 0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
   0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60, 0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
   0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9, 0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
   0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207, 0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
   0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6, 0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
   0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493, 0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
   0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a, 0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817],
  */

  /**
   * Function to precompute _init and _key.
   * @private
   */
  _precompute: function () {
    // XXX: This code is for precomputing the SHA256 constants, change for
    //      SHA512 and re-enable.
    var i = 0, prime = 2, factor;

    function frac(x)  { return (x-Math.floor(x)) * 0x100000000 | 0; }
    function frac2(x) { return (x-Math.floor(x)) * 0x10000000000 & 0xff; }

    outer: for (; i<80; prime++) {
      for (factor=2; factor*factor <= prime; factor++) {
        if (prime % factor === 0) {
          // not a prime
          continue outer;
        }
      }

      if (i<8) {
        this._init[i*2] = frac(Math.pow(prime, 1/2));
        this._init[i*2+1] = (frac2(Math.pow(prime, 1/2)) << 24) | this._initr[i];
      }
      this._key[i*2] = frac(Math.pow(prime, 1/3));
      this._key[i*2+1] = (frac2(Math.pow(prime, 1/3)) << 24) | this._keyr[i];
      i++;
    }
  },

  /**
   * Perform one cycle of SHA-512.
   * @param {bitArray} words one block of words.
   * @private
   */
  _block:function (words) {
    var i, wrh, wrl,
        w = words.slice(0),
        h = this._h,
        k = this._key,
        h0h = h[ 0], h0l = h[ 1], h1h = h[ 2], h1l = h[ 3],
        h2h = h[ 4], h2l = h[ 5], h3h = h[ 6], h3l = h[ 7],
        h4h = h[ 8], h4l = h[ 9], h5h = h[10], h5l = h[11],
        h6h = h[12], h6l = h[13], h7h = h[14], h7l = h[15];

    // Working variables
    var ah = h0h, al = h0l, bh = h1h, bl = h1l,
        ch = h2h, cl = h2l, dh = h3h, dl = h3l,
        eh = h4h, el = h4l, fh = h5h, fl = h5l,
        gh = h6h, gl = h6l, hh = h7h, hl = h7l;

    for (i=0; i<80; i++) {
      // load up the input word for this round
      if (i<16) {
        wrh = w[i * 2];
        wrl = w[i * 2 + 1];
      } else {
        // Gamma0
        var gamma0xh = w[(i-15) * 2];
        var gamma0xl = w[(i-15) * 2 + 1];
        var gamma0h =
          ((gamma0xl << 31) | (gamma0xh >>> 1)) ^
          ((gamma0xl << 24) | (gamma0xh >>> 8)) ^
           (gamma0xh >>> 7);
        var gamma0l =
          ((gamma0xh << 31) | (gamma0xl >>> 1)) ^
          ((gamma0xh << 24) | (gamma0xl >>> 8)) ^
          ((gamma0xh << 25) | (gamma0xl >>> 7));

        // Gamma1
        var gamma1xh = w[(i-2) * 2];
        var gamma1xl = w[(i-2) * 2 + 1];
        var gamma1h =
          ((gamma1xl << 13) | (gamma1xh >>> 19)) ^
          ((gamma1xh << 3)  | (gamma1xl >>> 29)) ^
           (gamma1xh >>> 6);
        var gamma1l =
          ((gamma1xh << 13) | (gamma1xl >>> 19)) ^
          ((gamma1xl << 3)  | (gamma1xh >>> 29)) ^
          ((gamma1xh << 26) | (gamma1xl >>> 6));

        // Shortcuts
        var wr7h = w[(i-7) * 2];
        var wr7l = w[(i-7) * 2 + 1];

        var wr16h = w[(i-16) * 2];
        var wr16l = w[(i-16) * 2 + 1];

        // W(round) = gamma0 + W(round - 7) + gamma1 + W(round - 16)
        wrl = gamma0l + wr7l;
        wrh = gamma0h + wr7h + ((wrl >>> 0) < (gamma0l >>> 0) ? 1 : 0);
        wrl += gamma1l;
        wrh += gamma1h + ((wrl >>> 0) < (gamma1l >>> 0) ? 1 : 0);
        wrl += wr16l;
        wrh += wr16h + ((wrl >>> 0) < (wr16l >>> 0) ? 1 : 0);
      }

      w[i*2]     = wrh |= 0;
      w[i*2 + 1] = wrl |= 0;

      // Ch
      var chh = (eh & fh) ^ (~eh & gh);
      var chl = (el & fl) ^ (~el & gl);

      // Maj
      var majh = (ah & bh) ^ (ah & ch) ^ (bh & ch);
      var majl = (al & bl) ^ (al & cl) ^ (bl & cl);

      // Sigma0
      var sigma0h = ((al << 4) | (ah >>> 28)) ^ ((ah << 30) | (al >>> 2)) ^ ((ah << 25) | (al >>> 7));
      var sigma0l = ((ah << 4) | (al >>> 28)) ^ ((al << 30) | (ah >>> 2)) ^ ((al << 25) | (ah >>> 7));

      // Sigma1
      var sigma1h = ((el << 18) | (eh >>> 14)) ^ ((el << 14) | (eh >>> 18)) ^ ((eh << 23) | (el >>> 9));
      var sigma1l = ((eh << 18) | (el >>> 14)) ^ ((eh << 14) | (el >>> 18)) ^ ((el << 23) | (eh >>> 9));

      // K(round)
      var krh = k[i*2];
      var krl = k[i*2+1];

      // t1 = h + sigma1 + ch + K(round) + W(round)
      var t1l = hl + sigma1l;
      var t1h = hh + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0);
      t1l += chl;
      t1h += chh + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0);
      t1l += krl;
      t1h += krh + ((t1l >>> 0) < (krl >>> 0) ? 1 : 0);
      t1l += wrl;
      t1h += wrh + ((t1l >>> 0) < (wrl >>> 0) ? 1 : 0);

      // t2 = sigma0 + maj
      var t2l = sigma0l + majl;
      var t2h = sigma0h + majh + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0);

      // Update working variables
      hh = gh;
      hl = gl;
      gh = fh;
      gl = fl;
      fh = eh;
      fl = el;
      el = (dl + t1l) | 0;
      eh = (dh + t1h + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;
      dh = ch;
      dl = cl;
      ch = bh;
      cl = bl;
      bh = ah;
      bl = al;
      al = (t1l + t2l) | 0;
      ah = (t1h + t2h + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0;
    }

    // Intermediate hash
    h0l = h[1] = (h0l + al) | 0;
    h[0] = (h0h + ah + ((h0l >>> 0) < (al >>> 0) ? 1 : 0)) | 0;
    h1l = h[3] = (h1l + bl) | 0;
    h[2] = (h1h + bh + ((h1l >>> 0) < (bl >>> 0) ? 1 : 0)) | 0;
    h2l = h[5] = (h2l + cl) | 0;
    h[4] = (h2h + ch + ((h2l >>> 0) < (cl >>> 0) ? 1 : 0)) | 0;
    h3l = h[7] = (h3l + dl) | 0;
    h[6] = (h3h + dh + ((h3l >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;
    h4l = h[9] = (h4l + el) | 0;
    h[8] = (h4h + eh + ((h4l >>> 0) < (el >>> 0) ? 1 : 0)) | 0;
    h5l = h[11] = (h5l + fl) | 0;
    h[10] = (h5h + fh + ((h5l >>> 0) < (fl >>> 0) ? 1 : 0)) | 0;
    h6l = h[13] = (h6l + gl) | 0;
    h[12] = (h6h + gh + ((h6l >>> 0) < (gl >>> 0) ? 1 : 0)) | 0;
    h7l = h[15] = (h7l + hl) | 0;
    h[14] = (h7h + hh + ((h7l >>> 0) < (hl >>> 0) ? 1 : 0)) | 0;
  }
};
//SHA512.js ends

//BN.js begins (also from SJCL)
/**
 * Constructs a new bignum from another bignum, a number or a hex string.
 */
sjcl.bn = function(it) {
  this.initWith(it);
};

sjcl.bn.prototype = {
  radix: 24,
  maxMul: 8,
  _class: sjcl.bn,
  
  copy: function() {
    return new this._class(this);
  },

  /**
   * Initializes this with it, either as a bn, a number, or a hex string.
   */
  initWith: function(it) {
    var i=0, k, n, l;
    switch(typeof it) {
    case "object":
      this.limbs = it.limbs.slice(0);
      break;
      
    case "number":
      this.limbs = [it];
      this.normalize();
      break;
      
    case "string":
      it = it.replace(/^0x/, '');
      this.limbs = [];
      // hack
      k = this.radix / 4;
      for (i=0; i < it.length; i+=k) {
	this.limbs.push(parseInt(it.substring(Math.max(it.length - i - k, 0), it.length - i),16));
      }
      break;

    default:
      this.limbs = [0];
    }
    return this;
  },

  /**
   * Returns true if "this" and "that" are equal.  Calls fullReduce().
   * Equality test is in constant time.
   */
  equals: function(that) {
    if (typeof that === "number") { that = new this._class(that); }
    var difference = 0, i;
    this.fullReduce();
    that.fullReduce();
    for (i = 0; i < this.limbs.length || i < that.limbs.length; i++) {
      difference |= this.getLimb(i) ^ that.getLimb(i);
    }
    return (difference === 0);
  },
  
  /**
   * Get the i'th limb of this, zero if i is too large.
   */
  getLimb: function(i) {
    return (i >= this.limbs.length) ? 0 : this.limbs[i];
  },
  
  /**
   * Constant time comparison function.
   * Returns 1 if this >= that, or zero otherwise.
   */
  greaterEquals: function(that) {
    if (typeof that === "number") { that = new this._class(that); }
    var less = 0, greater = 0, i, a, b;
    i = Math.max(this.limbs.length, that.limbs.length) - 1;
    for (; i>= 0; i--) {
      a = this.getLimb(i);
      b = that.getLimb(i);
      greater |= (b - a) & ~less;
      less |= (a - b) & ~greater;
    }
    return (greater | ~less) >>> 31;
  },
  
  /**
   * Convert to a hex string.
   */
  toString: function() {
    this.fullReduce();
    var out="", i, s, l = this.limbs;
    for (i=0; i < this.limbs.length; i++) {
      s = l[i].toString(16);
      while (i < this.limbs.length - 1 && s.length < 6) {
	s = "0" + s;
      }
      out = s + out;
    }
    return "0x"+out;
  },
  
  /** this += that.  Does not normalize. */
  addM: function(that) {
    if (typeof(that) !== "object") { that = new this._class(that); }
    var i, l=this.limbs, ll=that.limbs;
    for (i=l.length; i<ll.length; i++) {
      l[i] = 0;
    }
    for (i=0; i<ll.length; i++) {
      l[i] += ll[i];
    }
    return this;
  },
  
  /** this *= 2.  Requires normalized; ends up normalized. */
  doubleM: function() {
    var i, carry=0, tmp, r=this.radix, m=this.radixMask, l=this.limbs;
    for (i=0; i<l.length; i++) {
      tmp = l[i];
      tmp = tmp+tmp+carry;
      l[i] = tmp & m;
      carry = tmp >> r;
    }
    if (carry) {
      l.push(carry);
    }
    return this;
  },
  
  /** this /= 2, rounded down.	Requires normalized; ends up normalized. */
  halveM: function() {
    var i, carry=0, tmp, r=this.radix, l=this.limbs;
    for (i=l.length-1; i>=0; i--) {
      tmp = l[i];
      l[i] = (tmp+carry)>>1;
      carry = (tmp&1) << r;
    }
    if (!l[l.length-1]) {
      l.pop();
    }
    return this;
  },

  /** this -= that.  Does not normalize. */
  subM: function(that) {
    if (typeof(that) !== "object") { that = new this._class(that); }
    var i, l=this.limbs, ll=that.limbs;
    for (i=l.length; i<ll.length; i++) {
      l[i] = 0;
    }
    for (i=0; i<ll.length; i++) {
      l[i] -= ll[i];
    }
    return this;
  },
  
  mod: function(that) {
    that = new sjcl.bn(that).normalize(); // copy before we begin
    var out = new sjcl.bn(this).normalize(), ci=0;
    
    for (; out.greaterEquals(that); ci++) {

      that.doubleM();
    }
    for (; ci > 0; ci--) {
      that.halveM();
      if (out.greaterEquals(that)) {
	out.subM(that).normalize();
      }
    }
    return out.trim();
  },
  
  /** return inverse mod prime p.  p must be odd. Binary extended Euclidean algorithm mod p. */
  inverseMod: function(p) {
    var a = new sjcl.bn(1), b = new sjcl.bn(0), x = new sjcl.bn(this), y = new sjcl.bn(p), tmp, i, nz=1;
    
    if (!(p.limbs[0] & 1)) {
      throw (new sjcl.exception.invalid("inverseMod: p must be odd"));
    }
    
    // invariant: y is odd
    do {
      if (x.limbs[0] & 1) {
	if (!x.greaterEquals(y)) {
	  // x < y; swap everything
	  tmp = x; x = y; y = tmp;
	  tmp = a; a = b; b = tmp;
	}
	x.subM(y);
	x.normalize();
	
	if (!a.greaterEquals(b)) {
	  a.addM(p);
	}
	a.subM(b);
      }
      
      // cut everything in half
      x.halveM();
      if (a.limbs[0] & 1) {
	a.addM(p);
      }
      a.normalize();
      a.halveM();
      
      // check for termination: x ?= 0
      for (i=nz=0; i<x.limbs.length; i++) {
	nz |= x.limbs[i];
      }
    } while(nz);
    
    if (!y.equals(1)) {
      throw (new sjcl.exception.invalid("inverseMod: p and x must be relatively prime"));
    }
    
    return b;
  },
  
  /** this + that.  Does not normalize. */
  add: function(that) {
    return this.copy().addM(that);
  },

  /** this - that.  Does not normalize. */
  sub: function(that) {
    return this.copy().subM(that);
  },
  
  /** this * that.  Normalizes and reduces. */
  mul: function(that) {
    if (typeof(that) === "number") { that = new this._class(that); }
    var i, j, a = this.limbs, b = that.limbs, al = a.length, bl = b.length, out = new this._class(), c = out.limbs, ai, ii=this.maxMul;

    for (i=0; i < this.limbs.length + that.limbs.length + 1; i++) {
      c[i] = 0;
    }
    for (i=0; i<al; i++) {
      ai = a[i];
      for (j=0; j<bl; j++) {
	c[i+j] += ai * b[j];
      }
     
      if (!--ii) {
	ii = this.maxMul;
	out.cnormalize();
      }
    }
    return out.cnormalize().reduce();
  },

  /** this ^ 2.  Normalizes and reduces. */
  square: function() {
    return this.mul(this);
  },

  /** this ^ n.  Uses square-and-multiply.  Normalizes and reduces. */
  power: function(l) {
    if (typeof(l) === "number") {
      l = [l];
    } else if (l.limbs !== undefined) {
      l = l.normalize().limbs;
    }
    var i, j, out = new this._class(1), pow = this;

    for (i=0; i<l.length; i++) {
      for (j=0; j<this.radix; j++) {
	if (l[i] & (1<<j)) {
	  out = out.mul(pow);
	}
	pow = pow.square();
      }
    }
    
    return out;
  },

  /** this * that mod N */
  mulmod: function(that, N) {
    return this.mod(N).mul(that.mod(N)).mod(N);
  },

  /** this ^ x mod N */
  powermod: function(x, N) {
    var result = new sjcl.bn(1), a = new sjcl.bn(this), k = new sjcl.bn(x);
    while (true) {
      if (k.limbs[0] & 1) { result = result.mulmod(a, N); }
      k.halveM();
      if (k.equals(0)) { break; }
      a = a.mulmod(a, N);
    }
    return result.normalize().reduce();
  },

  trim: function() {
    var l = this.limbs, p;
    do {
      p = l.pop();
    } while (l.length && p === 0);
    l.push(p);
    return this;
  },
  
  /** Reduce mod a modulus.  Stubbed for subclassing. */
  reduce: function() {
    return this;
  },

  /** Reduce and normalize. */
  fullReduce: function() {
    return this.normalize();
  },
  
  /** Propagate carries. */
  normalize: function() {
    var carry=0, i, pv = this.placeVal, ipv = this.ipv, l, m, limbs = this.limbs, ll = limbs.length, mask = this.radixMask;
    for (i=0; i < ll || (carry !== 0 && carry !== -1); i++) {
      l = (limbs[i]||0) + carry;
      m = limbs[i] = l & mask;
      carry = (l-m)*ipv;
    }
    if (carry === -1) {
      limbs[i-1] -= this.placeVal;
    }
    return this;
  },

  /** Constant-time normalize. Does not allocate additional space. */
  cnormalize: function() {
    var carry=0, i, ipv = this.ipv, l, m, limbs = this.limbs, ll = limbs.length, mask = this.radixMask;
    for (i=0; i < ll-1; i++) {
      l = limbs[i] + carry;
      m = limbs[i] = l & mask;
      carry = (l-m)*ipv;
    }
    limbs[i] += carry;
    return this;
  },
  
  /** Serialize to a bit array */
  toBits: function(len) {
    this.fullReduce();
    len = len || this.exponent || this.limbs.length * this.radix;
    var i = Math.floor((len-1)/24), w=sjcl.bitArray, e = (len + 7 & -8) % this.radix || this.radix,
	out = [w.partial(e, this.getLimb(i))];
    for (i--; i >= 0; i--) {
      out = w.concat(out, [w.partial(this.radix, this.getLimb(i))]);
    }
    return out;
  },
  
  /** Return the length in bits, rounded up to the nearest byte. */
  bitLength: function() {
    this.fullReduce();
    var out = this.radix * (this.limbs.length - 1),
	b = this.limbs[this.limbs.length - 1];
    for (; b; b >>= 1) {
      out ++;
    }
    return out+7 & -8;
  }
};

sjcl.bn.fromBits = function(bits) {
  var Class = this, out = new Class(), words=[], w=sjcl.bitArray, t = this.prototype,
      l = Math.min(this.bitLength || 0x100000000, w.bitLength(bits)), e = l % t.radix || t.radix;
  
  words[0] = w.extract(bits, 0, e);
  for (; e < l; e += t.radix) {
    words.unshift(w.extract(bits, e, t.radix));
  }

  out.limbs = words;
  return out;
};

sjcl.bn.prototype.ipv = 1 / (sjcl.bn.prototype.placeVal = Math.pow(2,sjcl.bn.prototype.radix));
sjcl.bn.prototype.radixMask = (1 << sjcl.bn.prototype.radix) - 1;

/**
 * Creates a new subclass of bn, based on reduction modulo a pseudo-Mersenne prime,
 * i.e. a prime of the form 2^e + sum(a * 2^b),where the sum is negative and sparse.
 */
sjcl.bn.pseudoMersennePrime = function(exponent, coeff) {
  function p(it) {
    this.initWith(it);
    /*if (this.limbs[this.modOffset]) {
      this.reduce();
    }*/
  }

  var ppr = p.prototype = new sjcl.bn(), i, tmp, mo;
  mo = ppr.modOffset = Math.ceil(tmp = exponent / ppr.radix);
  ppr.exponent = exponent;
  ppr.offset = [];
  ppr.factor = [];
  ppr.minOffset = mo;
  ppr.fullMask = 0;
  ppr.fullOffset = [];
  ppr.fullFactor = [];
  ppr.modulus = p.modulus = new sjcl.bn(Math.pow(2,exponent));
  
  ppr.fullMask = 0|-Math.pow(2, exponent % ppr.radix);

  for (i=0; i<coeff.length; i++) {
    ppr.offset[i] = Math.floor(coeff[i][0] / ppr.radix - tmp);
    ppr.fullOffset[i] = Math.ceil(coeff[i][0] / ppr.radix - tmp);
    ppr.factor[i] = coeff[i][1] * Math.pow(1/2, exponent - coeff[i][0] + ppr.offset[i] * ppr.radix);
    ppr.fullFactor[i] = coeff[i][1] * Math.pow(1/2, exponent - coeff[i][0] + ppr.fullOffset[i] * ppr.radix);
    ppr.modulus.addM(new sjcl.bn(Math.pow(2,coeff[i][0])*coeff[i][1]));
    ppr.minOffset = Math.min(ppr.minOffset, -ppr.offset[i]); // conservative
  }
  ppr._class = p;
  ppr.modulus.cnormalize();

  /** Approximate reduction mod p.  May leave a number which is negative or slightly larger than p. */
  ppr.reduce = function() {
    var i, k, l, mo = this.modOffset, limbs = this.limbs, aff, off = this.offset, ol = this.offset.length, fac = this.factor, ll;

    i = this.minOffset;
    while (limbs.length > mo) {
      l = limbs.pop();
      ll = limbs.length;
      for (k=0; k<ol; k++) {
	limbs[ll+off[k]] -= fac[k] * l;
      }
      
      i--;
      if (!i) {
	limbs.push(0);
	this.cnormalize();
	i = this.minOffset;
      }
    }
    this.cnormalize();

    return this;
  };
  
  ppr._strongReduce = (ppr.fullMask === -1) ? ppr.reduce : function() {
    var limbs = this.limbs, i = limbs.length - 1, k, l;
    this.reduce();
    if (i === this.modOffset - 1) {
      l = limbs[i] & this.fullMask;
      limbs[i] -= l;
      for (k=0; k<this.fullOffset.length; k++) {
	limbs[i+this.fullOffset[k]] -= this.fullFactor[k] * l;
      }
      this.normalize();
    }
  };

  /** mostly constant-time, very expensive full reduction. */
  ppr.fullReduce = function() {
    var greater, i;
    // massively above the modulus, may be negative
    
    this._strongReduce();
    // less than twice the modulus, may be negative

    this.addM(this.modulus);
    this.addM(this.modulus);
    this.normalize();
    // probably 2-3x the modulus
    
    this._strongReduce();
    // less than the power of 2.  still may be more than
    // the modulus

    // HACK: pad out to this length
    for (i=this.limbs.length; i<this.modOffset; i++) {
      this.limbs[i] = 0;
    }
    
    // constant-time subtract modulus
    greater = this.greaterEquals(this.modulus);
    for (i=0; i<this.limbs.length; i++) {
      this.limbs[i] -= this.modulus.limbs[i] * greater;
    }
    this.cnormalize();

    return this;
  };

  ppr.inverse = function() {
    return (this.power(this.modulus.sub(2)));
  };

  p.fromBits = sjcl.bn.fromBits;

  return p;
};

// a small Mersenne prime
sjcl.bn.prime = {
  // NIST primes
  p192: sjcl.bn.pseudoMersennePrime(192, [[0,-1],[64,-1]]),
  p224: sjcl.bn.pseudoMersennePrime(224, [[0,1],[96,-1]]),
  p256: sjcl.bn.pseudoMersennePrime(256, [[0,-1],[96,1],[192,1],[224,-1]]),
  p384: sjcl.bn.pseudoMersennePrime(384, [[0,-1],[32,1],[96,-1],[128,-1]]),
  p521: sjcl.bn.pseudoMersennePrime(521, [[0,-1]])
};

sjcl.bn.random = function(modulus, paranoia) {
  if (typeof modulus !== "object") { modulus = new sjcl.bn(modulus); }
  var words, i, l = modulus.limbs.length, m = modulus.limbs[l-1]+1, out = new sjcl.bn();
  while (true) {
    // get a sequence whose first digits make sense
    do {
      words = sjcl.random.randomWords(l, paranoia);
      if (words[l-1] < 0) { words[l-1] += 0x100000000; }
    } while (Math.floor(words[l-1] / m) === Math.floor(0x100000000 / m));
    words[l-1] %= m;

    // mask off all the limbs
    for (i=0; i<l-1; i++) {
      words[i] &= modulus.radixMask;
    }

    // check the rest of the digitssj
    out.limbs = words;
    if (!out.greaterEquals(modulus)) {
      return out;
    }
  }
};

//ECC.js begins (I added the 521-bit curve, took out elGamal etc. at the end, replaced by my own functions. Modifications are noted)
sjcl.ecc = {};

/**
 * Represents a point on a curve in affine coordinates.
 * @constructor
 * @param {sjcl.ecc.curve} curve The curve that this point lies on.
 * @param {bigInt} x The x coordinate.
 * @param {bigInt} y The y coordinate.
 */
sjcl.ecc.point = function(curve,x,y) {
  if (x === undefined) {
    this.isIdentity = true;
  } else {
    this.x = x;
    this.y = y;
    this.isIdentity = false;
  }
  this.curve = curve;
};

sjcl.ecc.point.prototype = {
  toJac: function() {
    return new sjcl.ecc.pointJac(this.curve, this.x, this.y, new this.curve.field(1));
  },

  mult: function(k) {
    return this.toJac().mult(k, this).toAffine();
  },
  
  /**
   * Multiply this point by k, added to affine2*k2, and return the answer in Jacobian coordinates.
   * @param {bigInt} k The coefficient to multiply this by.
   * @param {bigInt} k2 The coefficient to multiply affine2 this by.
   * @param {sjcl.ecc.point} affine The other point in affine coordinates.
   * @return {sjcl.ecc.pointJac} The result of the multiplication and addition, in Jacobian coordinates.
   */
  mult2: function(k, k2, affine2) {
    return this.toJac().mult2(k, this, k2, affine2).toAffine();
  },
  
  multiples: function() {
    var m, i, j;
    if (this._multiples === undefined) {
      j = this.toJac().doubl();
      m = this._multiples = [new sjcl.ecc.point(this.curve), this, j.toAffine()];
      for (i=3; i<16; i++) {
	j = j.add(this);
	m.push(j.toAffine());
      }
    }
    return this._multiples;
  },

  isValid: function() {
    return this.y.square().equals(this.curve.b.add(this.x.mul(this.curve.a.add(this.x.square()))));
  },

  toBits: function() {
    return sjcl.bitArray.concat(this.x.toBits(), this.y.toBits());
  }
};

/**
 * Represents a point on a curve in Jacobian coordinates. Coordinates can be specified as bigInts or strings (which
 * will be converted to bigInts).
 *
 * @constructor
 * @param {bigInt/string} x The x coordinate.
 * @param {bigInt/string} y The y coordinate.
 * @param {bigInt/string} z The z coordinate.
 * @param {sjcl.ecc.curve} curve The curve that this point lies on.
 */
sjcl.ecc.pointJac = function(curve, x, y, z) {
  if (x === undefined) {
    this.isIdentity = true;
  } else {
    this.x = x;
    this.y = y;
    this.z = z;
    this.isIdentity = false;
  }
  this.curve = curve;
};

sjcl.ecc.pointJac.prototype = {
  /**
   * Adds S and T and returns the result in Jacobian coordinates. Note that S must be in Jacobian coordinates and T must be in affine coordinates.
   * @param {sjcl.ecc.pointJac} S One of the points to add, in Jacobian coordinates.
   * @param {sjcl.ecc.point} T The other point to add, in affine coordinates.
   * @return {sjcl.ecc.pointJac} The sum of the two points, in Jacobian coordinates. 
   */
  add: function(T) {
    var S = this, sz2, c, d, c2, x1, x2, x, y1, y2, y, z;
    if (S.curve !== T.curve) {
      throw("sjcl.ecc.add(): Points must be on the same curve to add them!");
    }

    if (S.isIdentity) {
      return T.toJac();
    } else if (T.isIdentity) {
      return S;
    }

    sz2 = S.z.square();
    c = T.x.mul(sz2).subM(S.x);

    if (c.equals(0)) {
      if (S.y.equals(T.y.mul(sz2.mul(S.z)))) {
	// same point
	return S.doubl();
      } else {
	// inverses
	return new sjcl.ecc.pointJac(S.curve);
      }
    }
    
    d = T.y.mul(sz2.mul(S.z)).subM(S.y);
    c2 = c.square();

    x1 = d.square();
    x2 = c.square().mul(c).addM( S.x.add(S.x).mul(c2) );
    x  = x1.subM(x2);

    y1 = S.x.mul(c2).subM(x).mul(d);
    y2 = S.y.mul(c.square().mul(c));
    y  = y1.subM(y2);

    z  = S.z.mul(c);

    return new sjcl.ecc.pointJac(this.curve,x,y,z);
  },
  
  /**
   * doubles this point.
   * @return {sjcl.ecc.pointJac} The doubled point.
   */
  doubl: function() {
    if (this.isIdentity) { return this; }

    var
      y2 = this.y.square(),
      a  = y2.mul(this.x.mul(4)),
      b  = y2.square().mul(8),
      z2 = this.z.square(),
      c  = this.x.sub(z2).mul(3).mul(this.x.add(z2)),
      x  = c.square().subM(a).subM(a),
      y  = a.sub(x).mul(c).subM(b),
      z  = this.y.add(this.y).mul(this.z);
    return new sjcl.ecc.pointJac(this.curve, x, y, z);
  },

  /**
   * Returns a copy of this point converted to affine coordinates.
   * @return {sjcl.ecc.point} The converted point.
   */  
  toAffine: function() {
    if (this.isIdentity || this.z.equals(0)) {
      return new sjcl.ecc.point(this.curve);
    }
    var zi = this.z.inverse(), zi2 = zi.square();
    return new sjcl.ecc.point(this.curve, this.x.mul(zi2).fullReduce(), this.y.mul(zi2.mul(zi)).fullReduce());
  },
  
  /**
   * Multiply this point by k and return the answer in Jacobian coordinates.
   * @param {bigInt} k The coefficient to multiply by.
   * @param {sjcl.ecc.point} affine This point in affine coordinates.
   * @return {sjcl.ecc.pointJac} The result of the multiplication, in Jacobian coordinates.
   */
  mult: function(k, affine) {
    if (typeof(k) === "number") {
      k = [k];
    } else if (k.limbs !== undefined) {
      k = k.normalize().limbs;
    }
    
    var i, j, out = new sjcl.ecc.point(this.curve).toJac(), multiples = affine.multiples();

    for (i=k.length-1; i>=0; i--) {
      for (j=sjcl.bn.prototype.radix-4; j>=0; j-=4) {
	out = out.doubl().doubl().doubl().doubl().add(multiples[k[i]>>j & 0xF]);
      }
    }
    
    return out;
  },
  
/**
   * Multiply this point by k, added to affine2*k2, and return the answer in Jacobian coordinates.
   * @param {bigInt} k The coefficient to multiply this by.
   * @param {sjcl.ecc.point} affine This point in affine coordinates.
   * @param {bigInt} k2 The coefficient to multiply affine2 this by.
   * @param {sjcl.ecc.point} affine The other point in affine coordinates.
   * @return {sjcl.ecc.pointJac} The result of the multiplication and addition, in Jacobian coordinates.
   */
  mult2: function(k1, affine, k2, affine2) {
    if (typeof(k1) === "number") {
      k1 = [k1];
    } else if (k1.limbs !== undefined) {
      k1 = k1.normalize().limbs;
    }
    
    if (typeof(k2) === "number") {
      k2 = [k2];
    } else if (k2.limbs !== undefined) {
      k2 = k2.normalize().limbs;
    }
    
    var i, j, out = new sjcl.ecc.point(this.curve).toJac(), m1 = affine.multiples(),
        m2 = affine2.multiples(), l1, l2;

    for (i=Math.max(k1.length,k2.length)-1; i>=0; i--) {
      l1 = k1[i] | 0;
      l2 = k2[i] | 0;
      for (j=sjcl.bn.prototype.radix-4; j>=0; j-=4) {
        out = out.doubl().doubl().doubl().doubl().add(m1[l1>>j & 0xF]).add(m2[l2>>j & 0xF]);
      }
    }
    
    return out;
  },
  
  isValid: function() {
    var z2 = this.z.square(), z4 = z2.square(), z6 = z4.mul(z2);
    return this.y.square().equals(
	    this.curve.b.mul(z6).add(this.x.mul(
	      this.curve.a.mul(z4).add(this.x.square()))));
  }
};

/**
 * Construct an elliptic curve. Most users will not use this and instead start with one of the NIST curves defined below.
 *
 * @constructor
 * @param {bigInt} p The prime modulus.
 * @param {bigInt} r The prime order of the curve.
 * @param {bigInt} a The constant a in the equation of the curve y^2 = x^3 + ax + b (for NIST curves, a is always -3).
 * @param {bigInt} x The x coordinate of a base point of the curve.
 * @param {bigInt} y The y coordinate of a base point of the curve.
 */
sjcl.ecc.curve = function(Field, r, a, b, x, y) {
  this.field = Field;
  this.r = Field.prototype.modulus.sub(r);
  this.a = new Field(a);
  this.b = new Field(b);
  this.G = new sjcl.ecc.point(this, new Field(x), new Field(y));
};

sjcl.ecc.curve.prototype.fromBits = function (bits) {
  var w = sjcl.bitArray, l = this.field.prototype.exponent + 7 & -8,
      p = new sjcl.ecc.point(this, this.field.fromBits(w.bitSlice(bits, 0, l)),
			    this.field.fromBits(w.bitSlice(bits, l, 2*l)));
  if (!p.isValid()) {										//modified to add alert in PassLok
  	alert("Invalid Lock");									//
    throw new sjcl.exception.corrupt("not on the curve!");	//
  }															//
  return p;
};

//Added the NIST 521-bit elliptic curve
sjcl.ecc.curves = {
	  c192: new sjcl.ecc.curve(
    sjcl.bn.prime.p192,
    "0x662107c8eb94364e4b2dd7ce",
    -3,
    "0x64210519e59c80e70fa7e9ab72243049feb8deecc146b9b1",
    "0x188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012",
    "0x07192b95ffc8da78631011ed6b24cdd573f977a11e794811"),

  c224: new sjcl.ecc.curve(
    sjcl.bn.prime.p224,
    "0xe95c1f470fc1ec22d6baa3a3d5c4",
    -3,
    "0xb4050a850c04b3abf54132565044b0b7d7bfd8ba270b39432355ffb4",
    "0xb70e0cbd6bb4bf7f321390b94a03c1d356c21122343280d6115c1d21",
    "0xbd376388b5f723fb4c22dfe6cd4375a05a07476444d5819985007e34"),

  c256: new sjcl.ecc.curve(
    sjcl.bn.prime.p256,
    "0x4319055358e8617b0c46353d039cdaae",
    -3,
    "0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b",
    "0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296",
    "0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"),

  c384: new sjcl.ecc.curve(
    sjcl.bn.prime.p384,
    "0x389cb27e0bc8d21fa7e5f24cb74f58851313e696333ad68c",
    -3,
    "0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef",
    "0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7",
    "0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f"),

  c521: new sjcl.ecc.curve(				//these parameters are my addition to ecc.js
	sjcl.bn.prime.p521,
	"0x5AE79787C40D069948033FEB708F65A2FC44A36477663B851449048E16EC79BF6",
	- 3,
"0x051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00",
"0xc6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66",
"0x11839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650")
};

//End of SJCL code, some of its elGamal, ECDSA code is used in the functions below 

//Now the ORIGINAL PASSLOK CODE BEGINS

//if key box is empty, this displays a random Key in the top box and its Lock in the bottom box, otherwise display Lock or combine Lock and Key
function fillkeys(){
	var plainstr = document.plain.text.value.split("=").sort(function (a, b) { return b.length - a.length; })[0];   //remove end tags in box 2
	plainstr = plainstr.replace(/\s/g,'');										//remove also spaces
	if(!(plainstr==="") && !(plainstr.length===87)){
		var reply = confirm("Box 2 is not empty. It will be modified if you proceed");
		if(reply===false) throw("boxes not empty");
	};
	var secstr = document.sec.text.value.trim();			//cut trailing spaces
	if(secstr===""){										//box 1 empty, make Random key and Lock
		if (document.getElementById("learnmode").checked === true){
			var reply2 = confirm("A random Key will be placed in box 1 and its Lock in box 2. Cancel if this is not what you want.");
			if(reply2===false) throw("random canceled");
		};
		document.sec.text.value = sjcl.codec.base64.fromBits(sjcl.random.randomWords('17','0')).slice(0,85);   //make it 85 characters long so it can be distinguished from a shared key, which is 86
		showpub();
		throw("new random key");
	};	
	if (plainstr.length===87){								//if it's a Lock in box 2, merge it with the secret Key
		if (document.getElementById("learnmode").checked === true){
			var reply3 = confirm("The Lock in box 2 will be combined with the key in box 1, and the resulting Key will be placed in box 1. Box 2 will be erased. Cancel if this is not what you want.");
			if(reply3===false) throw("merge canceled");
		};
		showshared();
		throw ("it was a lock, merged with key");
	} else {												//replace box 2 with Lock made from box 1
		if (document.getElementById("learnmode").checked === true){
			var reply4 = confirm("The Lock matching the Key in box 1 will be placed in box 2, replacing its contents. Cancel if this is not what you want.");
			if(reply4===false) throw("lock canceled");
		};
		showpub();
	};	
};

//display the public part, in case it got deleted
function showpub(){
	var secstr = document.sec.text.value.trim();
	var pubstr = secstr.replace(/\s/g,'');			//ignore spaces
		pubstr = pubstr.split("=").sort(function (a, b) { return b.length - a.length; })[0];		//remove tags
		pubstr = pubstr.replace(/[^a-zA-Z0-9+/ ]+/g, ''); 					//takes out anything that is not base64
		if (pubstr.length===87){
			var reply = confirm("Box 1 may contain a Lock. Are you sure you want to make a Lock for it?");
			if(reply===false) throw("lock canceled");
		};
	var pubstr = makepub(secstr);
	document.plain.text.value = "PL13lok=" + pubstr + "=PL13lok";
};

//makes the public string of a private string
function makepub(secstr){
	if (secstr === ""){
		alert("Write your secret Key in box 1");
		throw("secret key empty");
	};
	var curve = sjcl.ecc.curves["c521"],					//make curve object
		sec = toexponent(secstr),							//retrieve secret key, correctly formatted as an EC exponent
	    pub = curve.G.mult(sec),							//make public key
		pubstr = sjcl.codec.base64.fromBits(pub.toBits());
	return pubstr.slice(1,88)								//strip initial "A", only x part
};

//key reformatting and stretching for secret key (shared key is formatted automatically by sjcl) for 521 bit keys
function toexponent(string){
	var iter = passwordChanged();			//get number of iterations from key strength meter
	var w = sjcl.bitArray;
	return sjcl.bn.fromBits(w.bitSlice(sjcl.misc.pbkdf2(string,"",iter,528)));	//use no salt, iteration number variable according to key strength, 528 bits
};

//display shared secret made from secret and public keys 
function showshared(){
	var secstr = document.sec.text.value.trim(),
		pubstr = document.plain.text.value.replace(/\s/g,'');			//ignore spaces in public key
		pubstr = pubstr.split("=").sort(function (a, b) { return b.length - a.length; })[0];		//remove tags
		pubstr = pubstr.replace(/[^a-zA-Z0-9+/ ]+/g, ''); 					//takes out anything that is not base64
	if (secstr === ""){
		alert("Write your secret Key in box 1");
		throw("secret key empty");
	};
	if (pubstr === ""){
		alert("Write the other person's Lock into box 2"); 
		throw("public key empty");
	};
		pubstr = "A" + pubstr;										//add inital "A" before calculation
	document.sec.text.value = makeshared(secstr,pubstr);
	document.plain.text.value = "";
};

//this one makes the shared secret
function makeshared(secstr,xstr){
	var curve = sjcl.ecc.curves["c521"],
		sec = toexponent(secstr),
		ystr = yfromx(curve,xstr),				      				//retrieve y coordinate from x coordinate
		pub = curve.fromBits(sjcl.codec.base64.toBits(xstr+ystr)),  //make public key object containing both x and y
		sharedsec = pub.mult(sec),
		sharedstr = sjcl.codec.base64.fromBits(sharedsec.toBits());
	return sharedstr.slice(2,88)  									//strip initial "A", only x part. Strip also 2nd char so it's not mistaken for a lock
};

function yfromx(curve,xstr){
	var x = sjcl.bn.fromBits(sjcl.codec.base64.toBits(xstr)),   //the following to retrieve y coordinate from x coordinate
		y = curve.b.add(x.mul(curve.a.add(x.square())));		//this is actually y^2, square root by special case of Tonelli-Shanks follows
	var i;
	for (i=0; i<519; i++) {
  		y = y.square();											//performs y^((p+1)/4), since p = 2^521 - 1, (p=1)/4=2^519, all is mod p
		};
	return sjcl.codec.base64.fromBits(y.toBits());
};

//display a hash of the textarea for authentication purposes
function makehash(){
	if (document.getElementById("learnmode").checked === true){
			var reply = confirm("The content of box 2 will be replaced with its ID. This is irreversible. Cancel if this is not what you want.");
			if(reply===false) throw("ID canceled");
		};
	var mine = document.plain.text.value.trim();		//remove spaces at start and end
	if (mine.length < 215){								//if it's a key or fits in decoy msg remove spaces, tags and anything that is not base64
		mine = mine.replace(/\s/g,'');
		mine = mine.split("=").sort(function (a, b) { return b.length - a.length; })[0];  
		mine = mine.replace(/[^a-zA-Z0-9+/ ]+/g, '');
	};
	if(mine === "") {
		alert("Nothing to make an ID of");
		throw("textarea empty");
	};
	mine = sjcl.codec.hex.fromBits(sjcl.hash.sha256.hash(mine)).match(/.{1,4}/g).join("-"); //take hash, make it hex, cut into 4-char pieces and join with dashes
	document.plain.text.value = mine;
};

//AES encryption process: determines which kind of encryption by looking at which key boxes are filled
function Encrypt_text(){
	var iv = sjcl.codec.base64.fromBits(sjcl.random.randomWords('4','0')),					//22 char serial
		salt = "";
	var secstr = document.sec.text.value.trim();
	var pubstr = secstr;
		pubstr = pubstr.replace(/\s/g,'');															//remove spaces
		pubstr = pubstr.split("=").sort(function (a, b) { return b.length - a.length; })[0];		//remove tags									
		pubstr = pubstr.replace(/[^a-zA-Z0-9+/ ]+/g, ''); 					//takes out anything that is not base64	
	if (pubstr.length === 87){										//if it's a public key = lock mode
		if (document.getElementById("learnmode").checked === true){
			var reply = confirm("The contents of box 2 will be locked with the Lock in box 1 and the result will be placed in box 2. This is irreversible. Cancel if this is not what you want.");
			if(reply===false) throw("public encryption canceled");
		};
		var secstrdum = sjcl.codec.base64.fromBits(sjcl.random.randomWords('17','0')).slice(0,87),	//make dummy key
			pubstrdum = makepub(secstrdum);							//makes 87 char dummy public key, initial A stripped	
			pubstr = "A" + pubstr;
		var keystr = makeshared(secstrdum,pubstr);					//make AES key from dummy secret and recipient's public key
		salt = makesalt(iv,87);
		var cipherj = JSON.parse(sjcl.encrypt(keystr,document.plain.text.value,{"iv":iv,"salt":salt,"ks":256,"iter": 10000}));    //use 256 bit keys, 10000x key stretching
		if (document.getElementById("learnmode").checked === true){
				alert("The recipent will need to place his/her secret Key in box 1 to unlock the message in box 2.");
			};
		document.plain.text.value = "PL13msl=!" + cipherj.iv + cipherj.salt + pubstrdum + cipherj.ct + "=PL13msl";			//display adding dummy public key and anonymous tags
	} else {														//not a public key
		if (secstr === ""){											//nothing in box = short  mode			
			if (document.getElementById("learnmode").checked === true){
				var reply2 = confirm("The first 57 characters of box 2 will be locked with a key that will be entered in a popup. The result will replace box 2. Cancel if this is not what you want.");
				if(reply2===false) throw("short encryption canceled");
			};
			iv = sjcl.codec.base64.fromBits(sjcl.random.randomWords('2','0'));		//smaller salt
			var keystr = "";
			while (keystr==="") keystr = prompt("Short Message Key");		//empty key not allowed
			salt = makesalt(iv,38);
			var text = encodeURI(document.plain.text.value).replace(/%20/g, ' ');
			text = text + "                                                         ";   //clip or add spaces to make a 57 char message 
			text = text.slice(0,57);
			var cipherj = JSON.parse(sjcl.encrypt(keystr,text,{"iv":iv,"salt":salt,"ks":256,"iter": 10000}));
			document.plain.text.value = cipherj.iv + cipherj.salt + cipherj.ct;
		} else {												//symmetric encryption
			if (document.getElementById("learnmode").checked === true){
				var reply3 = confirm("The contents of box 2 will be locked with the secret Key in box 1, and the result will replace box 2. Cancel if this is not what you want.");
				if(reply3===false) throw("sym encryption canceled");
			};
			salt = makesalt(iv,152);
			var cipherj = JSON.parse(sjcl.encrypt(secstr,document.plain.text.value,{"iv":iv,"salt":salt,"ks":256,"iter": 10000}));
			if(secstr.length===86){								//if shared Key, use a different tag
			if (document.getElementById("learnmode").checked === true){
				alert("The recipent will need your Lock and his/her secret Key to unlock the message in box 2.");
			};
			document.plain.text.value = "PL13mss=#" + cipherj.iv + cipherj.salt + cipherj.ct + "=PL13mss"
			}else{
			if (document.getElementById("learnmode").checked === true){
				alert("The recipent will need to place the same Key in box 1 to unlock the message in box 2.");
			};	
			document.plain.text.value = "PL13msk=@" + cipherj.iv + cipherj.salt + cipherj.ct + "=PL13msk"
			}
		}
	}
};

//encrypts a hidden message into the salt value used by regular encryption, or makes a random salt also encoded by AES so it's indistinguishable
function makesalt(iv,leng){
	if (document.getElementById("decoymode").checked === false){				//no decoy mode, so salt comes from random text and key, no stretching
		var key = sjcl.codec.base64.fromBits(sjcl.random.randomWords('8','0')),
			text = sjcl.codec.base64.fromBits(sjcl.random.randomWords('57','0')).slice(0,214),
			iter = 101;														//minimum allowed
	} else {
		if (document.getElementById("learnmode").checked === true){
			var reply = confirm("You are adding a hidden message in Decoy mode. Cancel if this is not what you want.Then uncheck Decoy mode below.");
			if(reply===false) throw("decoy encryption canceled");
		};
		var	key = prompt("Enter Decoy Password"),								//key from prompt, spaces allowed, empty key allowed	
			text = encodeURI(prompt("Enter hidden message").replace(/%20/g, ' ')),	//make it ASCII, preserve spaces
			iter = 10000;															//key may be weak, so stretch it
	};
	while (text.length < leng) {										//clip or add spaces to make the number of characters required
			text = text + "          ";
		};
		text = text.slice(0,leng);
		var cipherj = JSON.parse(sjcl.encrypt(key,text,{"iv":iv,"salt":"","ks":256,"iter":iter}));
		return cipherj.ct;
};

//AES decryption process: determines which kind of encryption by looking at first character after the initial tag. Calls Encrypt_text or showpub as appropriate
function Decrypt_text(){
	var cipherstr = document.plain.text.value.trim(),
		secstr = document.sec.text.value.trim();
	if (cipherstr===""){							//if box 2 is empty, display a warning
		alert("Nothing to lock/unlock");
		throw("box 2 empty");
	};
	cipherstr = cipherstr.split("=").sort(function (a, b) { return b.length - a.length; })[0];   //remove end tags
	var type = cipherstr.slice(0,1);									//get encryption type. !=public, @=symmetric, #=stamped
	cipherstr = cipherstr.replace(/[^a-zA-Z0-9+/ ]+/g, '');				//remove anything that is not base64
	if (type === "!"){									//public decryption
		if (document.getElementById("learnmode").checked === true){
			var reply = confirm("The message in box 2 was locked with your personal Lock, and will now be unlocked if your secret Key is in box 1, replacing the locked message. Cancel if this is not what you want.");
			if(reply===false) throw("public decryption canceled");
		};
		var	iv = cipherstr.slice(0,22),									//get iv, salt, and later ct data and public key
			salt = cipherstr.slice(22,149);			
		if (document.getElementById("decoymode").checked === true) decoydecrypt(iv,salt); 	//do decoy decryption first, in case regular fails
		if (secstr === ""){
			alert("Enter your secret Key in box 1");
			throw("secret key empty");
		} else{
			var pubstr = secstr.split("=").sort(function (a, b) { return b.length - a.length; })[0];		//check that this isn't a lock
				pubstr = pubstr.replace(/[^a-zA-Z0-9+/ ]+/g, '').replace(/\s/g,'');
			if (pubstr.length === 87){
				alert("Box 1 contains a Lock. Enter your secret Key in box 1");
				throw("secret key empty");
			};
		};
		var pubstrdum = cipherstr.slice(149,236);			
		pubstrdum = "A" + pubstrdum;
		var keystr = makeshared(secstr,pubstrdum);
		var	ct = cipherstr.slice(236,cipherstr.length);
		cipherstr = '{"iv":"' + iv + '","salt":"' + salt + '","ct":"' + ct + '","ks":256,"iter":10000}';	//add labels and keylength to data
		document.plain.text.value = sjcl.decrypt(keystr,cipherstr);
	}
	else if ((type === "@") || (type === "#")){			//symmetric decryption
		if (document.getElementById("learnmode").checked === true){
			var reply2 = confirm("The message box 2 was locked with a Key, and will now be unlocked if the same Key is in box 1, replacing the locked message. Cancel if this is not what you want.");
			if(reply2===false) throw("sym decryption canceled");
		};
		var	iv = cipherstr.slice(0,22),
			salt = cipherstr.slice(22,236);
		if (document.getElementById("decoymode").checked === true) decoydecrypt(iv,salt);
		var keystr = secstr;
		if ((type === "#") && !(keystr.length === 86)){
			alert("This is a stamped message. Make first the special shared Key by putting your personal Key in box 1, the sender's Lock in box 2, and clicking Make Lock.");
			throw("need a shared key");
		};
		if (keystr === ""){
			alert("Enter shared Key in box 1");
			throw("secret key empty");
		};
		var	ct = cipherstr.slice(236,cipherstr.length);
		cipherstr = '{"iv":"' + iv + '","salt":"' + salt + '","ct":"' + ct + '","ks":256,"iter":10000}';
		document.plain.text.value = sjcl.decrypt(keystr,cipherstr);
	} 
	else if (cipherstr.length===160){					//short decryption, no tags
		if (document.getElementById("learnmode").checked === true){
			var reply3 = confirm("Box 2 contains a short locked message, which was locked with a Short Message Key. If you supply the same Key when prompted, the unlocked message will replace what is in box 2. Cancel if this is not what you want.");
			if(reply3===false) throw("short decryption canceled");
		};
		var	iv = cipherstr.slice(0,11),
			salt = cipherstr.slice(11,73),
			keystr = prompt("Short Message Key");
		if (document.getElementById("decoymode").checked === true) decoydecrypt(iv,salt);
		var	ct = cipherstr.slice(73,cipherstr.length);
		cipherstr = '{"iv":"' + iv + '","salt":"' + salt + '","ct":"' + ct + '","ks":256,"iter":10000}';
		document.plain.text.value = decodeURI(sjcl.decrypt(keystr,cipherstr));
	}
	else{
		Encrypt_text()									//none of the known tagged types, therefore encrypt rather than decrypt
	};
};

//decrypt the message hidden in the salt, for decoy mode
function decoydecrypt(iv,ct){
		if (document.getElementById("learnmode").checked === true){
			var	key2 = prompt("Decoy mode is selected, so please write the Password used to lock the hidden message. If you don't expect a hidden message, uncheck Decoy mode below.");
		} else {
			var	key2 = prompt("Enter Decoy Password");
		};
		var	cipherstr2 = '{"iv":"' + iv + '","salt":"' + "" + '","ct":"' + ct + '","ks":256,"iter":10000}';
		alert("Hidden message: " + decodeURI(sjcl.decrypt(key2,cipherstr2)))
};

//takes a hash of the plaintext and generates an ECDSA signature
function Signhash(){
	var secstr = document.sec.text.value.trim();
	if (document.getElementById("learnmode").checked === true){
		var reply = confirm("A stamp matching the contents of box 2 will be made using your secret Key in box 1, and the resulting stamp will be added to the end of box 2. Cancel if this is not what you want.");
		if(reply===false) throw("stamp canceled");
	};
	if (secstr===""){
		alert("Enter your Key in box 1");
		throw("secret key empty")
	};
	var pubstr = secstr.replace(/\s/g,'');
		pubstr = pubstr.split("=").sort(function (a, b) { return b.length - a.length; })[0];				
		pubstr = pubstr.replace(/[^a-zA-Z0-9+/ ]+/g, '');
	if (pubstr.length===87){											//this is a Lock, not a Key
		alert("Lock found in box 1. Enter your secret Key instead");
		throw("lock instead of key")
	};
	var hash = sjcl.hash.sha512.hash(document.plain.text.value.trim()),						//take SHA512 hash of plaintext, trimming space at ends
		sec = toexponent(secstr),
		curve = sjcl.ecc.curves["c521"],
		R = curve.r,
		l = R.bitLength(),
    	k = sjcl.bn.random(R.sub(1), 0).add(1),
    	r = curve.G.mult(k).x.mod(R),
		s = sjcl.bn.fromBits(hash).add(r.mul(sec)).mul(k.inverseMod(R)).mod(R),
		sigstr = sjcl.codec.base64.fromBits(sjcl.bitArray.concat(r.toBits(l), s.toBits(l)));	//make it base64
	var iv = sjcl.codec.base64.fromBits(sjcl.random.randomWords('2','0')),						//for hidden message, if activated
		padding = makesalt(iv,40);
	document.plain.text.value = document.plain.text.value + "\n\n" + "PL13stp=" + sigstr.slice(1,sigstr.length) + iv.slice(0,11) + padding + "=PL13stp";	//strip initial "A" and add decoy iv & padding and tags
};	

//verifies the ECDSA signature of a hash of the plaintext, calls Signhash as appropriate. Algorithm from SJCL ecc.js, but not the latest version
function Verifyhash(){
	var	pubstr = document.sec.text.value.trim();
	if (pubstr===""){											//nothing in sec box
		alert("No Key or Lock in box 1");
		throw("no key present")
	};
	var text = document.plain.text.value.trim();
	if (text===""){												//nothing in text box
		alert("Nothing to stamp/verify");
		throw("no text")
	};
	var	stamp = text.split(/\r?\n/);
		stamp = stamp[stamp.length-1];							//this is a stamp if added as last line of text
	var	sigstr = stamp.replace(/\s/g,'');
	if (!(sigstr.slice(4,8)==="stp=")){							//no stamp tag, therefore making stamp
		Signhash();
		throw("no stamp, creating one")
	};
	if (document.getElementById("learnmode").checked === true){
		var reply = confirm("The text in box 2 has been stamped with somebody's secret Key. I will now verify if the stamp is correct for this text and the matching Lock, which should be present in box 1, and will display the result in a popup. Cancel if this is not what you want.");
		if(reply===false) throw("stamp verification canceled");
	};
		sigstr = sigstr.split("=").sort(function (a, b) { return b.length - a.length; })[0];			
		sigstr = sigstr.replace(/[^a-zA-Z0-9+/ ]+/g, '');
	if (!(sigstr.length===250)){
		alert("Invalid Stamp");
		throw("invalid stamp")
	};		
		pubstr = pubstr.replace(/\s/g,'');
		pubstr = pubstr.split("=").sort(function (a, b) { return b.length - a.length; })[0];	//remove tags
		pubstr = pubstr.replace(/[^a-zA-Z0-9+/ ]+/g, ''); 
	if (pubstr===""){
		alert("Enter the signer's Lock in box 1");
		throw("public key empty")
	};
	if (!(pubstr.length===87)){
		alert("Invalid signer's Lock in box 1");
		throw("invalid public key")
	};
		text = text.replace(/\r?\n?[^\r\n]*$/, "");						//remove last line
	var hash = sjcl.hash.sha512.hash(text.trim()),						//take SHA512 hash of plaintext, ignoring spaces			
		curve = sjcl.ecc.curves["c521"],
		xstr = "A" + pubstr.slice(0,pubstr.length),
		ystr = yfromx(curve,xstr),
	 	pub = curve.fromBits(sjcl.codec.base64.toBits(xstr+ystr)),
		rs = sjcl.codec.base64.toBits("A" + sigstr.slice(0,175)),		//recover signature part
		w = sjcl.bitArray,
        R = curve.r,
        l = R.bitLength(),
        r = sjcl.bn.fromBits(w.bitSlice(rs,0,l)),
        s = sjcl.bn.fromBits(w.bitSlice(rs,l,2*l)),
		u = s.inverseMod(R),	
        hG = sjcl.bn.fromBits(hash).mul(u).mod(R),	
        hA = r.mul(u).mod(R),
		check = true,	
		r2 = curve.G.mult2(hG, hA, pub).x.mod(R);
		if (!r2.equals(r)){													//hack from when y is the wrong root of y^2
			var y = sjcl.bn.fromBits(sjcl.codec.base64.toBits(ystr)),
				p = curve.field.modulus.copy(),
				y2 = p.sub(y),												//this should be the right y
				ystr2 = sjcl.codec.base64.fromBits(y2.toBits());		
			pub = curve.fromBits(sjcl.codec.base64.toBits(xstr+ystr2));
			r2 = curve.G.mult2(hG, hA, pub).x.mod(R);
		};																	//end of wrong root hack
    if (r.equals(0) || s.equals(0) || r.greaterEquals(R) || s.greaterEquals(R) || !r2.equals(r)) check = false;
	if (check) {
		alert("The stamp is VERIFIED")
		}
	else {
		alert("The stamp has FAILED verification")
		};
	if (document.getElementById("decoymode").checked === true){				//this part to extract the hidden message, if it exists
		var iv = sigstr.slice(175,186),
			padding = sigstr.slice(186,250);
		decoydecrypt(iv, padding);
	};
};

//add entropy as forms are manipulated
function ce() {
	sjcl.random.addEntropy(Math.floor((((new Date).getMilliseconds()) * 255) / 999), 2, "loadtime");
};

<!-- Text hide trick, by Sandeep Gangadharan 2005-->
if (document.getElementById) {
 document.writeln('<style type="text/css"><!--')
 document.writeln('.texter {display:none} @media print {.texter {display:block;}}')
 document.writeln('//--></style>') }

function openClose(theID) {
 if (document.getElementById(theID).style.display === "block") { document.getElementById(theID).style.display = "none" }
 else { document.getElementById(theID).style.display = "block" } };
// end of hide trick

//this is for showing and hiding text in secret input fields
function showsec(){
  var showPasswordCheckBox = document.getElementById("show");
  if(showPasswordCheckBox.checked){
        document.getElementById("pwd").type="TEXT";
  }else{
      document.getElementById("pwd").type="PASSWORD";
  }
};

//function to test password strength
function passwordChanged() {
var iter = 200000;
var strength = document.getElementById("strength");
var perfectRegex = new RegExp("^(?=.{9,})(?=.*[A-Z])(?=.*[a-z])(?=.*[0-9])(?=.*[^a-zA-Z0-9_@.])(?=.*[@])(?=.*[.]).*$", "g");
var strongRegex = new RegExp("^(?=.{9,})(?=.*[A-Z])(?=.*[a-z])(?=.*[0-9])(?=.*[^a-zA-Z0-9_@.]).*$", "g");
var mediumRegex = new RegExp("^(?=.{8,})(((?=.*[A-Z])(?=.*[a-z]))|((?=.*[A-Z])(?=.*[0-9]))|((?=.*[a-z])(?=.*[0-9])))(?=.*[@])(?=.*[.]).*$", "g");
var adequateRegex = new RegExp("^(?=.{8,})(((?=.*[A-Z])(?=.*[a-z]))|((?=.*[A-Z])(?=.*[0-9]))|((?=.*[a-z])(?=.*[0-9]))).*$", "g");
var enoughRegex = new RegExp("(?=.{7,}).*", "g");
var pwd = document.getElementById("pwd").value;
	pwd = pwd.replace(/^\d+/,'').replace(/\d+$/,'');		//no credit for initial and trailing numbers
	pwd = pwd.replace(/^[a-zA-Z]/,'');						//no credit for initial letter, small or capital
	pwd = pwd.replace(/[@.]+$/,'');							//no credit for one or more @ or . at the end (no real email)
if (pwd.length==0) {
strength.innerHTML = "&nbsp";
} else if (false === enoughRegex.test(pwd)) {
strength.innerHTML = '<span style="color:black"> Terrible!</span>';	//less than 7 good characters
iter = 200000;
} else if (perfectRegex.test(pwd)) {
strength.innerHTML = '<span style="color:cyan">  Perfect!</span>';	//lowercase, caps, numbers, sp chars, and @ . (email)
iter = 1;
} else if (strongRegex.test(pwd)) {
strength.innerHTML = '<span style="color:green">  Very Good</span>';	//lowercase, caps, numbers, and sp chars (not @), but no email
iter = 1;
} else if (mediumRegex.test(pwd)) {
strength.innerHTML = '<span style="color:orange">  Good</span>';	//either two of lowercase, caps, numbers, plus @. (email)
iter = 10000;
} else if (adequateRegex.test(pwd)) {
strength.innerHTML = '<span style="color:magenta">  Adequate</span>';	//either two of lowercase, caps, numbers, but no email
iter = 10000;
} else {
strength.innerHTML = '<span style="color:red">  Weak!</span>';		//just one kind of characters
iter = 50000;
};
return iter
};

//formats results depending on tags present and sends to defaul email
function sendMail() {
	if (document.getElementById("learnmode").checked === true){
		var reply = confirm("A new tab will open, including the contents of box 2 in your default email. You still need to supply the recipient's address and a title. Only Locks and locked or stamped text are allowed. Cancel if this is not what you want.");
		if(reply===false) throw("email canceled");
	};
	var cipherstr = document.plain.text.value;
	cipherstr = cipherstr.split("=").sort(function (a, b) { return b.length - a.length; })[0];
	var type = cipherstr.slice(0,1);
	if(type==="!"){
    	var link = "mailto:"+ "?subject=" + "&body=Message locked with PassLok v.1.3 %0D%0A%0D%0AUnlock with your secret Key. %0D%0A%0D%0A" + encodeURIComponent(document.plain.text.value) + "%0D%0A%0D%0AGet PassLok at http://passlok.com";
	} else if (type==="@"){
		var link = "mailto:"+ "?subject=" + "&body=Message locked with PassLok v.1.3 %0D%0A%0D%0AUnlock with shared Key. %0D%0A%0D%0A" + encodeURIComponent(document.plain.text.value) + "%0D%0A%0D%0AGet PassLok at http://passlok.com";
	} else if (type==="#"){
		var link = "mailto:"+ "?subject=" + "&body=Message locked with PassLok v.1.3 %0D%0A%0D%0AUnlock with your secret Key and the sender's Lock. %0D%0A%0D%0A" + encodeURIComponent(document.plain.text.value) + "%0D%0A%0D%0AGet PassLok at http://passlok.com";
	} else if (cipherstr.length===87){
		var link = "mailto:"+ "?subject=" + "&body=This is my PassLok v.1.3 Lock, use it to send me messages and verify my Stamp. %0D%0A%0D%0A" + encodeURIComponent(document.plain.text.value) +"%0D%0A%0D%0AGet PassLok at http://passlok.com";
	} else if (cipherstr.length===250){
		var link = "mailto:"+ "?subject=" + "&body=The following is a text stamped with PassLok v.1.3. Verify using the signer's Lock.%0D%0A%0D%0AGet PassLok at http://passlok.com%0D%0A%0D%0AThe text, followed by the Stamp,  BEGINS BELOW THIS LINE:%0D%0A%0D%0A" + encodeURIComponent(document.plain.text.value);			
	} else if (cipherstr.length===160){
		var link = "mailto:"+ "?subject=" + "&body=Short message locked with PassLok v.1.3 %0D%0A%0D%0AStrip everything but the locked message and unlock with Short Message Key.%0D%0A%0D%0A" + encodeURIComponent(document.plain.text.value) + "%0D%0A%0D%0AGet PassLok at http://passlok.com";
	} else{ 
		alert("Only Locks, and locked or stamped text are allowed for Email");
		throw("illegal text")
	};
	if(typeof window.orientation !== 'undefined'){ 	 		//new window for PC, same for mobile
		window.open(link,"_parent")
	} else {
		window.open(link,"_blank")
	};
};

//calls SMS app (works on mobile only)
function sendSMS() {
	if (document.getElementById("learnmode").checked === true){
		var reply = confirm("The default SMS (texting) app will now open. You need to have copied your short locked message (no Key in box 1) to the clipboard before this, if you want to send one. This only works in smartphones. Cancel if this is not what you want.");
		if(reply===false) throw("SMS canceled");
	};
	if(typeof window.orientation !== 'undefined') window.open("SMS:","_parent");
};

function selectPlain(){
	document.plain.text.selectionStart=0;
	document.plain.text.selectionEnd=document.plain.text.value.length;
};

function displayhelp(){
	window.open("help13.html","_blank")
};

function makeQRcode(){
	if (document.getElementById("learnmode").checked === true){
		var reply = confirm("A QR code for the contents of box 2 will be displayed below. Cancel if this is not what you want.");
		if(reply===false) throw("QR code canceled");
	};
	qrcode.makeCode(document.plain.text.value)
};

//The main script ends here. Some QR functions are in the body, near the end.
</script>
		
		<style type="text/css">
		<!--
.texter {display:none;font-size:small;} @media print {.texter {display:block;font-size:small;}}
//-->
		</style>
		<style type="text/css">
		.style3 {font-size: small}
        </style></head>
  
  <body link="#0000ff" vlink="#0000ff" alink="#0000ff" onload="ce();">
<h2 align="center">PassLok privacy</h2>
    <hr style="background-color: rgb(192, 192, 192); color: #000000;">	
  <form name="warning" action="#" onsubmit="return false;"><p align="center">
<input type="text" name="warning"
    style="background-color: #FFA0A0; color: #000000;width: 96%; font-size: small;"
    value="Your browser DOES NOT support JavaScript or it's off."
    class="ctr" readonly="readonly" /></p>
</form>
</center>

<script type="text/javascript" language="JavaScript">
	sjcl.random.startCollectors();		//start SJCL's built-in entropy collectors
<!--
    //  Clear out "sorry, no JavaScript" message from text box.
    document.warning.warning.value = "To show/hide instructions for each box, click on titles with an arrow";
    document.warning.warning.style.backgroundColor = "rgb(230, 255, 230)";
// -->
</script>
      <p class="style3" align="center">Click  
        <input type="button" onclick="displayhelp();" onBlur="ce();" onFocus="ce();" value="Help" style="background-color: #EEE; font-size: medium;"/> 
        for help and self-ID</p>
        <div onClick="openClose('a0')" style="cursor:hand; cursor:pointer">
       <p class="style3" align="center">Check this for Learn mode &#9660  <input type="checkbox" id="learnmode" onBlur="ce();" onFocus="ce();"></p></div>
       <div id="a0" class="texter" style="display: none;">
      	<p align="center">If you check Learn mode, popups will appear every time you press a button, explaining what is about to happen. You will have the opportunity to cancel it.</p></div>
    <form onsubmit="return false;" id="sec" name="sec">
      <label for="sec">

      <div onClick="openClose('a1')" style="cursor:hand; cursor:pointer">
        <h3><b>1. Key / Lock &#9660;</b></h3>
      </div>
      <div id="a1" class="texter" style="display: none;">
      	<p>Write your personal or shared Key, or the recipient's or signer's Lock in box 1. To display the characters, check Show. As you type your Key, a text below will tell you the strength of the Key based on simple rules. Make sure to <strong>use $ymbol$, numb3rs, caPiTals, unusual words and mispelingss.</strong> Initial capitals and trailing numbers are not helpful and will be ignored for the strength score. It is strongly encouraged to <strong>append your email to the Key.</strong> The strength meter won't show a Perfect score otherwise.</p>
        <p>You will need to enter a Key to unlock or stamp messages. To send a short locked message, leave this box empty.</p>
        <p>To display the Lock matching a Key, place the Key in box 1, click the Make Lock button. The Lock will appear in box 2. You can then email it by clicking Email.</p>
        <p>To make a shared Key from your personal Key and someone's Lock, place your Key in box 1 and the Lock in box 2, then click Make Lock.</p>
		<p>To put a random Key in box 1 and its corresponding Lock in box 2, click Make Lock with box 1 empty.</p> 
      </div>
       </label>	
      <span id="strength"></span>
		<p align="center">
        <input type="password" autocomplete="off" id="pwd" onKeyDown="ce();" onKeyUp="return passwordChanged();" onBlur="ce();" onFocus="ce();" style="background-color: rgb(255, 255, 240); color: #000000; width: 96%; font-size: medium;" cols="36" name="text"></p>
	  <div align="center">
      	<input type="checkbox" id="show" onClick="showsec();" onBlur="ce();" onFocus="ce();"> Show
	    <input type="button" onclick="fillkeys();" onBlur="ce();" onFocus="ce();" value="Make Lock" style="background-color: #EEE; font-size: medium;"/>
	    <input type="button" onClick="passwordChanged();document.sec.text.value = ''" onBlur="ce();" onFocus="ce();" value="Clear" style="background-color: #EEE; font-size: medium;">
      </div>
    </form>
	<p></p>
    <form onSubmit="return false;" id="plain" name="plain">
      <label for="plain">
      <div onClick="openClose('a3')" style="cursor:hand; cursor:pointer">
        <h3><b>2. Text &#9660;</b></h3>
      </div>
 <div id="a3" class="texter">
   <p>This is where you write the text to be locked, stamped or unlocked. Locks matching the Key in box 1 also appear here. The process to make Locks and shared Keys is described above.</p>
   <p>To lock a text, enter it into box 2 below. Write a shared Key or the recipient's Lock in box 1, depending on the type of locking you want. Then click the Lock/Unlock button. The locked text will appear in box 2, replacing the original text. You can then email it or text it using the buttons above box 2.</p>
        <p>If box 1 is empty when you click Lock/Unlock, a prompt will ask for a Short Message Key (message length limited to 57 ASCII characters, non-ASCII characters use 6 spaces each, so avoid using accents, umlauts, etc.).</p>
        <p>To unlock a locked text, place your personal or shared Key in box 1, with the locked text in box 2, then click Lock/Unlock. If you have the wrong item in box 1, a popup will tell you.</p>
   <p>To stamp a text with your personal Key, first make sure your Key is in box 1 above, then enter into box 2 below the text to be signed and click Stamp/Verify. The Stamp will be appended to the text. This can also be emailed with the Email button.</p>
   <p>To verify a stamped text, place the text carrying the Stamp at the end in box 2 below, and the signer's Lock in box 1 above, then click Stamp/Verify. A popup will say whether or not the Stamp is verified for this text and this signer.</p>
	<p>The Email button places the contents of box 2 in a formatted email, using the default client. The SMS App button opens your default messaging app; you need to copy the message into the clipboard before clicking the button. The QR button makes a QR code of whatever is in box 2 and displays it at the bottom of this page. This is useful to exchange information between mobile devices. Be aware that smartphones have trouble reading codes longer than 500 characters. The ID button replaces the content of box 2 with its SHA256 hash. This is useful for authentication purposes.</p>
 </div>
      </label>
      <div align="center"> <input type="button" onClick="sendMail();" onBlur="ce();" onFocus="ce();" value="Email" style="background-color: #EEE; font-size: medium;">
	  <input type="button" onClick="sendSMS();" onBlur="ce();" onFocus="ce();" value="SMS" style="background-color: #EEE; font-size: medium;">
	  <input type="button" onClick="makeQRcode();" onBlur="ce();" onFocus="ce();" value="QR" style="background-color: #EEE; font-size: medium;">
	  <input type="button" onClick="makehash();" onBlur="ce();" onFocus="ce();" value="ID" style="background-color: #EEE; font-size: medium;">
      <textarea onKeyDown="ce();" onBlur="ce();" onFocus="ce();" style="background-color: rgb(255, 255, 240); color: #000000; width: 96%; font-size: medium;" cols="24" rows="10" name="text"></textarea>
	<br>
      <input type="button" onClick="Decrypt_text();" onBlur="ce();" onFocus="ce();" value="Lock/Unlock" name="decrypt" style="background-color: #EEE; font-size: medium;">
	  <input type="button" onClick="Verifyhash();" onBlur="ce();" onFocus="ce();" value="Stamp/Verify" style="background-color: #EEE; font-size: medium;">
	  <input type="button" onClick="selectPlain();" onBlur="ce();" onFocus="ce();" value=" Select " style="background-color: #EEE; font-size: medium;">
	  <input type="button" onClick="document.plain.text.value = '';" onBlur="ce();" onFocus="ce();" value=" Clear " style="background-color: #EEE; font-size: medium;">
      </div>
	  <p></p>
      <div onClick="openClose('a5')" style="cursor:hand; cursor:pointer"><label for="cipher">
	    <h3><b>Decoy mode &#9660;   <input type="checkbox" id="decoymode" onBlur="ce();" onFocus="ce();"></b></h3>
      </label></div>
	  <div id="a5" class="texter"><label for="cipher">
	    <p>By checking this mode you can include a second, hidden text locked by a separate Password. Popups will ask first for the Password for this text, and then for the text itself. The locked text in box 2 contains both texts. You can also use this mode when making a Stamp. The hidden text is limited to 152 ASCII characters for Key-locked text, 87 characters for text locked with the recipient's Lock, 38 characters for short message mode, 40 characters in Stamps. Non-ASCII characters use 6 spaces each, so avoid using accents, umlauts, etc.</p>
	      <p>When you unlock a text or verify a stamp in Decoy mode, a popup will ask for the special Password. The hidden text will appear in a second popup. </p>
      </label></div>
      <p></p>
    </form>
	<p></p>
    <hr>
<p></p>
    <div onClick="openClose('a6')" style="cursor:hand; cursor:pointer">
         <h3><b><address>
    PASSLOK v.1.3.03 &#169; <a href="http://prgomez.com/" target="_blank"> F. Ruiz</a> 2013 &#9660;
         </address>
             <address>
             </address>
         </b></h3>
  </div>
 <div id="a6" class="texter"> 
   <address>
   based on SJCL by <a href="http://crypto.stanford.edu/sjcl" target="_blank">Stark, Hamburg, and Boneh</a> 2012
   </address>
   <address> GUI inspired on jscrypt by <a href="http://www.fourmilab.ch/" target="_blank">John
        Walker</a> 2005 </address>
    <address>
    text hide trick by <a href="http://www.sivamdesign.com/scripts/" target="_blank">S. Gangadharan</a> 2005
    </address>
	<address>
    password strength meter by <a href="http://www.marketingtechblog.com/javascript-password-strength/" target="_blank">D. Karr</a> 2007
    </address>
	<address>
    QR funcions: qrcode.js by <a href="http://davidshimjs.github.io/qrcodejs/" target="_blank">K. Arase and David Shim</a> 2012
    </address>
 </div>
    <center> <em>This document may be used, modified or redistributed under GNU GPL license, version 3.0 or higher.</em> </center>
    <p></p>
    <hr>
	<p></p>
	<p></p>
<div align="center" id="qrcode" style="width:300px; height:300px; margin-top:15px; margin-bottom:15px; margin-left:10px; margin-right:10px;">
</div>
<script type="text/javascript">
var qrcode = new QRCode(document.getElementById("qrcode"), {
	width : 290,
	height : 290
});
</script>  

</body></html>